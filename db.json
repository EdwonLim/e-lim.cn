{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/tranquilpeak/source/assets/css/font-awesome.css","path":"assets/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/jquery.fancybox.css","path":"assets/css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/thumbs.css","path":"assets/css/thumbs.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/thumbs.js","path":"assets/js/thumbs.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/tranquilpeak.js","path":"assets/js/tranquilpeak.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/tranquilpeak.css","path":"assets/css/tranquilpeak.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.woff","path":"assets/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.woff2","path":"assets/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/style-1udptkpril81ozu8ifd8zpujn7ipu7lefxsiu5gxx0dpnzntdx6dusvki3ao.min.css","path":"assets/css/style-1udptkpril81ozu8ifd8zpujn7ipu7lefxsiu5gxx0dpnzntdx6dusvki3ao.min.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/style.css","path":"assets/css/style.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/FontAwesome.otf","path":"assets/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.eot","path":"assets/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.ttf","path":"assets/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/jquery.fancybox.js","path":"assets/js/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/script-yhuo2grt8r7qkqumzgjoglkfbicl1thukjgmla6jopu56zpcowfedi5zjcor.min.js","path":"assets/js/script-yhuo2grt8r7qkqumzgjoglkfbicl1thukjgmla6jopu56zpcowfedi5zjcor.min.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/cover.jpg","path":"assets/images/cover.jpg","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/jquery.js","path":"assets/js/jquery.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/cover-v1.2.0.jpg","path":"assets/images/cover-v1.2.0.jpg","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.svg","path":"assets/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/script.js","path":"assets/js/script.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"0e4b6097eb4cb64da15089c8cfd617e811a44ece","modified":1540365666998},{"_id":"source/404.md","hash":"a6b8a28fc3e9c0311a7e402bc3cb6f73fde4a105","modified":1527580644975},{"_id":"themes/tranquilpeak/.eslintignore","hash":"1f78f00553adf9ee374b343191ed809b0f8ba073","modified":1521393430000},{"_id":"themes/tranquilpeak/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1521394452000},{"_id":"themes/tranquilpeak/.eslintrc","hash":"b8227472c86456e77c456748f72fcbf93ea955ac","modified":1521393424000},{"_id":"themes/tranquilpeak/.gitignore","hash":"fa1331ae3eafab39a5b40cf5a011154043f9bf0e","modified":1521393430000},{"_id":"themes/tranquilpeak/.travis.yml","hash":"8a462414dfc70a5b30b97c1ea51185f3e4745ca1","modified":1521393432000},{"_id":"themes/tranquilpeak/DOCUMENTATION.md","hash":"af0d04f6d24fe9decb4ebf618ea37e3c5fd8d72e","modified":1521394350000},{"_id":"themes/tranquilpeak/Gruntfile.js","hash":"b2b078651cf8c5dcde2e847169ce242ad3319ca3","modified":1521393424000},{"_id":"themes/tranquilpeak/LICENSE","hash":"7a3b30ddb56760b35a6b7cd210aeb271cd292b60","modified":1521393424000},{"_id":"themes/tranquilpeak/README.md","hash":"e79c4571bda71a2b982162d5af27d4f876c2e652","modified":1521393430000},{"_id":"themes/tranquilpeak/_config.yml","hash":"582a6cf623600c69a39bcae8f78504c40a50e4ef","modified":1546581778383},{"_id":"themes/tranquilpeak/package.json","hash":"867285db4cc67e1c780251a16c2fc87375b53cf8","modified":1521393430000},{"_id":"source/_draft/2018-08-08-小程序工程化方案演进.md","hash":"260935e8f94592a087add225d9b62581502746a5","modified":1533656135830},{"_id":"source/_draft/2018-10-12-技术管理杂谈:从头马到车夫.md","hash":"8f77174b0e83cbcfeb397e5c37b57de0df6d88cd","modified":1543893419783},{"_id":"source/_posts/2015-10-04-WebIM实践过程中可能遇到的问题及总结.md","hash":"12ab3a5b7fb9390a83015bf027140691c60410db","modified":1527591260081},{"_id":"source/_posts/2015-10-07-前端工程师迈向全栈工程师之路.md","hash":"8494f92c78efcc9aef7038c04d495e178fc627d8","modified":1529896708179},{"_id":"source/_posts/2015-10-11-移动Hybrid开发加速器-模拟器.md","hash":"e1da8f3e65a8068f2d91bedebcda0bf4bbd9ef07","modified":1529896708180},{"_id":"source/_posts/2015-12-21-2015阿里巴巴D2前端论坛-参会总结.md","hash":"f1b916252ea407bd323cd440bf23d961ba246cdc","modified":1529896708180},{"_id":"source/_posts/2016-10-26-Use-Docker-In-Front-End-Development.md","hash":"913c4698e97363a344e5363344285ac819110e1d","modified":1529896708180},{"_id":"source/_posts/2017-01-01-Hy为了Native与Web彼此间的美好.md","hash":"89c25380b13b82434a73cfc52c36c7705514666d","modified":1529896708180},{"_id":"source/_posts/2017-04-26-混合开发中的JSBridge.md","hash":"24e6bb5535d572cffda3ae4a961c479bbd1e4bfa","modified":1529896733921},{"_id":"source/_posts/2017-09-20-写给前端应届生的职业规划建议.md","hash":"60e2dd3581cfd1e2991971e7b9bc9988a9f7838d","modified":1529896708180},{"_id":"source/_posts/2017-12-31-D2-2017.md","hash":"4320abf5fc0d139a1c4e36c8a729ac8a4c3ef933","modified":1529896708179},{"_id":"source/_posts/2018-01-11-the-use-of-block-chain-technology-in-tourism-industry.md","hash":"ef65d1f0d6908ef2013ef22f56d27ecc93122e36","modified":1529896708180},{"_id":"source/_posts/2018-03-10-用科学定义设计.md","hash":"486b18583701a056c203fa7af1c8f79803348edb","modified":1527587443187},{"_id":"source/_posts/2018-08-05-再谈移动端动态化方案.md","hash":"51cd469cc0b0cc9352944cfcfbb9b98ff62d1f78","modified":1533654320266},{"_id":"source/_posts/2018-10-10-深入Web缓存策略.md","hash":"2814dc430f7374ccf484604b4e57acd3f65e9e73","modified":1539175196953},{"_id":"source/_posts/2019-01-01-The_Next_Year_2019.md","hash":"93e079de339268941b36359997bc9df68e238338","modified":1546339795051},{"_id":"source/_posts/2019-01-02-[简悟]何为闭环.md","hash":"f211925c00c86e7909fcf29c75bd5dcfe0b7bb93","modified":1546413033525},{"_id":"source/all-archives/index.md","hash":"70239b47a1daff6184c195f317b6e4d4e468484f","modified":1527580491134},{"_id":"source/all-categories/index.md","hash":"3e36da8a208363a06f7d4553b96865e31787f10d","modified":1527580496190},{"_id":"source/all-tags/index.md","hash":"af9a2b81f84ec27edfac40e98e9ceab56b989c41","modified":1527580504557},{"_id":"source/favicon.ico","hash":"15405a61f48396aec5ede4cdc59522269c7b508f","modified":1529932496907},{"_id":"themes/tranquilpeak/languages/de-DE.yml","hash":"6054dd34bf3ccc00cd0ef88abd63a8ab5d65d19c","modified":1521393430000},{"_id":"themes/tranquilpeak/languages/en.yml","hash":"fd83558201c695b43e2f14ce1592d6125432b685","modified":1521393430000},{"_id":"themes/tranquilpeak/languages/es.yml","hash":"b4e0558f2dd9656a6a6089eef462d211ed039a6c","modified":1521393430000},{"_id":"themes/tranquilpeak/languages/fa.yml","hash":"d1013afe247b2a240f5d03d25e2c870994af6d3d","modified":1521393430000},{"_id":"themes/tranquilpeak/languages/fr-FR.yml","hash":"f3aa504b13a84e7e0bc75466abcea8e7e90838be","modified":1521393430000},{"_id":"themes/tranquilpeak/languages/it-IT.yml","hash":"2511c1dd63ac6c6c2c4da4e4aeaaf81eb5efb20d","modified":1521393430000},{"_id":"themes/tranquilpeak/languages/ja.yml","hash":"8c46dcbdfa981e614cf019b9b03c2d56b464a059","modified":1521393430000},{"_id":"themes/tranquilpeak/languages/pt-br.yml","hash":"e800caa9b58c5c07b0d7cf26abf74514121cb9eb","modified":1521393430000},{"_id":"themes/tranquilpeak/languages/ru.yml","hash":"b7f4d4df152d6e4a791958b7682c04fcd146c35e","modified":1521393430000},{"_id":"themes/tranquilpeak/languages/zh-cn.yml","hash":"e41582493eceea3c2df8095efa12e050af31ac3a","modified":1546579690174},{"_id":"themes/tranquilpeak/languages/zh-tw.yml","hash":"b1918a8911418d8a98e782dee8f303d1cb8b89f9","modified":1521393430000},{"_id":"themes/tranquilpeak/layout/all-archives.ejs","hash":"28a4e97d1cfe4730dbcc8fde27b079320b5eec35","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/all-categories.ejs","hash":"fa6f71b9543644df38cc1f33f8ed8223f91cc7a6","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/all-tags.ejs","hash":"aabb765f51a8d7582a5bafdbc8876b46ff1e6ea1","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/archive.ejs","hash":"0df1edf4ed40b316715ef1949b09aa9c98d22359","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/category.ejs","hash":"67902c418e299399133fe2a7ebc39cadd17de861","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/index.ejs","hash":"36e89b37f520533bef85fb32b714214257fad1d0","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/layout.ejs","hash":"29c1291c7ca3f5da7bee6385b7f716d179199933","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/page.ejs","hash":"ae761feddc98f4d3260e7591ed9fc91d9a49d0ab","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/post.ejs","hash":"ae761feddc98f4d3260e7591ed9fc91d9a49d0ab","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/tag.ejs","hash":"72bff1ae241fbe2ddca0537e8ed77c791a7d1766","modified":1521393424000},{"_id":"themes/tranquilpeak/scripts/.eslintrc.json","hash":"4cd7451f0bc15440bc8147912c63a11acd0e280f","modified":1521393430000},{"_id":"themes/tranquilpeak/tasks/pipeline.js","hash":"9c35bf63e39dcf989adf35b39c587290e6943e11","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/about.ejs","hash":"cffa945919c13f495185a44004b3c78265a2c9e6","modified":1527580123911},{"_id":"themes/tranquilpeak/layout/_partial/archive-post.ejs","hash":"e19455749c5c1bf773214d965f173613dd8f30f6","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/archive.ejs","hash":"bdd73d1f70bd91533863943f940f8193d44e0fdd","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/baidu-analytics.ejs","hash":"736eca2ecf6fdeea032d47c02c51688f006cafb4","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/cover.ejs","hash":"18b9a620fca9b648fd59467a66b3f4fdbba42613","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/footer.ejs","hash":"1480b15a30a963fe259cea47f67b3dc663e4e952","modified":1533658380872},{"_id":"themes/tranquilpeak/layout/_partial/google-analytics.ejs","hash":"0d0bc2c67d2cfab5fbf3d5d21c209d799f5de528","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/head.ejs","hash":"e7a3c6abbedf7a404776ed09676bcb0ac367d747","modified":1556611111965},{"_id":"themes/tranquilpeak/layout/_partial/header.ejs","hash":"9579d6aa6011d927d079639e80b28763a57f6b0b","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/index.ejs","hash":"d6f5cca078fd21721cff149bf383e7ee46774076","modified":1527589446603},{"_id":"themes/tranquilpeak/layout/_partial/pagination.ejs","hash":"207dd207e01eacda76b89e88a2ce95d898eadfca","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post.ejs","hash":"699c5447bde5190b0f3b8c91e0bfa3b1ada470ec","modified":1527589757705},{"_id":"themes/tranquilpeak/layout/_partial/script.ejs","hash":"7de0495bdd850fe93fb413f1d6417ab9bb52afb1","modified":1533661215944},{"_id":"themes/tranquilpeak/layout/_partial/search.ejs","hash":"c2e7449b4a980197f73c1cb163ab21fdc673351e","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/sidebar.ejs","hash":"c4925c7558608d596816df3063b56a470566cc93","modified":1527589818470},{"_id":"themes/tranquilpeak/scripts/filters/excerpt.js","hash":"5e0e473d46f8c7aac988ebf0b25ab2eab0af73bb","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/filters/thumbnail_image_url.js","hash":"0ad2d9304c991e2989708bdbfa6a59030ee691d3","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/helpers/absolute_url.js","hash":"0d520a946b6f0abbac60529017ed3133265aac60","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/helpers/generate_sharing_link.js","hash":"89069677e8acddef5fba0d3093f5f73fde4fa485","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/helpers/is_remote_url.js","hash":"471237ea295bcc9a392a5bb6738ef4c6ab673afb","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/helpers/json_ld.js","hash":"875f3a04b789ebb392169aca9f53c5e6cd4f8c35","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/helpers/resolve_asset_url.js","hash":"c813e9daaed374b386b91876923f10c0cf1d624c","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/tags/alert.js","hash":"5b86358dd53c9b0d44c385ec12cf9e76383e229a","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/tags/fancybox.js","hash":"55ce02f9ef084f43932eb9b0f10db1d5e9c3a250","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/tags/highlight_text.js","hash":"8e093f21e9a4b10c19be6f300dc90bcc39685ec9","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/tags/image.js","hash":"ab6b04db8fe2ad21ec52dac5e1c3ee76400c6a79","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/tags/tabbed_codeblock.js","hash":"7dccd36bdd85c96eb7af125b30d634f44125700c","modified":1521393430000},{"_id":"themes/tranquilpeak/scripts/tags/wide_image.js","hash":"d3596c62694548a3a684e8dfeb5372038ef6f450","modified":1521393430000},{"_id":"themes/tranquilpeak/source/_css/tranquilpeak.scss","hash":"e69c62b19ece4ab35d992e163b47f2a8374d7611","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/.eslintrc.json","hash":"27d4e7223eee3eca7eb717bea2d28d35714eccbc","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/about.js","hash":"47ecaf9e4532f4e36cf505de49a6a4357be030b2","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/archives-filter.js","hash":"8b8998b0e67c745a20450001c0739f6977b63309","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/categories-filter.js","hash":"a5f3c4b9bbef1c8ec881eb39551060ca95bfbb33","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/codeblock-resizer.js","hash":"391c2c9135579ea50c2060e0612e7105e06a8ff7","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/fancybox.js","hash":"659aaad375ecff9748a5d3b0ff1378a549236513","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/header.js","hash":"c274adf8f8010b9f4ba46896063859ae3e413e97","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/image-gallery.js","hash":"90efc47246af69b7e17fab6e0bd1578043fcc2b0","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/post-bottom-bar.js","hash":"11502f8c52489350c857b935a1a63f46d7ca5496","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/search-modal.js","hash":"7ea9ab668bc3118c28e6212516f366ef764d3550","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/share-options.js","hash":"c2046697540786721ff7c4754774f94fcaf32696","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/sidebar.js","hash":"18dc623dd237c519bb79ce93283a5446cc11a487","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/smartresize.js","hash":"7342a21f94d7bb0525ccbd917d43a6824d7ae63e","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/tabbed-codeblocks.js","hash":"465a7a60c609a3b2ac182ac164feea2fea00e0ec","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_js/tags-filter.js","hash":"d33625df51d7b9788eeea338626f04387c96f053","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/clean.js","hash":"ea70743eb4ed0d9ead68d6fc8b65b9f936229a00","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/concat.js","hash":"0c2c4dbbfac52f20a3035a2f8cd1c24f1759b17e","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/copy.js","hash":"9642e62ef9640bca9423dabefad8d0d1557cdcfa","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/cssmin.js","hash":"352185864437728c9c19169f4fec6fc3308e8b6d","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/replace.js","hash":"30fbbf51b8b41a70f5e76a335b50565f280f29e0","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/sails-linker.js","hash":"c1103119ec7d1f04cfbb1cda83b40d11e8f2d218","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/sass.js","hash":"79d65bad62ca0c2a8a155a76faa2be3b0c361bf0","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/sync.js","hash":"fbc09d0ed201993bc1918223b8f8ad5b68f50490","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/uglify.js","hash":"57c7341a004b61539f5b3f02bd772f40494b8306","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/config/watch.js","hash":"933eecd8a2506c627dbb9a1137305a16dd2d9f9a","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/register/build.js","hash":"959da556fe191cf51b6349f4f499be91ad2d501b","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/register/buildProd.js","hash":"5d9e617bc926e1a9edd9d1baedc2e9e66e715a19","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/register/compileAssets.js","hash":"a65122ba0d1a1b6044e3b635a644882577b628ba","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/register/default.js","hash":"80174db9b8a729980770e639e70999ce5a816b78","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/register/eslint.js","hash":"718cd8a80d060e2587b84e0e20ceaa39c2cc9411","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/register/linkAssets.js","hash":"079cd274cb29f9984eb7150d88f61819d2ef6235","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/register/linkAssetsProd.js","hash":"37f2fab80f25757be3e34b40bc5a26a82f088491","modified":1521393424000},{"_id":"themes/tranquilpeak/tasks/register/syncAssets.js","hash":"0813093c3e252a58371db53e914183a97e3186a1","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post/actions.ejs","hash":"ecda0a1f03e1df35b67a0cb6b879f88aba9554d3","modified":1546579539114},{"_id":"themes/tranquilpeak/layout/_partial/post/category.ejs","hash":"d4b26aa8c66aa8dbfae7a4aafed874745efb2f8e","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post/disqus.ejs","hash":"9e0d238ed918e3138d5a9bb23a90408669e19169","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post/duoshuo.ejs","hash":"992368f8863f34d1dccf90c0cabc33d5dcdbe92a","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post/gallery.ejs","hash":"09cd44fb300031266d04e7b2a4292f1a3ad5b574","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post/gitment.ejs","hash":"1dcfdca4d20bab5a43bda44cf37df506ab3a0fb7","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post/header-cover.ejs","hash":"4d3a73d0c6f26769f778d02a559e5055ef1ee0ca","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post/header.ejs","hash":"3c7d8aaf9ab28a3afb435b567f892729778adf08","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post/meta.ejs","hash":"772e627474442cdc2fce1c175db74d99fc2f8595","modified":1546578796175},{"_id":"themes/tranquilpeak/layout/_partial/post/share-options.ejs","hash":"b9b8b62345194f07542332771e71dad37f991847","modified":1521393424000},{"_id":"themes/tranquilpeak/layout/_partial/post/tag.ejs","hash":"2a52f38fa359f8ec8ae776e44e92c48795e31272","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/base/_base.scss","hash":"f0a46b090a0a4dd21edfd89095761895c5278ecb","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_alert.scss","hash":"3644442dfc16aa8a6894db1a605e325c856d44a9","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_archive.scss","hash":"6b7be2269d014c6c742a2c29c6a2aca39a383250","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_box.scss","hash":"eebaacf55234fdaa156edb7dc4d9a4f382eaf4d4","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_button.scss","hash":"ea9bd41800fe04860f7e892c17010588b2563a06","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_caption.scss","hash":"dad2683f5f3235b335eebcbda3db59a1cfbb2283","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_code.scss","hash":"0a14fe197c221a4d4d91ee9d41541ce7969043ca","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_fancybox.scss","hash":"e162e2ecafc2be70238a9885fd57a9a7ad642757","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_figure.scss","hash":"01152043de4e23f6595835941732563f09a033f3","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_form.scss","hash":"368187e0c5f1a57d8c423f2ec23e897ee94a1a27","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_hide.scss","hash":"c2f5ed51086b9ea5d94ff548bdc4653ea5cd7912","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_highlight-text.scss","hash":"7a7a8a78f75d6c43a46fd020e2d44546e716751b","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_icon.scss","hash":"60dc972bcd81b4f95ab2c067ca910a5bf324d907","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_image-gallery.scss","hash":"f683e80d69a0d5ac4e832d236ff5576cc749858a","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_link.scss","hash":"7460155ebf7ce0d3e9acd090b6b99673127fd0be","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_main-content.scss","hash":"90c46c87289a8b3cf7c14d36900f5ced9db36c25","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_markdown.scss","hash":"ba6d7e8f84b3b6dfef339f28b5c6ae372ead674f","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_media.scss","hash":"84aa03c01b741bbeb31c6b48122930f30ad40de3","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_modal.scss","hash":"bc56f823cd67b2ed65b5cf2c3e1851fa3e82f0f9","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_pagination.scss","hash":"809b9330a0e2d79c9285c1a452d61648248c8b70","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_post-actions.scss","hash":"6ecd72369cf03f59cfe749eab2712c5201cadd72","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_post-header-cover.scss","hash":"c4bf950602ccb3fbdad54938979651a7b488236e","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_post.scss","hash":"4aa8ed2aaaf5b61e78dea1b1e55dcbb539fa5941","modified":1527582331883},{"_id":"themes/tranquilpeak/source/_css/components/_postShorten.scss","hash":"4b545d89a2c4ce9857c2d83c942b3d78c09d8296","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_pullquote.scss","hash":"86bc35ba358d1340debc459a344f5f6d34acaa42","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_share-options-bar.scss","hash":"8965e62f215eff3209d9b6d3ff7b9203aa5f3974","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_tag.scss","hash":"ddd1c2ce17f0116655bdacda598e7f1d6fd18262","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_text.scss","hash":"7b38858248da2f73cf64c5949fd475a8e0a246ae","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_tooltip.scss","hash":"f33ad3e677761af1ceb42d337691b8b354ff70bd","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/components/_video.scss","hash":"f9727fd300d73e8844abf0e2575c45e6c7769333","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/layouts/_about.scss","hash":"52bdadfccaf3bc2082412348cd419c9da5793530","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/layouts/_blog.scss","hash":"2450e07594a5e5186170fb5b5b157cc340808a9a","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/layouts/_bottom-bar.scss","hash":"c7816c7ebc253d46466355860ead6669a3707ac6","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/layouts/_cover.scss","hash":"03a951c9b35dd4e35456caa36950e6d6bef77ac3","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/layouts/_footer.scss","hash":"645161942c66e6afbd666b4755337a6a6261e5e0","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/layouts/_header.scss","hash":"d840a4be850cb258167ee1081e1b288dc64b3d2c","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/layouts/_main.scss","hash":"ee4648502b355db51fc6cb7b05375003331f2f6e","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/layouts/_sidebar.scss","hash":"facaff0ca816a4ace67c7689e4286e88eb1010c2","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/pages/_search.scss","hash":"5f7cde0b68156ea802c3caf6cd673cab948b09d9","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/themes/_hljs-custom.scss","hash":"a0ffab53db35bbd4881aeb077400cba55551f3bd","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/themes/_hljs-tranquilpeak.scss","hash":"72bb30af91d08dbbd4092271eef288c40eeb7dbb","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/_fonts.scss","hash":"46f2edf56fb049f6d7289abfd5ad238a2c0c10dd","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/_variables.scss","hash":"f85f996b36a56a07d927e58ebcfffd9e21beaf6c","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/css/jquery.fancybox.css","hash":"a5913612c237bb7443c6006a386edd775201d423","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/css/thumbs.css","hash":"d805bc578c883345f0c2e533db2d2548281132c4","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/js/thumbs.js","hash":"9bd2831e83f5d851db6ceb4a3d354b59367a999b","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/js/tranquilpeak.js","hash":"68ac35debe2fff2bd50beede307ff86ee49480a3","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_images/cover.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/css/tranquilpeak.css","hash":"432e7bb0754963f490aa3d64f1a064189c7096e7","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_bottom-bar.scss","hash":"ab28b4d66f021e44d7a46a76157c6a2b5fd23496","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_button.scss","hash":"70c64560144d7d6015bbedeca0531258f9bafa07","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_category.scss","hash":"8cfc45772365e537949a4cd20cfa2a79e1a75dc8","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_form.scss","hash":"14026f13b54ef9f2cd7109cf1bca43040816e542","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_header.scss","hash":"52de2cb5f49a3b5748557fe2d25791ce52457d62","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_main.scss","hash":"0ad55a6191d0a533917845006ceae329353c0b90","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_opacity.scss","hash":"cfc9905b6df3b5100a30b5c47fd331068f238f97","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_post-header-cover.scss","hash":"ecd9078372d8bd1b7f4979bae3251e8efb345a9b","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_prefix.scss","hash":"5e04cd54ba375f69c97b62b7d4e535118ec78177","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_share-options-bar.scss","hash":"06f84bceb82df4d3bda64144f6fe4ad8e3e45f89","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_sidebar.scss","hash":"f9ef0a564553299225e9048462a0bea8760a2348","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_tag.scss","hash":"c8a87e586e27f999ffa46f273f78a812f1cf2f0a","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/css/style-1udptkpril81ozu8ifd8zpujn7ipu7lefxsiu5gxx0dpnzntdx6dusvki3ao.min.css","hash":"f6c328f363a65521f32007b09fda996ad2916990","modified":1546578771365},{"_id":"themes/tranquilpeak/source/assets/css/style.css","hash":"97c0d506d50dccce07ca74d9358b651e5e96c181","modified":1527582404531},{"_id":"themes/tranquilpeak/source/assets/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/js/jquery.fancybox.js","hash":"227dd641ffb92c1f0d1e6bb1c695fd4a05a13446","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/js/script-yhuo2grt8r7qkqumzgjoglkfbicl1thukjgmla6jopu56zpcowfedi5zjcor.min.js","hash":"160037ecfd42165894c2ea232cc472b30c4f315f","modified":1521393424000},{"_id":"themes/tranquilpeak/source/_images/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/images/cover.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/js/jquery.js","hash":"46a436eba01c79acdb225757ed80bf54bad6416b","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/images/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1521393424000},{"_id":"themes/tranquilpeak/source/assets/js/script.js","hash":"5e751b0e78c7041ded6c17cde69af5275d371911","modified":1527589203615},{"_id":"public/404.html","hash":"4525890f7bfc2895d131ed2984c97b493a1d2ed1","modified":1556611129149},{"_id":"public/all-categories/index.html","hash":"2f9b644c4607740057a1dc16ec50839327adc265","modified":1556611129149},{"_id":"public/archives/2015/index.html","hash":"55720466c50cc1547803c3a30d3fefa612582657","modified":1556611129150},{"_id":"public/archives/2015/10/index.html","hash":"bb8005722d48af14b52065833122c41c806fa82a","modified":1556611129150},{"_id":"public/archives/2015/12/index.html","hash":"b23b5dd995028643232ec0f913690ce40d8a530f","modified":1556611129151},{"_id":"public/archives/2016/index.html","hash":"8c6eb66d42865939edaecab9ffc6b6d222b28725","modified":1556611129151},{"_id":"public/archives/2016/10/index.html","hash":"103e2c53524fa64364deacfa76d14261e44a1567","modified":1556611129151},{"_id":"public/archives/2017/01/index.html","hash":"eb23df4e38ba33fb8d7d6f506c672c65c5e41dc4","modified":1556611129151},{"_id":"public/archives/2017/04/index.html","hash":"a086ba1f4456cdc58366b8270bc69d69865d2c1c","modified":1556611129151},{"_id":"public/archives/2017/09/index.html","hash":"3367e7742a512ab998d56c970d9f3a3db3bbea8c","modified":1556611129151},{"_id":"public/archives/2017/12/index.html","hash":"fbd3ec72ecbc0e29259ce354dea3ef2d2746d0a7","modified":1556611129151},{"_id":"public/archives/2018/01/index.html","hash":"a40332b90570a13058b4679638e7a8e2eabe1d77","modified":1556611129151},{"_id":"public/archives/2018/03/index.html","hash":"f785b346863618c9191cf465baa77d4ebcb803a3","modified":1556611129151},{"_id":"public/archives/2018/08/index.html","hash":"f8dc55b9affaac6f8d118c67f8e740c554965946","modified":1556611129151},{"_id":"public/archives/2018/10/index.html","hash":"5f13e1f86587150eedea7edf6a8ac4dd72e3bdda","modified":1556611129151},{"_id":"public/archives/2019/index.html","hash":"415229ac492a7de415511db36ee86df59d76b8a6","modified":1556611129151},{"_id":"public/archives/2019/01/index.html","hash":"5a9ddacafe9abc44031d14a9aa525b15e474d44a","modified":1556611129151},{"_id":"public/categories/潮流技术/index.html","hash":"d059d7ad26b240a001428fa47ca6ab3cdbc6ad58","modified":1556611129150},{"_id":"public/categories/产品设计/index.html","hash":"2f134d691a87279ed7b9452d71b985ef177208cb","modified":1556611129150},{"_id":"public/tags/Weibo/index.html","hash":"0590b79bc49828c1d872ea474016041bc9d2e06e","modified":1556611129152},{"_id":"public/tags/IM/index.html","hash":"05abf1f1c7acc86183d9c2c0cb9dc81568259808","modified":1556611129152},{"_id":"public/tags/前端/index.html","hash":"71a8a2e67d50a104644bd0898a10e41fe6364158","modified":1556611129152},{"_id":"public/tags/全栈/index.html","hash":"c5a276bc6485d0544acdd82a0ed5a9b77ebb762b","modified":1556611129152},{"_id":"public/tags/Mobile/index.html","hash":"ef1fae8af6b7242bd99ba08dce6f87932066b265","modified":1556611129152},{"_id":"public/tags/Debug/index.html","hash":"5ecd6d839b6b1000672f4ffe222faed10bf16a1a","modified":1556611129152},{"_id":"public/tags/D2/index.html","hash":"311657c1708e84525b06188a96a9864584266390","modified":1556611129152},{"_id":"public/tags/Docker/index.html","hash":"03873c7167e8de39244fd206ffa89e56fe068569","modified":1556611129152},{"_id":"public/tags/Bridge/index.html","hash":"0aa89c1072894e5cafb4ef35ea582f062fd08324","modified":1556611129152},{"_id":"public/tags/区块链/index.html","hash":"a02fc1a2672312bbb187e1eee2c37da40929999f","modified":1556611129152},{"_id":"public/tags/职业规划/index.html","hash":"b0c8aa22e8c441a12011374f26173034dc10873d","modified":1556611129152},{"_id":"public/tags/Design/index.html","hash":"4a6dc133a667dfa7f966c413213138b74a7c48a0","modified":1556611129152},{"_id":"public/tags/动态化/index.html","hash":"6bd6d284c99dec1cca55520d24fc82db8662f580","modified":1556611129152},{"_id":"public/tags/资源更新/index.html","hash":"ba0c6120af63a8523f76156e56dab1b1d9def9db","modified":1556611129153},{"_id":"public/tags/缓存/index.html","hash":"f42a90c4aae8c6019fa317f081bb575769f30aef","modified":1556611129153},{"_id":"public/tags/2019/index.html","hash":"db6c7c1857dbe8a9a35380ba29f85a21c667d1d3","modified":1556611129153},{"_id":"public/all-archives/index.html","hash":"4b222f4ac11764dfd265b61110d11a4a605ba7a3","modified":1556611129153},{"_id":"public/all-tags/index.html","hash":"8416e17d25df3c8702bd4a3e81719d2ccaa8211e","modified":1556611129153},{"_id":"public/20190101/index.html","hash":"91037cf341e73949b146756d5245de1dd8d3fb8b","modified":1556611129153},{"_id":"public/20181010/index.html","hash":"c3bc86980692897ae717d807295d8619ddb7f278","modified":1556611129153},{"_id":"public/20180805/index.html","hash":"cb03f560d62ee85b1513b2f9a8a27d54818b19d8","modified":1556611129153},{"_id":"public/20180310/index.html","hash":"ab7c2d5cfba458e4617bc7a13b18fce3da7f3586","modified":1556611129153},{"_id":"public/20180111/index.html","hash":"6c88d8b9f4783a8c0131ad42af0c77a45f70a0a1","modified":1556611129153},{"_id":"public/20171231/index.html","hash":"326bda05ec511ffdd28312d8343aec79a0c8f0b0","modified":1556611129153},{"_id":"public/20170920/index.html","hash":"51ecaf153b938e51d84623fd3e2f3dcacad84ecb","modified":1556611129153},{"_id":"public/20170426/index.html","hash":"92315effcab12048f510881b3f643b779067088d","modified":1556611129153},{"_id":"public/20170101/index.html","hash":"54a7983aba708bdd1cd03ae28c1762ed5f9cbb24","modified":1556611129154},{"_id":"public/20161026/index.html","hash":"34ef5f86e1db902e9850d4066a43f69b0c9b7669","modified":1556611129154},{"_id":"public/20151221/index.html","hash":"39b4e9c85036dc54b6607a2435625861afebc1f5","modified":1556611129154},{"_id":"public/20151011/index.html","hash":"f19585f25e36e16a344c8d574d5b3990f06efd86","modified":1556611129154},{"_id":"public/20151007/index.html","hash":"0910ea94eb9e410887ff96ef31325bdffed0778b","modified":1556611129154},{"_id":"public/20151004/index.html","hash":"5583bf609d4cec633ce34e04861b94160f045d35","modified":1556611129154},{"_id":"public/archives/index.html","hash":"57b319e674101a961fbb166fe73eb7aa4760a208","modified":1556611129154},{"_id":"public/archives/page/2/index.html","hash":"170aed8d56facab728d4ef8674dffbd12ff8ceb8","modified":1556611129150},{"_id":"public/archives/2017/index.html","hash":"17cc1d955b4218d89e50dbfd921b24ba34184ac9","modified":1556611129154},{"_id":"public/archives/2018/index.html","hash":"c5ef756497fcb6131761a1f1cdc9a1877cdfbfd0","modified":1556611129154},{"_id":"public/index.html","hash":"28d59a32697630e6ab424ab9d7996c1e8d29baba","modified":1556611129154},{"_id":"public/page/2/index.html","hash":"fca7c3c4d71c98838311e0b3f193c3143ba41df2","modified":1556611129152},{"_id":"public/categories/随笔/index.html","hash":"f143129473413eb3dd2574a1c049544934157eed","modified":1556611129154},{"_id":"public/categories/大前端技术/index.html","hash":"2c87e4054f58926ba52717da28ec8d277914fa50","modified":1556611129154},{"_id":"public/tags/Hybrid/index.html","hash":"c98ec2a8d2bc80ccfb16a7b1280f892d536d6e18","modified":1556611129155},{"_id":"public/books/index.html","hash":"9be62d7c4d973552023c85c3815d5e91bf44c553","modified":1556611129155},{"_id":"public/tags/简悟/index.html","hash":"0721012f888158a047e7301b2cd8318212ca5c92","modified":1546581842162},{"_id":"public/20190102/index.html","hash":"d65be544c43b06225e10848fdebed6141fbef6c7","modified":1546581842164},{"_id":"public/assets/js/thumbs.js","hash":"e2a1a76c86b7f605ddc5dd04274f8b35af1d5103","modified":1546571394831},{"_id":"public/assets/css/jquery.fancybox.css","hash":"a5913612c237bb7443c6006a386edd775201d423","modified":1546571394831},{"_id":"public/assets/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1546571394841},{"_id":"public/assets/js/tranquilpeak.js","hash":"68ac35debe2fff2bd50beede307ff86ee49480a3","modified":1546571394841},{"_id":"public/assets/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1546571394842},{"_id":"public/assets/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1546571394842},{"_id":"public/assets/css/thumbs.css","hash":"921a2c7359aecec27a5d60478a48501b493e7492","modified":1546571394848},{"_id":"public/assets/css/tranquilpeak.css","hash":"432e7bb0754963f490aa3d64f1a064189c7096e7","modified":1546571394848},{"_id":"public/assets/css/style-1udptkpril81ozu8ifd8zpujn7ipu7lefxsiu5gxx0dpnzntdx6dusvki3ao.min.css","hash":"e0005bfdcea9ce0a2395aeace0c2275d8f1a00d1","modified":1546571394848},{"_id":"public/assets/css/style.css","hash":"5faf33d719e39fdda55862794488892da49d5258","modified":1546571394848},{"_id":"public/assets/js/script-yhuo2grt8r7qkqumzgjoglkfbicl1thukjgmla6jopu56zpcowfedi5zjcor.min.js","hash":"160037ecfd42165894c2ea232cc472b30c4f315f","modified":1546571394849},{"_id":"public/assets/js/jquery.js","hash":"46a436eba01c79acdb225757ed80bf54bad6416b","modified":1546571394849},{"_id":"public/assets/js/script.js","hash":"af69c4f7373b3a88e1257b11953ef154da5c4979","modified":1546571394849},{"_id":"public/assets/js/jquery.fancybox.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1546571394849},{"_id":"public/favicon.ico","hash":"15405a61f48396aec5ede4cdc59522269c7b508f","modified":1546571394849},{"_id":"public/assets/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1546571394849},{"_id":"public/assets/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1546571394849},{"_id":"public/assets/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1546571394850},{"_id":"public/assets/images/cover.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1546571394852},{"_id":"public/assets/images/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1546571394853},{"_id":"public/assets/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1546571394855},{"_id":"source/_draft/2019-01-02-[简悟]何为闭环.md","hash":"f211925c00c86e7909fcf29c75bd5dcfe0b7bb93","modified":1547724142560},{"_id":"source/reicalc.html","hash":"f8b65601e44ecfef4693a824baa4aa81cc87eadb","modified":1558689022828},{"_id":"public/reicalc.html","hash":"17d11aad587754bf408816915e3f47cdad13f45d","modified":1558689041909},{"_id":"source/eicalc.html","hash":"2d5aae559eefdd0daf32e2289b75ea4b9ce613f8","modified":1558693102645},{"_id":"public/eicalc.html","hash":"04440bc0fabe3bc198cad0a02ef6e2733616e059","modified":1558693120991}],"Category":[{"name":"随笔","_id":"cjqhgoc6x0005hxp4ezqrqcop"},{"name":"大前端技术","_id":"cjqhgoc76000ghxp45ssbqdm9"},{"name":"潮流技术","_id":"cjqhgoc78000ohxp4e20wlxe1"},{"name":"产品设计","_id":"cjqhgoc7f001bhxp45qbyl1g5"}],"Data":[],"Page":[{"title":"页面找不到","meta":false,"actions":false,"comments":0,"_content":"","source":"404.md","raw":"---\ntitle: 页面找不到\nmeta: false\nactions: false\ncomments: false\n---\n","date":"2018-05-29T07:57:24.975Z","updated":"2018-05-29T07:57:24.975Z","path":"404.html","layout":"page","_id":"cjqhgoc610000hxp4y1g2g5ul","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"归档","layout":"all-archives","comments":0,"_content":"","source":"all-archives/index.md","raw":"---\ntitle: \"归档\"\nlayout: \"all-archives\"\ncomments: false\n---\n","date":"2018-05-29T07:54:51.134Z","updated":"2018-05-29T07:54:51.134Z","path":"all-archives/index.html","_id":"cjqhgoc6v0002hxp4bl26hus5","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"分类","layout":"all-categories","comments":0,"_content":"","source":"all-categories/index.md","raw":"---\ntitle: \"分类\"\nlayout: \"all-categories\"\ncomments: false\n---\n","date":"2018-05-29T07:54:56.190Z","updated":"2018-05-29T07:54:56.190Z","path":"all-categories/index.html","_id":"cjqhgoc6w0004hxp4o07sxehx","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"标签","layout":"all-tags","comments":0,"_content":"","source":"all-tags/index.md","raw":"---\ntitle: \"标签\"\nlayout: \"all-tags\"\ncomments: false\n---\n","date":"2018-05-29T07:55:04.557Z","updated":"2018-05-29T07:55:04.557Z","path":"all-tags/index.html","_id":"cjqhgoc6z0008hxp4grm5w7pe","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"layout":"false","_content":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\" />\n    <link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css\" />\n\n    <title>Estate Investment Calculator</title>\n</head>\n\n<body>\n    <nav class=\"navbar navbar-light bg-light\">\n        <span class=\"navbar-brand mb-0 h1\" style=\"margin: 0 auto\">房产投资计算器</span>\n    </nav>\n    <div class=\"container\">\n        <form data-toggle=\"formcache\">\n            <div class=\"form-group\">\n                <label for=\"price\">单价</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"price\" id=\"price\" aria-describedby=\"priceHelp\"\n                        placeholder=\"输入房产单价\" value=\"10000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"priceHelp\" class=\"form-text text-muted\">房产单价</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"area\">面积</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"area\" id=\"area\" aria-describedby=\"areaHelp\"\n                        placeholder=\"输入房产面积\" value=\"90\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">平</span>\n                    </div>\n                </div>\n                <small id=\"areaHelp\" class=\"form-text text-muted\">房产面积</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"pay\">首付</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"pay\" id=\"pay\" aria-describedby=\"payHelp\"\n                        placeholder=\"输入首付金额\" value=\"270000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"payHelp\" class=\"form-text text-muted\">首付，默认房产总价 30%</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"other\">手续费、契税等支出</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"other\" id=\"other\" aria-describedby=\"otherHelp\"\n                        placeholder=\"输入手续费、契税等支出金额\" value=\"18000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"otherHelp\" class=\"form-text text-muted\">手续费，默认房产总价 2%（1% 契税，1% 公共维修基金）</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【房产信息】<br />\n                <span id=\"info1\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"rate\">房贷利率</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"rate\" id=\"rate\" aria-describedby=\"rateHelp\"\n                        placeholder=\"输入手续费、契税等支出金额\" value=\"4.9\" step=\"0.01\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"rateHelp\" class=\"form-text text-muted\">房贷，默认：4.9，商贷基准利率</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"float\">利率浮动</label>\n                <select class=\"form-control\" name=\"float\" id=\"float\" aria-describedby=\"floatHelp\">\n                    <option value=\"0.80\">八折优惠( -20% )</option>\n                    <option value=\"0.85\">八五折优惠( -15% )</option>\n                    <option value=\"0.90\">九折优惠( -10% )</option>\n                    <option value=\"0.95\">九五折优惠( -5% )</option>\n                    <option value=\"1.00\" selected>正常利率( +0% )</option>\n                    <option value=\"1.05\">上浮5个点( +5% )</option>\n                    <option value=\"1.10\">上浮10个点( +10% )</option>\n                    <option value=\"1.15\">上浮15个点( +15% )</option>\n                    <option value=\"1.20\">上浮20个点( +20% )</option>\n                </select>\n                <small id=\"floatHelp\" class=\"form-text text-muted\">利率浮动，默认不上浮也不打折</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"year\">贷款年限</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"year\" id=\"year\" aria-describedby=\"yearHelp\"\n                        placeholder=\"输入贷款年限\" value=\"25\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"yearHelp\" class=\"form-text text-muted\">贷款年限，单位：年，默认25，当前最长年数</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【贷款信息】<br />\n                <span id=\"info2\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"get\">交房时间</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"get\" id=\"get\" aria-describedby=\"getHelp\"\n                        placeholder=\"输入交房时间\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"getHelp\" class=\"form-text text-muted\">几年后交房，单位：年，除期房，都是 0</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"sell\">预计卖房时间</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"sell\" id=\"sell\" aria-describedby=\"sellHelp\"\n                        placeholder=\"输入预计卖房时间\" value=\"5\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"sellHelp\" class=\"form-text text-muted\">几年后卖房，单位：年，默认交房时间 + 5（满五）</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【卖房时成本信息】<br />\n                <span id=\"info3\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"expenditure\">每年持有支出</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"expenditure\" id=\"expenditure\"\n                        aria-describedby=\"expenditureHelp\" placeholder=\"输入预计卖房时间\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"expenditureHelp\" class=\"form-text text-muted\">每年持有房屋的花费，单位：元，包括物业费、暖气费、交通费等</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"income\">每年营租收入</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"income\" id=\"income\" aria-describedby=\"incomeHelp\"\n                        placeholder=\"输入每年营租收入\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"incomeHelp\" class=\"form-text text-muted\">每年营租收入，单位：元，包括租房、Airbnb 等</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【核算支出/收入金额】<br />\n                <span id=\"info4\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"3rate\">银行定期利率（大于等于 3 年）</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"3rate\" id=\"3rate\" aria-describedby=\"3rateHelp\"\n                        placeholder=\"输入定期利率\" value=\"4\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"3rateHelp\" class=\"form-text text-muted\">银行定期利率，超过 3 年的，利率都差不多，粗算一下。</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"1rate\">银行定期利率（小于 3 年）</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"1rate\" id=\"1rate\" aria-describedby=\"1rateHelp\"\n                        placeholder=\"输入定期利率\" value=\"2\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"1rateHelp\" class=\"form-text text-muted\">银行定期利率，不到 3 年的，利率都差不多，粗算一下。</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【利息收入】<br />\n                <span id=\"info5\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"swell\">通货膨胀率</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"swell\" id=\"swell\" aria-describedby=\"swellHelp\"\n                        placeholder=\"输入通货膨胀率\" value=\"7\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"swellHelp\" class=\"form-text text-muted\">通货膨胀率，决定于政府调控，一般通货膨胀率是 7%，各国基本一致。</small>\n            </div>\n            <!-- <p class=\"text-center\">\n                <button type=\"submit\" class=\"btn btn-primary\">分析计算</button>\n            </p> -->\n            <div class=\"alert alert-success\" role=\"alert\">\n                【通膨抵消】<br />\n                <span id=\"info6\"></span>\n            </div>\n            <hr />\n            <div class=\"alert alert-primary\" role=\"alert\">\n                【信息汇总】<br />\n                <span id=\"info7\"></span>\n            </div>\n            <div class=\"alert alert-danger\" role=\"alert\">\n                【卖时成本】<br />\n                <span id=\"info8\"></span>\n            </div>\n            <div class=\"alert alert-warning\" role=\"alert\">\n                【收益计算】<br />\n                <span id=\"info9\"></span>\n            </div>\n            <hr />\n        </form>\n    </div>\n\n    <script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/jquery-url-parser/2.3.1/purl.min.js\"></script>\n    <script>\n        /*!\n         * Form Cache v0.0.3\n         * https://github.com/fengyuanchen/formcache\n         *\n         * Copyright 2014 Fengyuan Chen\n         * Released under the MIT license\n         *\n         * Date: 2014-12-17T12:42:29.194Z\n         */\n        ! function (a) {\n            \"function\" == typeof define && define.amd ? define(\"formcache\", [\"jquery\"], a) : a(jQuery)\n        }(function (a) {\n            \"use strict\";\n            var b = a(window),\n                c = window.sessionStorage,\n                d = window.localStorage,\n                e = \"undefined\",\n                f = \".formcache\",\n                g = /[\\.\\*\\+\\^\\$\\:\\!\\[\\]#>~]+/g,\n                h = \"change\" + f,\n                i = \"beforeunload\" + f,\n                j = function (a) {\n                    return \"checkbox\" === a.type || \"radio\" === a.type\n                },\n                k = function (a) {\n                    return parseInt(a, 10)\n                },\n                l = function (b, c) {\n                    this.form = b, this.$form = a(b), this.defaults = a.extend({}, l.DEFAULTS, a.isPlainObject(c) ?\n                        c : {}), this.init()\n                };\n            l.prototype = {\n                    constructor: l,\n                    init: function () {\n                        var b = this.defaults;\n                        b.maxAge = Math.abs(b.maxAge || b.maxage), b.autoStore = Boolean(b.autoStore || b\n                                .autostore), this.initKey(), this.initStorage(), this.caches = this.storage\n                            .caches, this.index = 0, this.activeIndex = 0, this.storing = null, a.isArray(b\n                                .controls) || (b.controls = []), this.$controls = this.$form.find(b.controls\n                                .join()).not(\":file\"), this.addListeners(), this.outputCache()\n                    },\n                    initKey: function () {\n                        var b = this.$form,\n                            c = this.defaults.key || b.data(\"key\");\n                        c || (a(\"form\").each(function (b) {\n                            a(this).data(\"key\", b)\n                        }), c = b.data(\"key\")), this.key = location.pathname + \"#formcache-\" + c\n                    },\n                    initStorage: function () {\n                        var b, e = this.defaults,\n                            f = this.key,\n                            g = new Date,\n                            h = {\n                                date: g,\n                                maxAge: e.maxAge,\n                                caches: []\n                            };\n                        c && (b = c.getItem(f)), !b && d && (b = d.getItem(f)), b = \"string\" == typeof b ? JSON\n                            .parse(b) : null, a.isPlainObject(b) ? \"number\" == typeof b.maxAge && (g - new Date(\n                                b.date)) / 1e3 > b.maxAge && (b = h) : b = h, this.storage = b\n                    },\n                    addListeners: function () {\n                        this.defaults.autoStore && (this.$controls.on(h, a.proxy(this.change, this)), b.on(i, a\n                            .proxy(this.beforeunload, this)))\n                    },\n                    removeListeners: function () {\n                        this.defaults.autoStore && (this.$controls.off(h, this.change), b.off(i, this\n                            .beforeunload))\n                    },\n                    change: function (b) {\n                        var c, d, e = b.target,\n                            f = a(e),\n                            h = f.attr(\"name\"),\n                            i = [];\n                        h && (c = h.replace(g, \"\"), this.$controls.filter('[name*=\"' + c + '\"]').each(\n                            function () {\n                                j(e) ? i.push(this.checked) : (d = a(this).val(), d && i.push(d))\n                            }), i.length && (this.update(h, i), clearTimeout(this.storing), this\n                            .storing =\n                            setTimeout(a.proxy(this.store, this), 1e3)))\n                    },\n                    beforeunload: function () {\n                        this.update(), this.store()\n                    },\n                    update: function (a, b) {\n                        var c = this.activeIndex || this.index,\n                            d = this.getCache(c);\n                        \"string\" == typeof a ? d[a] = b : d = this.serialize(), this.setCache(c, d)\n                    },\n                    serialize: function () {\n                        var b = {};\n                        return this.$controls.each(function () {\n                            var c, d, e = a(this),\n                                f = e.attr(\"name\");\n                            f && (c = b[f], c = a.isArray(c) ? c : [], j(this) ? c.push(this.checked) :\n                                (d = e.val(), d && c.push(d)), c.length && (b[f] = c))\n                        }), b\n                    },\n                    getCache: function (a) {\n                        return this.caches[k(a) || this.index] || {}\n                    },\n                    getCaches: function () {\n                        return this.caches\n                    },\n                    setCache: function (b, c) {\n                        typeof c === e && (c = b, b = 0 / 0), a.isPlainObject(c) && (b = k(b) || this.index,\n                            this.caches[b] = c, this.store())\n                    },\n                    setCaches: function (b) {\n                        a.isArray(b) && (this.caches = b, this.store())\n                    },\n                    removeCache: function (a) {\n                        this.caches.splice(k(a) || this.index, 1), this.store()\n                    },\n                    removeCaches: function () {\n                        this.caches = [], this.store()\n                    },\n                    outputCache: function (b) {\n                        var c = this.getCache(b);\n                        a.isPlainObject(c) && (this.activeIndex = k(b) || this.index, c = a.extend(!0, {}, c),\n                            this.$controls.each(function () {\n                                var b, d, e = a(this),\n                                    f = e.attr(\"name\");\n                                f && (b = c[f], a.isArray(b) && b.length && (d = b.shift(), j(this) ?\n                                    this.checked = d : e.val(d)))\n                            }))\n                    },\n                    store: function () {\n                        var a = this.storage,\n                            b = this.key,\n                            e = this.defaults;\n                        a.date = new Date, a.maxAge = e.maxAge, a = JSON.stringify(a), e.session && c && c\n                            .setItem(b, a), e.local && d && d.setItem(b, a)\n                    },\n                    clear: function () {\n                        var a = this.key,\n                            b = this.defaults;\n                        b.session && c && c.removeItem(a), b.local && d && d.removeItem(a)\n                    },\n                    destroy: function () {\n                        this.removeListeners(), this.$form.removeData(\"formcache\")\n                    }\n                }, l.DEFAULTS = {\n                    key: \"\",\n                    local: !0,\n                    session: !0,\n                    autoStore: !0,\n                    maxAge: void 0,\n                    controls: [\"select\", \"textarea\", \"input\"]\n                }, l.setDefaults = function (b) {\n                    a.extend(l.DEFAULTS, b)\n                }, l.other = a.fn.formcache, a.fn.formcache = function (b) {\n                    var c, d = [].slice.call(arguments, 1);\n                    return this.each(function () {\n                        var e, f = a(this),\n                            g = f.data(\"formcache\");\n                        g || f.data(\"formcache\", g = new l(this, b)), \"string\" == typeof b && a.isFunction(\n                            e = g[b]) && (c = e.apply(g, d))\n                    }), typeof c !== e ? c : this\n                }, a.fn.formcache.Constructor = l, a.fn.formcache.setDefaults = l.setDefaults, a.fn.formcache\n                .noConflict = function () {\n                    return a.fn.formcache = l.other, this\n                }, a(function () {\n                    a('form[data-toggle=\"formcache\"]').formcache()\n                })\n        });\n    </script>\n    <script>\n        (() => {\n            const cache = {};\n            // 计算\n            const getLoan = () => {\n                const values = getValues();\n                const loan = values.area * values.price - values.pay;\n                return loan;\n            };\n\n            const getSupply = () => {\n                const values = getValues();\n                const monthRate = values.rate * values.float / 12 / 100;\n                const loan = getLoan();\n                const supply = loan * monthRate * Math.pow(1 + monthRate, values.year * 12) / (Math.pow(1 + monthRate,\n                    values.year * 12) - 1);\n                return supply;\n            };\n\n            const getTotalRepay = () => {\n                const values = getValues();\n                const monthRate = values.rate * values.float / 12 / 100;\n                const loan = getLoan();\n                const supply = getSupply();\n\n                let total = 0;\n                for (let i = 1; i <= values.sell * 12; i++) {\n                    total += supply - (loan * monthRate * (Math.pow(1 + monthRate, values.year * 12) - Math.pow(1 +\n                        monthRate, i - 1))) / (Math.pow(1 + monthRate, values.year * 12) - 1);\n                }\n\n                return total;\n            };\n\n            const getBankIncome = () => {\n                const values = getValues();\n                const rate3 = values['3rate'] / 100;\n                const rate1 = values['1rate'] / 100;\n                const payment = values.pay + values.other;\n                const supply = getSupply();\n                let total = payment * values.sell * rate3;\n                for (let i = values.sell - 1; i >= 3; i --) {\n                    total += supply * 12 * values.sell * rate3;\n                }\n                total += supply * 12 * 3 * rate1;\n                return total;\n            };\n\n            const getSwell = () => {\n                const values = getValues();\n                const supply = getSupply();\n                const swellRate = values.swell / 100;\n                let base = values.pay + values.other;\n                let total = base * Math.pow(1 +　swellRate, 8);\n                for (let i = values.sell - 1; i >= 1; i --) {\n                    base += supply * 12;\n                    total += supply * 12 * Math.pow(1 +　swellRate, i);\n                }\n                return total - base;\n            };\n\n            // 关联\n            const changePay = () => {\n                const values = getValues();\n                $(`#pay`).val((values.area * values.price) * 0.3);\n            };\n\n            const changeOther = () => {\n                const values = getValues();\n                $(`#other`).val((values.area * values.price) * 0.02);\n            };\n\n            const changeSell = () => {\n                const values = getValues();\n                $(`#sell`).val(parseInt(values.get) + 5);\n            };\n\n            // 分析\n            const changeInfo1 = () => {\n                const values = getValues();\n                $('#info1').html(\n                    `总价 ${(values.area * values.price / 10000).toFixed(2)} 万元，首付 ${((values.pay + values.other) / 10000).toFixed(2)} 万元，贷款 ${((values.area * values.price - values.pay) / 10000).toFixed(2)} 万元。`\n                );\n                cache.total = (values.area * values.price / 10000).toFixed(2);\n                cache.payment = ((values.pay + values.other) / 10000).toFixed(2);\n                cache.liabilities = ((values.area * values.price - values.pay) / 10000).toFixed(2);\n                changeInfo3();\n                changeInfo7();\n            };\n\n            const changeInfo2 = () => {\n                const values = getValues();\n                const loan = getLoan();\n                const supply = getSupply();\n                $('#info2').html(\n                    `· 年利率 ${(values.rate * values.float).toFixed(2)}%，年限 ${values.year} 年（ ${values.year * 12} 个月）。<br/>` + \n                    `· 等额本息月供 ${supply.toFixed(2)} 元，利息总和为 ${((supply * values.year * 12 - loan) / 10000).toFixed(2)} 万元。`\n                    );\n                cache.supply = supply.toFixed(2);\n                changeInfo3();\n                changeInfo7();\n            };\n\n            const changeInfo3 = () => {\n                const values = getValues();\n                const loan = getLoan();\n                const supply = getSupply();\n                const totalRepay = getTotalRepay();\n                const total = values.pay + values.other + values.sell * 12 * supply + loan - totalRepay;\n                $('#info3').html(\n                    `· 已经还款 ${values.sell * 12} 个月， 共还款 ${(values.sell * 12 * supply / 10000).toFixed(2)} 万元, 供还本金 ${(totalRepay / 10000).toFixed(2)} 万元，剩余本金 ${((loan - totalRepay) / 10000).toFixed(2)} 万元。<br/>` +\n                    `· 总成本为：${values.pay + values.other}(首付) + ${(values.sell * 12 * supply).toFixed(2)}(还款) + ${(loan - totalRepay).toFixed(2)}(剩余本金) = ${(total).toFixed(2)} 元 = ${(total / 10000).toFixed(2)} 万元。<br/>` +\n                    `· 对应每平单价为： ${(total / values.area).toFixed(0)} 元。`\n                );\n                cache.cost = total;\n                changeInfo4();\n                changeInfo5();\n                changeInfo6();\n            };\n\n            const changeInfo4 = () => {\n                const values = getValues();\n                $('#info4').html(\n                    `共营收 ${(values.income - values.expenditure) * (values.sell - values.get)} 元，对应每平减少成本 ${(((values.income - values.expenditure) * (values.sell - values.get)) / values.area).toFixed(0)} 元。`\n                    );\n                cache.totalIncome = (values.income - values.expenditure) * (values.sell - values.get);\n                changeInfo8();\n            };\n\n            const changeInfo5 = () => {\n                const values = getValues();\n                const bankIncome = getBankIncome();\n                $('#info5').html(\n                    `首付存定期，月供每年一次存定期，直接存到卖房时，获得的利息为 ${(bankIncome / 10000).toFixed(2)} 万元，对应每平增加成本 ${(bankIncome / values.area).toFixed(0)} 元。`\n                    );\n                changeInfo9();\n            };\n\n            const changeInfo6 = () => {\n                const values = getValues();\n                const swell = getSwell();\n                $('#info6').html(\n                    `抵消通货膨胀，需要增加收入 ${(swell / 10000).toFixed(2)} 万元，平均每平米需再增长 ${(swell / values.area).toFixed(0)} 元。`\n                    );\n                changeInfo9();\n            };\n\n            const changeInfo7 = () => {\n                const values = getValues();\n                $('#info7').html([\n                    `<ul>`, \n                        `<li>总价：${cache.total} 万元</li>`,\n                        `<li>单价：${values.price} 元</li>`,\n                        `<li>首付：${cache.payment} 万元</li>`,\n                        `<li>贷款：${cache.liabilities} 万元</li>`,\n                        `<li>月供：${cache.supply} 元</li>`,\n                    `</ul>`\n                ].join(''));\n            };\n\n            const changeInfo8 = () => {\n                const values = getValues();\n                $('#info8').html([\n                    `<ul>`, \n                        `<li>成本：${((cache.cost - cache.totalIncome) / 10000).toFixed(2)} 万元</li>`,\n                        `<li>单价：${((cache.cost - cache.totalIncome) / values.area).toFixed(0)} 元</li>`,\n                    `</ul>`\n                ].join(''));\n\n            };\n\n            const changeInfo9 = () => {\n                const values = getValues();\n                $('#info9').html([\n                    `<ul>`, \n                        `<li>总价达到 ${((cache.cost - cache.totalIncome + getBankIncome()) / 10000).toFixed(2)} 万元，能与银行定期收益持平，对应单价为 ${((cache.cost - cache.totalIncome + getBankIncome()) / values.area).toFixed(0)} 元。</li>`,\n                        `<li>总价达到 ${((cache.cost - cache.totalIncome + getSwell()) / 10000).toFixed(2)} 万元，能抵消通货膨胀，对应单价为 ${((cache.cost - cache.totalIncome + getSwell()) / values.area).toFixed(0)} 元。</li>`,\n                    `</ul>`\n                ].join(''));\n            };\n\n            const inputOpts = {\n                price: {\n                    default: 10000,\n                    change: [changePay, changeOther, changeInfo1]\n                },\n                area: {\n                    default: 90,\n                    change: [changePay, changeOther, changeInfo1]\n                },\n                pay: {\n                    default: 270000,\n                    change: [changeInfo1]\n                },\n                other: {\n                    default: 18000,\n                    change: [changeInfo1]\n                },\n                rate: {\n                    default: 4.9,\n                    change: [changeInfo2]\n                },\n                float: {\n                    default: '1.00',\n                    change: [changeInfo2]\n                },\n                year: {\n                    default: 25,\n                    change: [changeInfo2]\n                },\n                get: {\n                    default: 0,\n                    change: [changeSell, changeInfo3]\n                },\n                sell: {\n                    default: 5,\n                    change: [changeInfo3]\n                },\n                expenditure: {\n                    default: 0,\n                    change: [changeInfo4]\n                },\n                income: {\n                    default: 0,\n                    change: [changeInfo4]\n                },\n                '3rate': {\n                    default: 4,\n                    change: [changeInfo5]\n                },\n                '1rate': {\n                    default: 2,\n                    change: [changeInfo5]\n                },\n                swell: {\n                    default: 7,\n                    change: [changeInfo6]\n                }\n            };\n\n            const getValues = () => {\n                const res = {};\n                Object.keys(inputOpts).forEach((key) => {\n                    res[key] = parseFloat($(`#${key}`).val());\n                });\n                return res;\n            };\n\n\n            const handleChange = (e) => {\n                const id = e.target.id;\n                const opt = inputOpts[id];\n                if (opt.change) {\n                    [].concat(opt.change).forEach(t => t());\n                }\n                var cache = $('form').formcache('serialize');\n                $('form').formcache('setCache', cache);\n                history.replaceState(null, document.title, \"/eicalc.html?data=\" + encodeURIComponent(JSON.stringify(cache)));\n            };\n\n            $(() => {\n                $('form').delegate('input', 'focus', (e) => {\n                    const value = e.target.value;\n                    e.target.value = '';\n                    const onblur = () => {\n                        if (isNaN(parseFloat(e.target.value))) {\n                            e.target.value = value;\n                            handleChange(e);\n                        }\n                        e.target.removeEventListener('blur', onblur);\n                    };\n                    e.target.addEventListener('blur', onblur, false);\n                });\n\n                $('form').delegate('input,select', 'change', handleChange);\n                const data = $.url().param('data');\n                if (data) {\n                    try {\n                        const cache = JSON.parse(decodeURIComponent(data));\n                        $('form').formcache('setCache', cache);\n                    } catch(e) {}\n                }\n                $('form').formcache('outputCache');\n                changeInfo1();\n                changeInfo2();\n            });\n        })();\n    </script>\n</body>\n\n</html>","source":"eicalc.html","raw":"---\nlayout: false\n---\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\" />\n    <link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css\" />\n\n    <title>Estate Investment Calculator</title>\n</head>\n\n<body>\n    <nav class=\"navbar navbar-light bg-light\">\n        <span class=\"navbar-brand mb-0 h1\" style=\"margin: 0 auto\">房产投资计算器</span>\n    </nav>\n    <div class=\"container\">\n        <form data-toggle=\"formcache\">\n            <div class=\"form-group\">\n                <label for=\"price\">单价</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"price\" id=\"price\" aria-describedby=\"priceHelp\"\n                        placeholder=\"输入房产单价\" value=\"10000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"priceHelp\" class=\"form-text text-muted\">房产单价</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"area\">面积</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"area\" id=\"area\" aria-describedby=\"areaHelp\"\n                        placeholder=\"输入房产面积\" value=\"90\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">平</span>\n                    </div>\n                </div>\n                <small id=\"areaHelp\" class=\"form-text text-muted\">房产面积</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"pay\">首付</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"pay\" id=\"pay\" aria-describedby=\"payHelp\"\n                        placeholder=\"输入首付金额\" value=\"270000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"payHelp\" class=\"form-text text-muted\">首付，默认房产总价 30%</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"other\">手续费、契税等支出</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"other\" id=\"other\" aria-describedby=\"otherHelp\"\n                        placeholder=\"输入手续费、契税等支出金额\" value=\"18000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"otherHelp\" class=\"form-text text-muted\">手续费，默认房产总价 2%（1% 契税，1% 公共维修基金）</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【房产信息】<br />\n                <span id=\"info1\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"rate\">房贷利率</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"rate\" id=\"rate\" aria-describedby=\"rateHelp\"\n                        placeholder=\"输入手续费、契税等支出金额\" value=\"4.9\" step=\"0.01\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"rateHelp\" class=\"form-text text-muted\">房贷，默认：4.9，商贷基准利率</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"float\">利率浮动</label>\n                <select class=\"form-control\" name=\"float\" id=\"float\" aria-describedby=\"floatHelp\">\n                    <option value=\"0.80\">八折优惠( -20% )</option>\n                    <option value=\"0.85\">八五折优惠( -15% )</option>\n                    <option value=\"0.90\">九折优惠( -10% )</option>\n                    <option value=\"0.95\">九五折优惠( -5% )</option>\n                    <option value=\"1.00\" selected>正常利率( +0% )</option>\n                    <option value=\"1.05\">上浮5个点( +5% )</option>\n                    <option value=\"1.10\">上浮10个点( +10% )</option>\n                    <option value=\"1.15\">上浮15个点( +15% )</option>\n                    <option value=\"1.20\">上浮20个点( +20% )</option>\n                </select>\n                <small id=\"floatHelp\" class=\"form-text text-muted\">利率浮动，默认不上浮也不打折</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"year\">贷款年限</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"year\" id=\"year\" aria-describedby=\"yearHelp\"\n                        placeholder=\"输入贷款年限\" value=\"25\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"yearHelp\" class=\"form-text text-muted\">贷款年限，单位：年，默认25，当前最长年数</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【贷款信息】<br />\n                <span id=\"info2\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"get\">交房时间</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"get\" id=\"get\" aria-describedby=\"getHelp\"\n                        placeholder=\"输入交房时间\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"getHelp\" class=\"form-text text-muted\">几年后交房，单位：年，除期房，都是 0</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"sell\">预计卖房时间</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"sell\" id=\"sell\" aria-describedby=\"sellHelp\"\n                        placeholder=\"输入预计卖房时间\" value=\"5\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"sellHelp\" class=\"form-text text-muted\">几年后卖房，单位：年，默认交房时间 + 5（满五）</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【卖房时成本信息】<br />\n                <span id=\"info3\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"expenditure\">每年持有支出</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"expenditure\" id=\"expenditure\"\n                        aria-describedby=\"expenditureHelp\" placeholder=\"输入预计卖房时间\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"expenditureHelp\" class=\"form-text text-muted\">每年持有房屋的花费，单位：元，包括物业费、暖气费、交通费等</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"income\">每年营租收入</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"income\" id=\"income\" aria-describedby=\"incomeHelp\"\n                        placeholder=\"输入每年营租收入\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"incomeHelp\" class=\"form-text text-muted\">每年营租收入，单位：元，包括租房、Airbnb 等</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【核算支出/收入金额】<br />\n                <span id=\"info4\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"3rate\">银行定期利率（大于等于 3 年）</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"3rate\" id=\"3rate\" aria-describedby=\"3rateHelp\"\n                        placeholder=\"输入定期利率\" value=\"4\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"3rateHelp\" class=\"form-text text-muted\">银行定期利率，超过 3 年的，利率都差不多，粗算一下。</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"1rate\">银行定期利率（小于 3 年）</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"1rate\" id=\"1rate\" aria-describedby=\"1rateHelp\"\n                        placeholder=\"输入定期利率\" value=\"2\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"1rateHelp\" class=\"form-text text-muted\">银行定期利率，不到 3 年的，利率都差不多，粗算一下。</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【利息收入】<br />\n                <span id=\"info5\"></span>\n            </div>\n            <hr />\n            <div class=\"form-group\">\n                <label for=\"swell\">通货膨胀率</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"swell\" id=\"swell\" aria-describedby=\"swellHelp\"\n                        placeholder=\"输入通货膨胀率\" value=\"7\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"swellHelp\" class=\"form-text text-muted\">通货膨胀率，决定于政府调控，一般通货膨胀率是 7%，各国基本一致。</small>\n            </div>\n            <!-- <p class=\"text-center\">\n                <button type=\"submit\" class=\"btn btn-primary\">分析计算</button>\n            </p> -->\n            <div class=\"alert alert-success\" role=\"alert\">\n                【通膨抵消】<br />\n                <span id=\"info6\"></span>\n            </div>\n            <hr />\n            <div class=\"alert alert-primary\" role=\"alert\">\n                【信息汇总】<br />\n                <span id=\"info7\"></span>\n            </div>\n            <div class=\"alert alert-danger\" role=\"alert\">\n                【卖时成本】<br />\n                <span id=\"info8\"></span>\n            </div>\n            <div class=\"alert alert-warning\" role=\"alert\">\n                【收益计算】<br />\n                <span id=\"info9\"></span>\n            </div>\n            <hr />\n        </form>\n    </div>\n\n    <script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/jquery-url-parser/2.3.1/purl.min.js\"></script>\n    <script>\n        /*!\n         * Form Cache v0.0.3\n         * https://github.com/fengyuanchen/formcache\n         *\n         * Copyright 2014 Fengyuan Chen\n         * Released under the MIT license\n         *\n         * Date: 2014-12-17T12:42:29.194Z\n         */\n        ! function (a) {\n            \"function\" == typeof define && define.amd ? define(\"formcache\", [\"jquery\"], a) : a(jQuery)\n        }(function (a) {\n            \"use strict\";\n            var b = a(window),\n                c = window.sessionStorage,\n                d = window.localStorage,\n                e = \"undefined\",\n                f = \".formcache\",\n                g = /[\\.\\*\\+\\^\\$\\:\\!\\[\\]#>~]+/g,\n                h = \"change\" + f,\n                i = \"beforeunload\" + f,\n                j = function (a) {\n                    return \"checkbox\" === a.type || \"radio\" === a.type\n                },\n                k = function (a) {\n                    return parseInt(a, 10)\n                },\n                l = function (b, c) {\n                    this.form = b, this.$form = a(b), this.defaults = a.extend({}, l.DEFAULTS, a.isPlainObject(c) ?\n                        c : {}), this.init()\n                };\n            l.prototype = {\n                    constructor: l,\n                    init: function () {\n                        var b = this.defaults;\n                        b.maxAge = Math.abs(b.maxAge || b.maxage), b.autoStore = Boolean(b.autoStore || b\n                                .autostore), this.initKey(), this.initStorage(), this.caches = this.storage\n                            .caches, this.index = 0, this.activeIndex = 0, this.storing = null, a.isArray(b\n                                .controls) || (b.controls = []), this.$controls = this.$form.find(b.controls\n                                .join()).not(\":file\"), this.addListeners(), this.outputCache()\n                    },\n                    initKey: function () {\n                        var b = this.$form,\n                            c = this.defaults.key || b.data(\"key\");\n                        c || (a(\"form\").each(function (b) {\n                            a(this).data(\"key\", b)\n                        }), c = b.data(\"key\")), this.key = location.pathname + \"#formcache-\" + c\n                    },\n                    initStorage: function () {\n                        var b, e = this.defaults,\n                            f = this.key,\n                            g = new Date,\n                            h = {\n                                date: g,\n                                maxAge: e.maxAge,\n                                caches: []\n                            };\n                        c && (b = c.getItem(f)), !b && d && (b = d.getItem(f)), b = \"string\" == typeof b ? JSON\n                            .parse(b) : null, a.isPlainObject(b) ? \"number\" == typeof b.maxAge && (g - new Date(\n                                b.date)) / 1e3 > b.maxAge && (b = h) : b = h, this.storage = b\n                    },\n                    addListeners: function () {\n                        this.defaults.autoStore && (this.$controls.on(h, a.proxy(this.change, this)), b.on(i, a\n                            .proxy(this.beforeunload, this)))\n                    },\n                    removeListeners: function () {\n                        this.defaults.autoStore && (this.$controls.off(h, this.change), b.off(i, this\n                            .beforeunload))\n                    },\n                    change: function (b) {\n                        var c, d, e = b.target,\n                            f = a(e),\n                            h = f.attr(\"name\"),\n                            i = [];\n                        h && (c = h.replace(g, \"\"), this.$controls.filter('[name*=\"' + c + '\"]').each(\n                            function () {\n                                j(e) ? i.push(this.checked) : (d = a(this).val(), d && i.push(d))\n                            }), i.length && (this.update(h, i), clearTimeout(this.storing), this\n                            .storing =\n                            setTimeout(a.proxy(this.store, this), 1e3)))\n                    },\n                    beforeunload: function () {\n                        this.update(), this.store()\n                    },\n                    update: function (a, b) {\n                        var c = this.activeIndex || this.index,\n                            d = this.getCache(c);\n                        \"string\" == typeof a ? d[a] = b : d = this.serialize(), this.setCache(c, d)\n                    },\n                    serialize: function () {\n                        var b = {};\n                        return this.$controls.each(function () {\n                            var c, d, e = a(this),\n                                f = e.attr(\"name\");\n                            f && (c = b[f], c = a.isArray(c) ? c : [], j(this) ? c.push(this.checked) :\n                                (d = e.val(), d && c.push(d)), c.length && (b[f] = c))\n                        }), b\n                    },\n                    getCache: function (a) {\n                        return this.caches[k(a) || this.index] || {}\n                    },\n                    getCaches: function () {\n                        return this.caches\n                    },\n                    setCache: function (b, c) {\n                        typeof c === e && (c = b, b = 0 / 0), a.isPlainObject(c) && (b = k(b) || this.index,\n                            this.caches[b] = c, this.store())\n                    },\n                    setCaches: function (b) {\n                        a.isArray(b) && (this.caches = b, this.store())\n                    },\n                    removeCache: function (a) {\n                        this.caches.splice(k(a) || this.index, 1), this.store()\n                    },\n                    removeCaches: function () {\n                        this.caches = [], this.store()\n                    },\n                    outputCache: function (b) {\n                        var c = this.getCache(b);\n                        a.isPlainObject(c) && (this.activeIndex = k(b) || this.index, c = a.extend(!0, {}, c),\n                            this.$controls.each(function () {\n                                var b, d, e = a(this),\n                                    f = e.attr(\"name\");\n                                f && (b = c[f], a.isArray(b) && b.length && (d = b.shift(), j(this) ?\n                                    this.checked = d : e.val(d)))\n                            }))\n                    },\n                    store: function () {\n                        var a = this.storage,\n                            b = this.key,\n                            e = this.defaults;\n                        a.date = new Date, a.maxAge = e.maxAge, a = JSON.stringify(a), e.session && c && c\n                            .setItem(b, a), e.local && d && d.setItem(b, a)\n                    },\n                    clear: function () {\n                        var a = this.key,\n                            b = this.defaults;\n                        b.session && c && c.removeItem(a), b.local && d && d.removeItem(a)\n                    },\n                    destroy: function () {\n                        this.removeListeners(), this.$form.removeData(\"formcache\")\n                    }\n                }, l.DEFAULTS = {\n                    key: \"\",\n                    local: !0,\n                    session: !0,\n                    autoStore: !0,\n                    maxAge: void 0,\n                    controls: [\"select\", \"textarea\", \"input\"]\n                }, l.setDefaults = function (b) {\n                    a.extend(l.DEFAULTS, b)\n                }, l.other = a.fn.formcache, a.fn.formcache = function (b) {\n                    var c, d = [].slice.call(arguments, 1);\n                    return this.each(function () {\n                        var e, f = a(this),\n                            g = f.data(\"formcache\");\n                        g || f.data(\"formcache\", g = new l(this, b)), \"string\" == typeof b && a.isFunction(\n                            e = g[b]) && (c = e.apply(g, d))\n                    }), typeof c !== e ? c : this\n                }, a.fn.formcache.Constructor = l, a.fn.formcache.setDefaults = l.setDefaults, a.fn.formcache\n                .noConflict = function () {\n                    return a.fn.formcache = l.other, this\n                }, a(function () {\n                    a('form[data-toggle=\"formcache\"]').formcache()\n                })\n        });\n    </script>\n    <script>\n        (() => {\n            const cache = {};\n            // 计算\n            const getLoan = () => {\n                const values = getValues();\n                const loan = values.area * values.price - values.pay;\n                return loan;\n            };\n\n            const getSupply = () => {\n                const values = getValues();\n                const monthRate = values.rate * values.float / 12 / 100;\n                const loan = getLoan();\n                const supply = loan * monthRate * Math.pow(1 + monthRate, values.year * 12) / (Math.pow(1 + monthRate,\n                    values.year * 12) - 1);\n                return supply;\n            };\n\n            const getTotalRepay = () => {\n                const values = getValues();\n                const monthRate = values.rate * values.float / 12 / 100;\n                const loan = getLoan();\n                const supply = getSupply();\n\n                let total = 0;\n                for (let i = 1; i <= values.sell * 12; i++) {\n                    total += supply - (loan * monthRate * (Math.pow(1 + monthRate, values.year * 12) - Math.pow(1 +\n                        monthRate, i - 1))) / (Math.pow(1 + monthRate, values.year * 12) - 1);\n                }\n\n                return total;\n            };\n\n            const getBankIncome = () => {\n                const values = getValues();\n                const rate3 = values['3rate'] / 100;\n                const rate1 = values['1rate'] / 100;\n                const payment = values.pay + values.other;\n                const supply = getSupply();\n                let total = payment * values.sell * rate3;\n                for (let i = values.sell - 1; i >= 3; i --) {\n                    total += supply * 12 * values.sell * rate3;\n                }\n                total += supply * 12 * 3 * rate1;\n                return total;\n            };\n\n            const getSwell = () => {\n                const values = getValues();\n                const supply = getSupply();\n                const swellRate = values.swell / 100;\n                let base = values.pay + values.other;\n                let total = base * Math.pow(1 +　swellRate, 8);\n                for (let i = values.sell - 1; i >= 1; i --) {\n                    base += supply * 12;\n                    total += supply * 12 * Math.pow(1 +　swellRate, i);\n                }\n                return total - base;\n            };\n\n            // 关联\n            const changePay = () => {\n                const values = getValues();\n                $(`#pay`).val((values.area * values.price) * 0.3);\n            };\n\n            const changeOther = () => {\n                const values = getValues();\n                $(`#other`).val((values.area * values.price) * 0.02);\n            };\n\n            const changeSell = () => {\n                const values = getValues();\n                $(`#sell`).val(parseInt(values.get) + 5);\n            };\n\n            // 分析\n            const changeInfo1 = () => {\n                const values = getValues();\n                $('#info1').html(\n                    `总价 ${(values.area * values.price / 10000).toFixed(2)} 万元，首付 ${((values.pay + values.other) / 10000).toFixed(2)} 万元，贷款 ${((values.area * values.price - values.pay) / 10000).toFixed(2)} 万元。`\n                );\n                cache.total = (values.area * values.price / 10000).toFixed(2);\n                cache.payment = ((values.pay + values.other) / 10000).toFixed(2);\n                cache.liabilities = ((values.area * values.price - values.pay) / 10000).toFixed(2);\n                changeInfo3();\n                changeInfo7();\n            };\n\n            const changeInfo2 = () => {\n                const values = getValues();\n                const loan = getLoan();\n                const supply = getSupply();\n                $('#info2').html(\n                    `· 年利率 ${(values.rate * values.float).toFixed(2)}%，年限 ${values.year} 年（ ${values.year * 12} 个月）。<br/>` + \n                    `· 等额本息月供 ${supply.toFixed(2)} 元，利息总和为 ${((supply * values.year * 12 - loan) / 10000).toFixed(2)} 万元。`\n                    );\n                cache.supply = supply.toFixed(2);\n                changeInfo3();\n                changeInfo7();\n            };\n\n            const changeInfo3 = () => {\n                const values = getValues();\n                const loan = getLoan();\n                const supply = getSupply();\n                const totalRepay = getTotalRepay();\n                const total = values.pay + values.other + values.sell * 12 * supply + loan - totalRepay;\n                $('#info3').html(\n                    `· 已经还款 ${values.sell * 12} 个月， 共还款 ${(values.sell * 12 * supply / 10000).toFixed(2)} 万元, 供还本金 ${(totalRepay / 10000).toFixed(2)} 万元，剩余本金 ${((loan - totalRepay) / 10000).toFixed(2)} 万元。<br/>` +\n                    `· 总成本为：${values.pay + values.other}(首付) + ${(values.sell * 12 * supply).toFixed(2)}(还款) + ${(loan - totalRepay).toFixed(2)}(剩余本金) = ${(total).toFixed(2)} 元 = ${(total / 10000).toFixed(2)} 万元。<br/>` +\n                    `· 对应每平单价为： ${(total / values.area).toFixed(0)} 元。`\n                );\n                cache.cost = total;\n                changeInfo4();\n                changeInfo5();\n                changeInfo6();\n            };\n\n            const changeInfo4 = () => {\n                const values = getValues();\n                $('#info4').html(\n                    `共营收 ${(values.income - values.expenditure) * (values.sell - values.get)} 元，对应每平减少成本 ${(((values.income - values.expenditure) * (values.sell - values.get)) / values.area).toFixed(0)} 元。`\n                    );\n                cache.totalIncome = (values.income - values.expenditure) * (values.sell - values.get);\n                changeInfo8();\n            };\n\n            const changeInfo5 = () => {\n                const values = getValues();\n                const bankIncome = getBankIncome();\n                $('#info5').html(\n                    `首付存定期，月供每年一次存定期，直接存到卖房时，获得的利息为 ${(bankIncome / 10000).toFixed(2)} 万元，对应每平增加成本 ${(bankIncome / values.area).toFixed(0)} 元。`\n                    );\n                changeInfo9();\n            };\n\n            const changeInfo6 = () => {\n                const values = getValues();\n                const swell = getSwell();\n                $('#info6').html(\n                    `抵消通货膨胀，需要增加收入 ${(swell / 10000).toFixed(2)} 万元，平均每平米需再增长 ${(swell / values.area).toFixed(0)} 元。`\n                    );\n                changeInfo9();\n            };\n\n            const changeInfo7 = () => {\n                const values = getValues();\n                $('#info7').html([\n                    `<ul>`, \n                        `<li>总价：${cache.total} 万元</li>`,\n                        `<li>单价：${values.price} 元</li>`,\n                        `<li>首付：${cache.payment} 万元</li>`,\n                        `<li>贷款：${cache.liabilities} 万元</li>`,\n                        `<li>月供：${cache.supply} 元</li>`,\n                    `</ul>`\n                ].join(''));\n            };\n\n            const changeInfo8 = () => {\n                const values = getValues();\n                $('#info8').html([\n                    `<ul>`, \n                        `<li>成本：${((cache.cost - cache.totalIncome) / 10000).toFixed(2)} 万元</li>`,\n                        `<li>单价：${((cache.cost - cache.totalIncome) / values.area).toFixed(0)} 元</li>`,\n                    `</ul>`\n                ].join(''));\n\n            };\n\n            const changeInfo9 = () => {\n                const values = getValues();\n                $('#info9').html([\n                    `<ul>`, \n                        `<li>总价达到 ${((cache.cost - cache.totalIncome + getBankIncome()) / 10000).toFixed(2)} 万元，能与银行定期收益持平，对应单价为 ${((cache.cost - cache.totalIncome + getBankIncome()) / values.area).toFixed(0)} 元。</li>`,\n                        `<li>总价达到 ${((cache.cost - cache.totalIncome + getSwell()) / 10000).toFixed(2)} 万元，能抵消通货膨胀，对应单价为 ${((cache.cost - cache.totalIncome + getSwell()) / values.area).toFixed(0)} 元。</li>`,\n                    `</ul>`\n                ].join(''));\n            };\n\n            const inputOpts = {\n                price: {\n                    default: 10000,\n                    change: [changePay, changeOther, changeInfo1]\n                },\n                area: {\n                    default: 90,\n                    change: [changePay, changeOther, changeInfo1]\n                },\n                pay: {\n                    default: 270000,\n                    change: [changeInfo1]\n                },\n                other: {\n                    default: 18000,\n                    change: [changeInfo1]\n                },\n                rate: {\n                    default: 4.9,\n                    change: [changeInfo2]\n                },\n                float: {\n                    default: '1.00',\n                    change: [changeInfo2]\n                },\n                year: {\n                    default: 25,\n                    change: [changeInfo2]\n                },\n                get: {\n                    default: 0,\n                    change: [changeSell, changeInfo3]\n                },\n                sell: {\n                    default: 5,\n                    change: [changeInfo3]\n                },\n                expenditure: {\n                    default: 0,\n                    change: [changeInfo4]\n                },\n                income: {\n                    default: 0,\n                    change: [changeInfo4]\n                },\n                '3rate': {\n                    default: 4,\n                    change: [changeInfo5]\n                },\n                '1rate': {\n                    default: 2,\n                    change: [changeInfo5]\n                },\n                swell: {\n                    default: 7,\n                    change: [changeInfo6]\n                }\n            };\n\n            const getValues = () => {\n                const res = {};\n                Object.keys(inputOpts).forEach((key) => {\n                    res[key] = parseFloat($(`#${key}`).val());\n                });\n                return res;\n            };\n\n\n            const handleChange = (e) => {\n                const id = e.target.id;\n                const opt = inputOpts[id];\n                if (opt.change) {\n                    [].concat(opt.change).forEach(t => t());\n                }\n                var cache = $('form').formcache('serialize');\n                $('form').formcache('setCache', cache);\n                history.replaceState(null, document.title, \"/eicalc.html?data=\" + encodeURIComponent(JSON.stringify(cache)));\n            };\n\n            $(() => {\n                $('form').delegate('input', 'focus', (e) => {\n                    const value = e.target.value;\n                    e.target.value = '';\n                    const onblur = () => {\n                        if (isNaN(parseFloat(e.target.value))) {\n                            e.target.value = value;\n                            handleChange(e);\n                        }\n                        e.target.removeEventListener('blur', onblur);\n                    };\n                    e.target.addEventListener('blur', onblur, false);\n                });\n\n                $('form').delegate('input,select', 'change', handleChange);\n                const data = $.url().param('data');\n                if (data) {\n                    try {\n                        const cache = JSON.parse(decodeURIComponent(data));\n                        $('form').formcache('setCache', cache);\n                    } catch(e) {}\n                }\n                $('form').formcache('outputCache');\n                changeInfo1();\n                changeInfo2();\n            });\n        })();\n    </script>\n</body>\n\n</html>","date":"2019-05-24T10:18:22.645Z","updated":"2019-05-24T10:18:22.645Z","path":"eicalc.html","_id":"cjw1ve1fe0000pyp4ykgglics","title":"","comments":1,"content":"<!DOCTYPE html>\n<html>\n\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n    <link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css\">\n\n    <title>Estate Investment Calculator</title>\n</head>\n\n<body>\n    <nav class=\"navbar navbar-light bg-light\">\n        <span class=\"navbar-brand mb-0 h1\" style=\"margin: 0 auto\">房产投资计算器</span>\n    </nav>\n    <div class=\"container\">\n        <form data-toggle=\"formcache\">\n            <div class=\"form-group\">\n                <label for=\"price\">单价</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"price\" id=\"price\" aria-describedby=\"priceHelp\" placeholder=\"输入房产单价\" value=\"10000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"priceHelp\" class=\"form-text text-muted\">房产单价</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"area\">面积</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"area\" id=\"area\" aria-describedby=\"areaHelp\" placeholder=\"输入房产面积\" value=\"90\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">平</span>\n                    </div>\n                </div>\n                <small id=\"areaHelp\" class=\"form-text text-muted\">房产面积</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"pay\">首付</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"pay\" id=\"pay\" aria-describedby=\"payHelp\" placeholder=\"输入首付金额\" value=\"270000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"payHelp\" class=\"form-text text-muted\">首付，默认房产总价 30%</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"other\">手续费、契税等支出</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"other\" id=\"other\" aria-describedby=\"otherHelp\" placeholder=\"输入手续费、契税等支出金额\" value=\"18000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"otherHelp\" class=\"form-text text-muted\">手续费，默认房产总价 2%（1% 契税，1% 公共维修基金）</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【房产信息】<br>\n                <span id=\"info1\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"rate\">房贷利率</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"rate\" id=\"rate\" aria-describedby=\"rateHelp\" placeholder=\"输入手续费、契税等支出金额\" value=\"4.9\" step=\"0.01\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"rateHelp\" class=\"form-text text-muted\">房贷，默认：4.9，商贷基准利率</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"float\">利率浮动</label>\n                <select class=\"form-control\" name=\"float\" id=\"float\" aria-describedby=\"floatHelp\">\n                    <option value=\"0.80\">八折优惠( -20% )</option>\n                    <option value=\"0.85\">八五折优惠( -15% )</option>\n                    <option value=\"0.90\">九折优惠( -10% )</option>\n                    <option value=\"0.95\">九五折优惠( -5% )</option>\n                    <option value=\"1.00\" selected>正常利率( +0% )</option>\n                    <option value=\"1.05\">上浮5个点( +5% )</option>\n                    <option value=\"1.10\">上浮10个点( +10% )</option>\n                    <option value=\"1.15\">上浮15个点( +15% )</option>\n                    <option value=\"1.20\">上浮20个点( +20% )</option>\n                </select>\n                <small id=\"floatHelp\" class=\"form-text text-muted\">利率浮动，默认不上浮也不打折</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"year\">贷款年限</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"year\" id=\"year\" aria-describedby=\"yearHelp\" placeholder=\"输入贷款年限\" value=\"25\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"yearHelp\" class=\"form-text text-muted\">贷款年限，单位：年，默认25，当前最长年数</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【贷款信息】<br>\n                <span id=\"info2\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"get\">交房时间</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"get\" id=\"get\" aria-describedby=\"getHelp\" placeholder=\"输入交房时间\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"getHelp\" class=\"form-text text-muted\">几年后交房，单位：年，除期房，都是 0</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"sell\">预计卖房时间</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"sell\" id=\"sell\" aria-describedby=\"sellHelp\" placeholder=\"输入预计卖房时间\" value=\"5\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"sellHelp\" class=\"form-text text-muted\">几年后卖房，单位：年，默认交房时间 + 5（满五）</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【卖房时成本信息】<br>\n                <span id=\"info3\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"expenditure\">每年持有支出</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"expenditure\" id=\"expenditure\" aria-describedby=\"expenditureHelp\" placeholder=\"输入预计卖房时间\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"expenditureHelp\" class=\"form-text text-muted\">每年持有房屋的花费，单位：元，包括物业费、暖气费、交通费等</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"income\">每年营租收入</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"income\" id=\"income\" aria-describedby=\"incomeHelp\" placeholder=\"输入每年营租收入\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"incomeHelp\" class=\"form-text text-muted\">每年营租收入，单位：元，包括租房、Airbnb 等</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【核算支出/收入金额】<br>\n                <span id=\"info4\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"3rate\">银行定期利率（大于等于 3 年）</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"3rate\" id=\"3rate\" aria-describedby=\"3rateHelp\" placeholder=\"输入定期利率\" value=\"4\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"3rateHelp\" class=\"form-text text-muted\">银行定期利率，超过 3 年的，利率都差不多，粗算一下。</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"1rate\">银行定期利率（小于 3 年）</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"1rate\" id=\"1rate\" aria-describedby=\"1rateHelp\" placeholder=\"输入定期利率\" value=\"2\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"1rateHelp\" class=\"form-text text-muted\">银行定期利率，不到 3 年的，利率都差不多，粗算一下。</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【利息收入】<br>\n                <span id=\"info5\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"swell\">通货膨胀率</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"swell\" id=\"swell\" aria-describedby=\"swellHelp\" placeholder=\"输入通货膨胀率\" value=\"7\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"swellHelp\" class=\"form-text text-muted\">通货膨胀率，决定于政府调控，一般通货膨胀率是 7%，各国基本一致。</small>\n            </div>\n            <!-- <p class=\"text-center\">\n                <button type=\"submit\" class=\"btn btn-primary\">分析计算</button>\n            </p> -->\n            <div class=\"alert alert-success\" role=\"alert\">\n                【通膨抵消】<br>\n                <span id=\"info6\"></span>\n            </div>\n            <hr>\n            <div class=\"alert alert-primary\" role=\"alert\">\n                【信息汇总】<br>\n                <span id=\"info7\"></span>\n            </div>\n            <div class=\"alert alert-danger\" role=\"alert\">\n                【卖时成本】<br>\n                <span id=\"info8\"></span>\n            </div>\n            <div class=\"alert alert-warning\" role=\"alert\">\n                【收益计算】<br>\n                <span id=\"info9\"></span>\n            </div>\n            <hr>\n        </form>\n    </div>\n\n    <script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/jquery-url-parser/2.3.1/purl.min.js\"></script>\n    <script>\n        /*!\n         * Form Cache v0.0.3\n         * https://github.com/fengyuanchen/formcache\n         *\n         * Copyright 2014 Fengyuan Chen\n         * Released under the MIT license\n         *\n         * Date: 2014-12-17T12:42:29.194Z\n         */\n        ! function (a) {\n            \"function\" == typeof define && define.amd ? define(\"formcache\", [\"jquery\"], a) : a(jQuery)\n        }(function (a) {\n            \"use strict\";\n            var b = a(window),\n                c = window.sessionStorage,\n                d = window.localStorage,\n                e = \"undefined\",\n                f = \".formcache\",\n                g = /[\\.\\*\\+\\^\\$\\:\\!\\[\\]#>~]+/g,\n                h = \"change\" + f,\n                i = \"beforeunload\" + f,\n                j = function (a) {\n                    return \"checkbox\" === a.type || \"radio\" === a.type\n                },\n                k = function (a) {\n                    return parseInt(a, 10)\n                },\n                l = function (b, c) {\n                    this.form = b, this.$form = a(b), this.defaults = a.extend({}, l.DEFAULTS, a.isPlainObject(c) ?\n                        c : {}), this.init()\n                };\n            l.prototype = {\n                    constructor: l,\n                    init: function () {\n                        var b = this.defaults;\n                        b.maxAge = Math.abs(b.maxAge || b.maxage), b.autoStore = Boolean(b.autoStore || b\n                                .autostore), this.initKey(), this.initStorage(), this.caches = this.storage\n                            .caches, this.index = 0, this.activeIndex = 0, this.storing = null, a.isArray(b\n                                .controls) || (b.controls = []), this.$controls = this.$form.find(b.controls\n                                .join()).not(\":file\"), this.addListeners(), this.outputCache()\n                    },\n                    initKey: function () {\n                        var b = this.$form,\n                            c = this.defaults.key || b.data(\"key\");\n                        c || (a(\"form\").each(function (b) {\n                            a(this).data(\"key\", b)\n                        }), c = b.data(\"key\")), this.key = location.pathname + \"#formcache-\" + c\n                    },\n                    initStorage: function () {\n                        var b, e = this.defaults,\n                            f = this.key,\n                            g = new Date,\n                            h = {\n                                date: g,\n                                maxAge: e.maxAge,\n                                caches: []\n                            };\n                        c && (b = c.getItem(f)), !b && d && (b = d.getItem(f)), b = \"string\" == typeof b ? JSON\n                            .parse(b) : null, a.isPlainObject(b) ? \"number\" == typeof b.maxAge && (g - new Date(\n                                b.date)) / 1e3 > b.maxAge && (b = h) : b = h, this.storage = b\n                    },\n                    addListeners: function () {\n                        this.defaults.autoStore && (this.$controls.on(h, a.proxy(this.change, this)), b.on(i, a\n                            .proxy(this.beforeunload, this)))\n                    },\n                    removeListeners: function () {\n                        this.defaults.autoStore && (this.$controls.off(h, this.change), b.off(i, this\n                            .beforeunload))\n                    },\n                    change: function (b) {\n                        var c, d, e = b.target,\n                            f = a(e),\n                            h = f.attr(\"name\"),\n                            i = [];\n                        h && (c = h.replace(g, \"\"), this.$controls.filter('[name*=\"' + c + '\"]').each(\n                            function () {\n                                j(e) ? i.push(this.checked) : (d = a(this).val(), d && i.push(d))\n                            }), i.length && (this.update(h, i), clearTimeout(this.storing), this\n                            .storing =\n                            setTimeout(a.proxy(this.store, this), 1e3)))\n                    },\n                    beforeunload: function () {\n                        this.update(), this.store()\n                    },\n                    update: function (a, b) {\n                        var c = this.activeIndex || this.index,\n                            d = this.getCache(c);\n                        \"string\" == typeof a ? d[a] = b : d = this.serialize(), this.setCache(c, d)\n                    },\n                    serialize: function () {\n                        var b = {};\n                        return this.$controls.each(function () {\n                            var c, d, e = a(this),\n                                f = e.attr(\"name\");\n                            f && (c = b[f], c = a.isArray(c) ? c : [], j(this) ? c.push(this.checked) :\n                                (d = e.val(), d && c.push(d)), c.length && (b[f] = c))\n                        }), b\n                    },\n                    getCache: function (a) {\n                        return this.caches[k(a) || this.index] || {}\n                    },\n                    getCaches: function () {\n                        return this.caches\n                    },\n                    setCache: function (b, c) {\n                        typeof c === e && (c = b, b = 0 / 0), a.isPlainObject(c) && (b = k(b) || this.index,\n                            this.caches[b] = c, this.store())\n                    },\n                    setCaches: function (b) {\n                        a.isArray(b) && (this.caches = b, this.store())\n                    },\n                    removeCache: function (a) {\n                        this.caches.splice(k(a) || this.index, 1), this.store()\n                    },\n                    removeCaches: function () {\n                        this.caches = [], this.store()\n                    },\n                    outputCache: function (b) {\n                        var c = this.getCache(b);\n                        a.isPlainObject(c) && (this.activeIndex = k(b) || this.index, c = a.extend(!0, {}, c),\n                            this.$controls.each(function () {\n                                var b, d, e = a(this),\n                                    f = e.attr(\"name\");\n                                f && (b = c[f], a.isArray(b) && b.length && (d = b.shift(), j(this) ?\n                                    this.checked = d : e.val(d)))\n                            }))\n                    },\n                    store: function () {\n                        var a = this.storage,\n                            b = this.key,\n                            e = this.defaults;\n                        a.date = new Date, a.maxAge = e.maxAge, a = JSON.stringify(a), e.session && c && c\n                            .setItem(b, a), e.local && d && d.setItem(b, a)\n                    },\n                    clear: function () {\n                        var a = this.key,\n                            b = this.defaults;\n                        b.session && c && c.removeItem(a), b.local && d && d.removeItem(a)\n                    },\n                    destroy: function () {\n                        this.removeListeners(), this.$form.removeData(\"formcache\")\n                    }\n                }, l.DEFAULTS = {\n                    key: \"\",\n                    local: !0,\n                    session: !0,\n                    autoStore: !0,\n                    maxAge: void 0,\n                    controls: [\"select\", \"textarea\", \"input\"]\n                }, l.setDefaults = function (b) {\n                    a.extend(l.DEFAULTS, b)\n                }, l.other = a.fn.formcache, a.fn.formcache = function (b) {\n                    var c, d = [].slice.call(arguments, 1);\n                    return this.each(function () {\n                        var e, f = a(this),\n                            g = f.data(\"formcache\");\n                        g || f.data(\"formcache\", g = new l(this, b)), \"string\" == typeof b && a.isFunction(\n                            e = g[b]) && (c = e.apply(g, d))\n                    }), typeof c !== e ? c : this\n                }, a.fn.formcache.Constructor = l, a.fn.formcache.setDefaults = l.setDefaults, a.fn.formcache\n                .noConflict = function () {\n                    return a.fn.formcache = l.other, this\n                }, a(function () {\n                    a('form[data-toggle=\"formcache\"]').formcache()\n                })\n        });\n    </script>\n    <script>\n        (() => {\n            const cache = {};\n            // 计算\n            const getLoan = () => {\n                const values = getValues();\n                const loan = values.area * values.price - values.pay;\n                return loan;\n            };\n\n            const getSupply = () => {\n                const values = getValues();\n                const monthRate = values.rate * values.float / 12 / 100;\n                const loan = getLoan();\n                const supply = loan * monthRate * Math.pow(1 + monthRate, values.year * 12) / (Math.pow(1 + monthRate,\n                    values.year * 12) - 1);\n                return supply;\n            };\n\n            const getTotalRepay = () => {\n                const values = getValues();\n                const monthRate = values.rate * values.float / 12 / 100;\n                const loan = getLoan();\n                const supply = getSupply();\n\n                let total = 0;\n                for (let i = 1; i <= values.sell * 12; i++) {\n                    total += supply - (loan * monthRate * (Math.pow(1 + monthRate, values.year * 12) - Math.pow(1 +\n                        monthRate, i - 1))) / (Math.pow(1 + monthRate, values.year * 12) - 1);\n                }\n\n                return total;\n            };\n\n            const getBankIncome = () => {\n                const values = getValues();\n                const rate3 = values['3rate'] / 100;\n                const rate1 = values['1rate'] / 100;\n                const payment = values.pay + values.other;\n                const supply = getSupply();\n                let total = payment * values.sell * rate3;\n                for (let i = values.sell - 1; i >= 3; i --) {\n                    total += supply * 12 * values.sell * rate3;\n                }\n                total += supply * 12 * 3 * rate1;\n                return total;\n            };\n\n            const getSwell = () => {\n                const values = getValues();\n                const supply = getSupply();\n                const swellRate = values.swell / 100;\n                let base = values.pay + values.other;\n                let total = base * Math.pow(1 +　swellRate, 8);\n                for (let i = values.sell - 1; i >= 1; i --) {\n                    base += supply * 12;\n                    total += supply * 12 * Math.pow(1 +　swellRate, i);\n                }\n                return total - base;\n            };\n\n            // 关联\n            const changePay = () => {\n                const values = getValues();\n                $(`#pay`).val((values.area * values.price) * 0.3);\n            };\n\n            const changeOther = () => {\n                const values = getValues();\n                $(`#other`).val((values.area * values.price) * 0.02);\n            };\n\n            const changeSell = () => {\n                const values = getValues();\n                $(`#sell`).val(parseInt(values.get) + 5);\n            };\n\n            // 分析\n            const changeInfo1 = () => {\n                const values = getValues();\n                $('#info1').html(\n                    `总价 ${(values.area * values.price / 10000).toFixed(2)} 万元，首付 ${((values.pay + values.other) / 10000).toFixed(2)} 万元，贷款 ${((values.area * values.price - values.pay) / 10000).toFixed(2)} 万元。`\n                );\n                cache.total = (values.area * values.price / 10000).toFixed(2);\n                cache.payment = ((values.pay + values.other) / 10000).toFixed(2);\n                cache.liabilities = ((values.area * values.price - values.pay) / 10000).toFixed(2);\n                changeInfo3();\n                changeInfo7();\n            };\n\n            const changeInfo2 = () => {\n                const values = getValues();\n                const loan = getLoan();\n                const supply = getSupply();\n                $('#info2').html(\n                    `· 年利率 ${(values.rate * values.float).toFixed(2)}%，年限 ${values.year} 年（ ${values.year * 12} 个月）。<br/>` + \n                    `· 等额本息月供 ${supply.toFixed(2)} 元，利息总和为 ${((supply * values.year * 12 - loan) / 10000).toFixed(2)} 万元。`\n                    );\n                cache.supply = supply.toFixed(2);\n                changeInfo3();\n                changeInfo7();\n            };\n\n            const changeInfo3 = () => {\n                const values = getValues();\n                const loan = getLoan();\n                const supply = getSupply();\n                const totalRepay = getTotalRepay();\n                const total = values.pay + values.other + values.sell * 12 * supply + loan - totalRepay;\n                $('#info3').html(\n                    `· 已经还款 ${values.sell * 12} 个月， 共还款 ${(values.sell * 12 * supply / 10000).toFixed(2)} 万元, 供还本金 ${(totalRepay / 10000).toFixed(2)} 万元，剩余本金 ${((loan - totalRepay) / 10000).toFixed(2)} 万元。<br/>` +\n                    `· 总成本为：${values.pay + values.other}(首付) + ${(values.sell * 12 * supply).toFixed(2)}(还款) + ${(loan - totalRepay).toFixed(2)}(剩余本金) = ${(total).toFixed(2)} 元 = ${(total / 10000).toFixed(2)} 万元。<br/>` +\n                    `· 对应每平单价为： ${(total / values.area).toFixed(0)} 元。`\n                );\n                cache.cost = total;\n                changeInfo4();\n                changeInfo5();\n                changeInfo6();\n            };\n\n            const changeInfo4 = () => {\n                const values = getValues();\n                $('#info4').html(\n                    `共营收 ${(values.income - values.expenditure) * (values.sell - values.get)} 元，对应每平减少成本 ${(((values.income - values.expenditure) * (values.sell - values.get)) / values.area).toFixed(0)} 元。`\n                    );\n                cache.totalIncome = (values.income - values.expenditure) * (values.sell - values.get);\n                changeInfo8();\n            };\n\n            const changeInfo5 = () => {\n                const values = getValues();\n                const bankIncome = getBankIncome();\n                $('#info5').html(\n                    `首付存定期，月供每年一次存定期，直接存到卖房时，获得的利息为 ${(bankIncome / 10000).toFixed(2)} 万元，对应每平增加成本 ${(bankIncome / values.area).toFixed(0)} 元。`\n                    );\n                changeInfo9();\n            };\n\n            const changeInfo6 = () => {\n                const values = getValues();\n                const swell = getSwell();\n                $('#info6').html(\n                    `抵消通货膨胀，需要增加收入 ${(swell / 10000).toFixed(2)} 万元，平均每平米需再增长 ${(swell / values.area).toFixed(0)} 元。`\n                    );\n                changeInfo9();\n            };\n\n            const changeInfo7 = () => {\n                const values = getValues();\n                $('#info7').html([\n                    `<ul>`, \n                        `<li>总价：${cache.total} 万元</li>`,\n                        `<li>单价：${values.price} 元</li>`,\n                        `<li>首付：${cache.payment} 万元</li>`,\n                        `<li>贷款：${cache.liabilities} 万元</li>`,\n                        `<li>月供：${cache.supply} 元</li>`,\n                    `</ul>`\n                ].join(''));\n            };\n\n            const changeInfo8 = () => {\n                const values = getValues();\n                $('#info8').html([\n                    `<ul>`, \n                        `<li>成本：${((cache.cost - cache.totalIncome) / 10000).toFixed(2)} 万元</li>`,\n                        `<li>单价：${((cache.cost - cache.totalIncome) / values.area).toFixed(0)} 元</li>`,\n                    `</ul>`\n                ].join(''));\n\n            };\n\n            const changeInfo9 = () => {\n                const values = getValues();\n                $('#info9').html([\n                    `<ul>`, \n                        `<li>总价达到 ${((cache.cost - cache.totalIncome + getBankIncome()) / 10000).toFixed(2)} 万元，能与银行定期收益持平，对应单价为 ${((cache.cost - cache.totalIncome + getBankIncome()) / values.area).toFixed(0)} 元。</li>`,\n                        `<li>总价达到 ${((cache.cost - cache.totalIncome + getSwell()) / 10000).toFixed(2)} 万元，能抵消通货膨胀，对应单价为 ${((cache.cost - cache.totalIncome + getSwell()) / values.area).toFixed(0)} 元。</li>`,\n                    `</ul>`\n                ].join(''));\n            };\n\n            const inputOpts = {\n                price: {\n                    default: 10000,\n                    change: [changePay, changeOther, changeInfo1]\n                },\n                area: {\n                    default: 90,\n                    change: [changePay, changeOther, changeInfo1]\n                },\n                pay: {\n                    default: 270000,\n                    change: [changeInfo1]\n                },\n                other: {\n                    default: 18000,\n                    change: [changeInfo1]\n                },\n                rate: {\n                    default: 4.9,\n                    change: [changeInfo2]\n                },\n                float: {\n                    default: '1.00',\n                    change: [changeInfo2]\n                },\n                year: {\n                    default: 25,\n                    change: [changeInfo2]\n                },\n                get: {\n                    default: 0,\n                    change: [changeSell, changeInfo3]\n                },\n                sell: {\n                    default: 5,\n                    change: [changeInfo3]\n                },\n                expenditure: {\n                    default: 0,\n                    change: [changeInfo4]\n                },\n                income: {\n                    default: 0,\n                    change: [changeInfo4]\n                },\n                '3rate': {\n                    default: 4,\n                    change: [changeInfo5]\n                },\n                '1rate': {\n                    default: 2,\n                    change: [changeInfo5]\n                },\n                swell: {\n                    default: 7,\n                    change: [changeInfo6]\n                }\n            };\n\n            const getValues = () => {\n                const res = {};\n                Object.keys(inputOpts).forEach((key) => {\n                    res[key] = parseFloat($(`#${key}`).val());\n                });\n                return res;\n            };\n\n\n            const handleChange = (e) => {\n                const id = e.target.id;\n                const opt = inputOpts[id];\n                if (opt.change) {\n                    [].concat(opt.change).forEach(t => t());\n                }\n                var cache = $('form').formcache('serialize');\n                $('form').formcache('setCache', cache);\n                history.replaceState(null, document.title, \"/eicalc.html?data=\" + encodeURIComponent(JSON.stringify(cache)));\n            };\n\n            $(() => {\n                $('form').delegate('input', 'focus', (e) => {\n                    const value = e.target.value;\n                    e.target.value = '';\n                    const onblur = () => {\n                        if (isNaN(parseFloat(e.target.value))) {\n                            e.target.value = value;\n                            handleChange(e);\n                        }\n                        e.target.removeEventListener('blur', onblur);\n                    };\n                    e.target.addEventListener('blur', onblur, false);\n                });\n\n                $('form').delegate('input,select', 'change', handleChange);\n                const data = $.url().param('data');\n                if (data) {\n                    try {\n                        const cache = JSON.parse(decodeURIComponent(data));\n                        $('form').formcache('setCache', cache);\n                    } catch(e) {}\n                }\n                $('form').formcache('outputCache');\n                changeInfo1();\n                changeInfo2();\n            });\n        })();\n    </script>\n</body>\n\n</html>","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":"<!DOCTYPE html>\n<html>\n\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n    <link rel=\"stylesheet\" href=\"https://cdn.bootcss.com/bootstrap/4.0.0/css/bootstrap.min.css\">\n\n    <title>Estate Investment Calculator</title>\n</head>\n\n<body>\n    <nav class=\"navbar navbar-light bg-light\">\n        <span class=\"navbar-brand mb-0 h1\" style=\"margin: 0 auto\">房产投资计算器</span>\n    </nav>\n    <div class=\"container\">\n        <form data-toggle=\"formcache\">\n            <div class=\"form-group\">\n                <label for=\"price\">单价</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"price\" id=\"price\" aria-describedby=\"priceHelp\" placeholder=\"输入房产单价\" value=\"10000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"priceHelp\" class=\"form-text text-muted\">房产单价</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"area\">面积</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"area\" id=\"area\" aria-describedby=\"areaHelp\" placeholder=\"输入房产面积\" value=\"90\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">平</span>\n                    </div>\n                </div>\n                <small id=\"areaHelp\" class=\"form-text text-muted\">房产面积</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"pay\">首付</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"pay\" id=\"pay\" aria-describedby=\"payHelp\" placeholder=\"输入首付金额\" value=\"270000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"payHelp\" class=\"form-text text-muted\">首付，默认房产总价 30%</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"other\">手续费、契税等支出</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"other\" id=\"other\" aria-describedby=\"otherHelp\" placeholder=\"输入手续费、契税等支出金额\" value=\"18000\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"otherHelp\" class=\"form-text text-muted\">手续费，默认房产总价 2%（1% 契税，1% 公共维修基金）</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【房产信息】<br>\n                <span id=\"info1\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"rate\">房贷利率</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"rate\" id=\"rate\" aria-describedby=\"rateHelp\" placeholder=\"输入手续费、契税等支出金额\" value=\"4.9\" step=\"0.01\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"rateHelp\" class=\"form-text text-muted\">房贷，默认：4.9，商贷基准利率</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"float\">利率浮动</label>\n                <select class=\"form-control\" name=\"float\" id=\"float\" aria-describedby=\"floatHelp\">\n                    <option value=\"0.80\">八折优惠( -20% )</option>\n                    <option value=\"0.85\">八五折优惠( -15% )</option>\n                    <option value=\"0.90\">九折优惠( -10% )</option>\n                    <option value=\"0.95\">九五折优惠( -5% )</option>\n                    <option value=\"1.00\" selected>正常利率( +0% )</option>\n                    <option value=\"1.05\">上浮5个点( +5% )</option>\n                    <option value=\"1.10\">上浮10个点( +10% )</option>\n                    <option value=\"1.15\">上浮15个点( +15% )</option>\n                    <option value=\"1.20\">上浮20个点( +20% )</option>\n                </select>\n                <small id=\"floatHelp\" class=\"form-text text-muted\">利率浮动，默认不上浮也不打折</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"year\">贷款年限</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"year\" id=\"year\" aria-describedby=\"yearHelp\" placeholder=\"输入贷款年限\" value=\"25\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"yearHelp\" class=\"form-text text-muted\">贷款年限，单位：年，默认25，当前最长年数</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【贷款信息】<br>\n                <span id=\"info2\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"get\">交房时间</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"get\" id=\"get\" aria-describedby=\"getHelp\" placeholder=\"输入交房时间\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"getHelp\" class=\"form-text text-muted\">几年后交房，单位：年，除期房，都是 0</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"sell\">预计卖房时间</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"sell\" id=\"sell\" aria-describedby=\"sellHelp\" placeholder=\"输入预计卖房时间\" value=\"5\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">年</span>\n                    </div>\n                </div>\n                <small id=\"sellHelp\" class=\"form-text text-muted\">几年后卖房，单位：年，默认交房时间 + 5（满五）</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【卖房时成本信息】<br>\n                <span id=\"info3\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"expenditure\">每年持有支出</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"expenditure\" id=\"expenditure\" aria-describedby=\"expenditureHelp\" placeholder=\"输入预计卖房时间\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"expenditureHelp\" class=\"form-text text-muted\">每年持有房屋的花费，单位：元，包括物业费、暖气费、交通费等</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"income\">每年营租收入</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"income\" id=\"income\" aria-describedby=\"incomeHelp\" placeholder=\"输入每年营租收入\" value=\"0\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">元</span>\n                    </div>\n                </div>\n                <small id=\"incomeHelp\" class=\"form-text text-muted\">每年营租收入，单位：元，包括租房、Airbnb 等</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【核算支出/收入金额】<br>\n                <span id=\"info4\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"3rate\">银行定期利率（大于等于 3 年）</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"3rate\" id=\"3rate\" aria-describedby=\"3rateHelp\" placeholder=\"输入定期利率\" value=\"4\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"3rateHelp\" class=\"form-text text-muted\">银行定期利率，超过 3 年的，利率都差不多，粗算一下。</small>\n            </div>\n            <div class=\"form-group\">\n                <label for=\"1rate\">银行定期利率（小于 3 年）</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"1rate\" id=\"1rate\" aria-describedby=\"1rateHelp\" placeholder=\"输入定期利率\" value=\"2\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"1rateHelp\" class=\"form-text text-muted\">银行定期利率，不到 3 年的，利率都差不多，粗算一下。</small>\n            </div>\n            <div class=\"alert alert-success\" role=\"alert\">\n                【利息收入】<br>\n                <span id=\"info5\"></span>\n            </div>\n            <hr>\n            <div class=\"form-group\">\n                <label for=\"swell\">通货膨胀率</label>\n                <div class=\"input-group mb-3\">\n                    <input type=\"number\" class=\"form-control\" name=\"swell\" id=\"swell\" aria-describedby=\"swellHelp\" placeholder=\"输入通货膨胀率\" value=\"7\" style=\"text-align: right\">\n                    <div class=\"input-group-append\">\n                        <span class=\"input-group-text\">%</span>\n                    </div>\n                </div>\n                <small id=\"swellHelp\" class=\"form-text text-muted\">通货膨胀率，决定于政府调控，一般通货膨胀率是 7%，各国基本一致。</small>\n            </div>\n            <!-- <p class=\"text-center\">\n                <button type=\"submit\" class=\"btn btn-primary\">分析计算</button>\n            </p> -->\n            <div class=\"alert alert-success\" role=\"alert\">\n                【通膨抵消】<br>\n                <span id=\"info6\"></span>\n            </div>\n            <hr>\n            <div class=\"alert alert-primary\" role=\"alert\">\n                【信息汇总】<br>\n                <span id=\"info7\"></span>\n            </div>\n            <div class=\"alert alert-danger\" role=\"alert\">\n                【卖时成本】<br>\n                <span id=\"info8\"></span>\n            </div>\n            <div class=\"alert alert-warning\" role=\"alert\">\n                【收益计算】<br>\n                <span id=\"info9\"></span>\n            </div>\n            <hr>\n        </form>\n    </div>\n\n    <script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js\"></script>\n    <script src=\"https://cdn.bootcss.com/jquery-url-parser/2.3.1/purl.min.js\"></script>\n    <script>\n        /*!\n         * Form Cache v0.0.3\n         * https://github.com/fengyuanchen/formcache\n         *\n         * Copyright 2014 Fengyuan Chen\n         * Released under the MIT license\n         *\n         * Date: 2014-12-17T12:42:29.194Z\n         */\n        ! function (a) {\n            \"function\" == typeof define && define.amd ? define(\"formcache\", [\"jquery\"], a) : a(jQuery)\n        }(function (a) {\n            \"use strict\";\n            var b = a(window),\n                c = window.sessionStorage,\n                d = window.localStorage,\n                e = \"undefined\",\n                f = \".formcache\",\n                g = /[\\.\\*\\+\\^\\$\\:\\!\\[\\]#>~]+/g,\n                h = \"change\" + f,\n                i = \"beforeunload\" + f,\n                j = function (a) {\n                    return \"checkbox\" === a.type || \"radio\" === a.type\n                },\n                k = function (a) {\n                    return parseInt(a, 10)\n                },\n                l = function (b, c) {\n                    this.form = b, this.$form = a(b), this.defaults = a.extend({}, l.DEFAULTS, a.isPlainObject(c) ?\n                        c : {}), this.init()\n                };\n            l.prototype = {\n                    constructor: l,\n                    init: function () {\n                        var b = this.defaults;\n                        b.maxAge = Math.abs(b.maxAge || b.maxage), b.autoStore = Boolean(b.autoStore || b\n                                .autostore), this.initKey(), this.initStorage(), this.caches = this.storage\n                            .caches, this.index = 0, this.activeIndex = 0, this.storing = null, a.isArray(b\n                                .controls) || (b.controls = []), this.$controls = this.$form.find(b.controls\n                                .join()).not(\":file\"), this.addListeners(), this.outputCache()\n                    },\n                    initKey: function () {\n                        var b = this.$form,\n                            c = this.defaults.key || b.data(\"key\");\n                        c || (a(\"form\").each(function (b) {\n                            a(this).data(\"key\", b)\n                        }), c = b.data(\"key\")), this.key = location.pathname + \"#formcache-\" + c\n                    },\n                    initStorage: function () {\n                        var b, e = this.defaults,\n                            f = this.key,\n                            g = new Date,\n                            h = {\n                                date: g,\n                                maxAge: e.maxAge,\n                                caches: []\n                            };\n                        c && (b = c.getItem(f)), !b && d && (b = d.getItem(f)), b = \"string\" == typeof b ? JSON\n                            .parse(b) : null, a.isPlainObject(b) ? \"number\" == typeof b.maxAge && (g - new Date(\n                                b.date)) / 1e3 > b.maxAge && (b = h) : b = h, this.storage = b\n                    },\n                    addListeners: function () {\n                        this.defaults.autoStore && (this.$controls.on(h, a.proxy(this.change, this)), b.on(i, a\n                            .proxy(this.beforeunload, this)))\n                    },\n                    removeListeners: function () {\n                        this.defaults.autoStore && (this.$controls.off(h, this.change), b.off(i, this\n                            .beforeunload))\n                    },\n                    change: function (b) {\n                        var c, d, e = b.target,\n                            f = a(e),\n                            h = f.attr(\"name\"),\n                            i = [];\n                        h && (c = h.replace(g, \"\"), this.$controls.filter('[name*=\"' + c + '\"]').each(\n                            function () {\n                                j(e) ? i.push(this.checked) : (d = a(this).val(), d && i.push(d))\n                            }), i.length && (this.update(h, i), clearTimeout(this.storing), this\n                            .storing =\n                            setTimeout(a.proxy(this.store, this), 1e3)))\n                    },\n                    beforeunload: function () {\n                        this.update(), this.store()\n                    },\n                    update: function (a, b) {\n                        var c = this.activeIndex || this.index,\n                            d = this.getCache(c);\n                        \"string\" == typeof a ? d[a] = b : d = this.serialize(), this.setCache(c, d)\n                    },\n                    serialize: function () {\n                        var b = {};\n                        return this.$controls.each(function () {\n                            var c, d, e = a(this),\n                                f = e.attr(\"name\");\n                            f && (c = b[f], c = a.isArray(c) ? c : [], j(this) ? c.push(this.checked) :\n                                (d = e.val(), d && c.push(d)), c.length && (b[f] = c))\n                        }), b\n                    },\n                    getCache: function (a) {\n                        return this.caches[k(a) || this.index] || {}\n                    },\n                    getCaches: function () {\n                        return this.caches\n                    },\n                    setCache: function (b, c) {\n                        typeof c === e && (c = b, b = 0 / 0), a.isPlainObject(c) && (b = k(b) || this.index,\n                            this.caches[b] = c, this.store())\n                    },\n                    setCaches: function (b) {\n                        a.isArray(b) && (this.caches = b, this.store())\n                    },\n                    removeCache: function (a) {\n                        this.caches.splice(k(a) || this.index, 1), this.store()\n                    },\n                    removeCaches: function () {\n                        this.caches = [], this.store()\n                    },\n                    outputCache: function (b) {\n                        var c = this.getCache(b);\n                        a.isPlainObject(c) && (this.activeIndex = k(b) || this.index, c = a.extend(!0, {}, c),\n                            this.$controls.each(function () {\n                                var b, d, e = a(this),\n                                    f = e.attr(\"name\");\n                                f && (b = c[f], a.isArray(b) && b.length && (d = b.shift(), j(this) ?\n                                    this.checked = d : e.val(d)))\n                            }))\n                    },\n                    store: function () {\n                        var a = this.storage,\n                            b = this.key,\n                            e = this.defaults;\n                        a.date = new Date, a.maxAge = e.maxAge, a = JSON.stringify(a), e.session && c && c\n                            .setItem(b, a), e.local && d && d.setItem(b, a)\n                    },\n                    clear: function () {\n                        var a = this.key,\n                            b = this.defaults;\n                        b.session && c && c.removeItem(a), b.local && d && d.removeItem(a)\n                    },\n                    destroy: function () {\n                        this.removeListeners(), this.$form.removeData(\"formcache\")\n                    }\n                }, l.DEFAULTS = {\n                    key: \"\",\n                    local: !0,\n                    session: !0,\n                    autoStore: !0,\n                    maxAge: void 0,\n                    controls: [\"select\", \"textarea\", \"input\"]\n                }, l.setDefaults = function (b) {\n                    a.extend(l.DEFAULTS, b)\n                }, l.other = a.fn.formcache, a.fn.formcache = function (b) {\n                    var c, d = [].slice.call(arguments, 1);\n                    return this.each(function () {\n                        var e, f = a(this),\n                            g = f.data(\"formcache\");\n                        g || f.data(\"formcache\", g = new l(this, b)), \"string\" == typeof b && a.isFunction(\n                            e = g[b]) && (c = e.apply(g, d))\n                    }), typeof c !== e ? c : this\n                }, a.fn.formcache.Constructor = l, a.fn.formcache.setDefaults = l.setDefaults, a.fn.formcache\n                .noConflict = function () {\n                    return a.fn.formcache = l.other, this\n                }, a(function () {\n                    a('form[data-toggle=\"formcache\"]').formcache()\n                })\n        });\n    </script>\n    <script>\n        (() => {\n            const cache = {};\n            // 计算\n            const getLoan = () => {\n                const values = getValues();\n                const loan = values.area * values.price - values.pay;\n                return loan;\n            };\n\n            const getSupply = () => {\n                const values = getValues();\n                const monthRate = values.rate * values.float / 12 / 100;\n                const loan = getLoan();\n                const supply = loan * monthRate * Math.pow(1 + monthRate, values.year * 12) / (Math.pow(1 + monthRate,\n                    values.year * 12) - 1);\n                return supply;\n            };\n\n            const getTotalRepay = () => {\n                const values = getValues();\n                const monthRate = values.rate * values.float / 12 / 100;\n                const loan = getLoan();\n                const supply = getSupply();\n\n                let total = 0;\n                for (let i = 1; i <= values.sell * 12; i++) {\n                    total += supply - (loan * monthRate * (Math.pow(1 + monthRate, values.year * 12) - Math.pow(1 +\n                        monthRate, i - 1))) / (Math.pow(1 + monthRate, values.year * 12) - 1);\n                }\n\n                return total;\n            };\n\n            const getBankIncome = () => {\n                const values = getValues();\n                const rate3 = values['3rate'] / 100;\n                const rate1 = values['1rate'] / 100;\n                const payment = values.pay + values.other;\n                const supply = getSupply();\n                let total = payment * values.sell * rate3;\n                for (let i = values.sell - 1; i >= 3; i --) {\n                    total += supply * 12 * values.sell * rate3;\n                }\n                total += supply * 12 * 3 * rate1;\n                return total;\n            };\n\n            const getSwell = () => {\n                const values = getValues();\n                const supply = getSupply();\n                const swellRate = values.swell / 100;\n                let base = values.pay + values.other;\n                let total = base * Math.pow(1 +　swellRate, 8);\n                for (let i = values.sell - 1; i >= 1; i --) {\n                    base += supply * 12;\n                    total += supply * 12 * Math.pow(1 +　swellRate, i);\n                }\n                return total - base;\n            };\n\n            // 关联\n            const changePay = () => {\n                const values = getValues();\n                $(`#pay`).val((values.area * values.price) * 0.3);\n            };\n\n            const changeOther = () => {\n                const values = getValues();\n                $(`#other`).val((values.area * values.price) * 0.02);\n            };\n\n            const changeSell = () => {\n                const values = getValues();\n                $(`#sell`).val(parseInt(values.get) + 5);\n            };\n\n            // 分析\n            const changeInfo1 = () => {\n                const values = getValues();\n                $('#info1').html(\n                    `总价 ${(values.area * values.price / 10000).toFixed(2)} 万元，首付 ${((values.pay + values.other) / 10000).toFixed(2)} 万元，贷款 ${((values.area * values.price - values.pay) / 10000).toFixed(2)} 万元。`\n                );\n                cache.total = (values.area * values.price / 10000).toFixed(2);\n                cache.payment = ((values.pay + values.other) / 10000).toFixed(2);\n                cache.liabilities = ((values.area * values.price - values.pay) / 10000).toFixed(2);\n                changeInfo3();\n                changeInfo7();\n            };\n\n            const changeInfo2 = () => {\n                const values = getValues();\n                const loan = getLoan();\n                const supply = getSupply();\n                $('#info2').html(\n                    `· 年利率 ${(values.rate * values.float).toFixed(2)}%，年限 ${values.year} 年（ ${values.year * 12} 个月）。<br/>` + \n                    `· 等额本息月供 ${supply.toFixed(2)} 元，利息总和为 ${((supply * values.year * 12 - loan) / 10000).toFixed(2)} 万元。`\n                    );\n                cache.supply = supply.toFixed(2);\n                changeInfo3();\n                changeInfo7();\n            };\n\n            const changeInfo3 = () => {\n                const values = getValues();\n                const loan = getLoan();\n                const supply = getSupply();\n                const totalRepay = getTotalRepay();\n                const total = values.pay + values.other + values.sell * 12 * supply + loan - totalRepay;\n                $('#info3').html(\n                    `· 已经还款 ${values.sell * 12} 个月， 共还款 ${(values.sell * 12 * supply / 10000).toFixed(2)} 万元, 供还本金 ${(totalRepay / 10000).toFixed(2)} 万元，剩余本金 ${((loan - totalRepay) / 10000).toFixed(2)} 万元。<br/>` +\n                    `· 总成本为：${values.pay + values.other}(首付) + ${(values.sell * 12 * supply).toFixed(2)}(还款) + ${(loan - totalRepay).toFixed(2)}(剩余本金) = ${(total).toFixed(2)} 元 = ${(total / 10000).toFixed(2)} 万元。<br/>` +\n                    `· 对应每平单价为： ${(total / values.area).toFixed(0)} 元。`\n                );\n                cache.cost = total;\n                changeInfo4();\n                changeInfo5();\n                changeInfo6();\n            };\n\n            const changeInfo4 = () => {\n                const values = getValues();\n                $('#info4').html(\n                    `共营收 ${(values.income - values.expenditure) * (values.sell - values.get)} 元，对应每平减少成本 ${(((values.income - values.expenditure) * (values.sell - values.get)) / values.area).toFixed(0)} 元。`\n                    );\n                cache.totalIncome = (values.income - values.expenditure) * (values.sell - values.get);\n                changeInfo8();\n            };\n\n            const changeInfo5 = () => {\n                const values = getValues();\n                const bankIncome = getBankIncome();\n                $('#info5').html(\n                    `首付存定期，月供每年一次存定期，直接存到卖房时，获得的利息为 ${(bankIncome / 10000).toFixed(2)} 万元，对应每平增加成本 ${(bankIncome / values.area).toFixed(0)} 元。`\n                    );\n                changeInfo9();\n            };\n\n            const changeInfo6 = () => {\n                const values = getValues();\n                const swell = getSwell();\n                $('#info6').html(\n                    `抵消通货膨胀，需要增加收入 ${(swell / 10000).toFixed(2)} 万元，平均每平米需再增长 ${(swell / values.area).toFixed(0)} 元。`\n                    );\n                changeInfo9();\n            };\n\n            const changeInfo7 = () => {\n                const values = getValues();\n                $('#info7').html([\n                    `<ul>`, \n                        `<li>总价：${cache.total} 万元</li>`,\n                        `<li>单价：${values.price} 元</li>`,\n                        `<li>首付：${cache.payment} 万元</li>`,\n                        `<li>贷款：${cache.liabilities} 万元</li>`,\n                        `<li>月供：${cache.supply} 元</li>`,\n                    `</ul>`\n                ].join(''));\n            };\n\n            const changeInfo8 = () => {\n                const values = getValues();\n                $('#info8').html([\n                    `<ul>`, \n                        `<li>成本：${((cache.cost - cache.totalIncome) / 10000).toFixed(2)} 万元</li>`,\n                        `<li>单价：${((cache.cost - cache.totalIncome) / values.area).toFixed(0)} 元</li>`,\n                    `</ul>`\n                ].join(''));\n\n            };\n\n            const changeInfo9 = () => {\n                const values = getValues();\n                $('#info9').html([\n                    `<ul>`, \n                        `<li>总价达到 ${((cache.cost - cache.totalIncome + getBankIncome()) / 10000).toFixed(2)} 万元，能与银行定期收益持平，对应单价为 ${((cache.cost - cache.totalIncome + getBankIncome()) / values.area).toFixed(0)} 元。</li>`,\n                        `<li>总价达到 ${((cache.cost - cache.totalIncome + getSwell()) / 10000).toFixed(2)} 万元，能抵消通货膨胀，对应单价为 ${((cache.cost - cache.totalIncome + getSwell()) / values.area).toFixed(0)} 元。</li>`,\n                    `</ul>`\n                ].join(''));\n            };\n\n            const inputOpts = {\n                price: {\n                    default: 10000,\n                    change: [changePay, changeOther, changeInfo1]\n                },\n                area: {\n                    default: 90,\n                    change: [changePay, changeOther, changeInfo1]\n                },\n                pay: {\n                    default: 270000,\n                    change: [changeInfo1]\n                },\n                other: {\n                    default: 18000,\n                    change: [changeInfo1]\n                },\n                rate: {\n                    default: 4.9,\n                    change: [changeInfo2]\n                },\n                float: {\n                    default: '1.00',\n                    change: [changeInfo2]\n                },\n                year: {\n                    default: 25,\n                    change: [changeInfo2]\n                },\n                get: {\n                    default: 0,\n                    change: [changeSell, changeInfo3]\n                },\n                sell: {\n                    default: 5,\n                    change: [changeInfo3]\n                },\n                expenditure: {\n                    default: 0,\n                    change: [changeInfo4]\n                },\n                income: {\n                    default: 0,\n                    change: [changeInfo4]\n                },\n                '3rate': {\n                    default: 4,\n                    change: [changeInfo5]\n                },\n                '1rate': {\n                    default: 2,\n                    change: [changeInfo5]\n                },\n                swell: {\n                    default: 7,\n                    change: [changeInfo6]\n                }\n            };\n\n            const getValues = () => {\n                const res = {};\n                Object.keys(inputOpts).forEach((key) => {\n                    res[key] = parseFloat($(`#${key}`).val());\n                });\n                return res;\n            };\n\n\n            const handleChange = (e) => {\n                const id = e.target.id;\n                const opt = inputOpts[id];\n                if (opt.change) {\n                    [].concat(opt.change).forEach(t => t());\n                }\n                var cache = $('form').formcache('serialize');\n                $('form').formcache('setCache', cache);\n                history.replaceState(null, document.title, \"/eicalc.html?data=\" + encodeURIComponent(JSON.stringify(cache)));\n            };\n\n            $(() => {\n                $('form').delegate('input', 'focus', (e) => {\n                    const value = e.target.value;\n                    e.target.value = '';\n                    const onblur = () => {\n                        if (isNaN(parseFloat(e.target.value))) {\n                            e.target.value = value;\n                            handleChange(e);\n                        }\n                        e.target.removeEventListener('blur', onblur);\n                    };\n                    e.target.addEventListener('blur', onblur, false);\n                });\n\n                $('form').delegate('input,select', 'change', handleChange);\n                const data = $.url().param('data');\n                if (data) {\n                    try {\n                        const cache = JSON.parse(decodeURIComponent(data));\n                        $('form').formcache('setCache', cache);\n                    } catch(e) {}\n                }\n                $('form').formcache('outputCache');\n                changeInfo1();\n                changeInfo2();\n            });\n        })();\n    </script>\n</body>\n\n</html>"}],"Post":[{"title":"WebIM实践过程中可能遇到的问题及总结","date":"2015-10-04T10:55:33.000Z","thumbnailImage":"https://ws3.sinaimg.cn/large/006tKfTcly1frsep4zshhj30cs0cs755.jpg","thumbnailImagePosition":"left","_content":"\n昨天晚上到今天早晨，在微信群QCon可扩展高可用框架群，被 @TimYang 拉进群，主要讨论了一下 WebIM前端的相关问题。\n\n把群里的讨论内容和我自己的一些看法总结如下： <!-- more -->\n\n1. 对于PC端的WebIM，使用WebScoket结合长轮询的方式。使用长轮询，不仅仅因为WebSocket浏览器兼容性问题，还有就是网络原因，有些网络对WebSocket有限制，原来遇到过，能和WebSocket Server建立链接，但是数据包发送，对方收不到的情况。要视情况，切换到长轮训方式。\n2. 关于长轮询，它的及时性是很高的。不同于定时轮询，它的原理是，Client端发请求，Server端Pendding，当有需要推送的消息或者超过一定时间，才会Response。然后Client端再发起请求。这样能保证，推送消息的及时性。同域可以用Ajax，跨域可以用Jsonp。因为url长度限制的原因，Jsonp形式对消息长度有限制。或者限制消息长度，或者消息过长，分多次请求发送。\n3. 在支持http1.1的浏览器里，可以用长链接，用得很少，坑未知。\n4. 移动Web上，用WebSocket兼容性问题少，理论上绝大多数机型，都支持WebScoket，但是耗电量和持续性不好处理，页面在后台时，线程可能被停掉，这样不能保证在停掉期间，消息的及时推送。现在移动端纯Web端，对于及时通信，个人暂时没有了解到比较靠谱的方案。\n5. 对于服务，可以用CometD。如果考虑node的话，可以看一下socket.io。\n6. Ack，为了适应各种『糟糕』的网络情况，和消息相关的都要做ack确认，服务端，在一定时间内，没收到ack，要重新push消息。而前端要对消息进行判重（有可能前端发ack了，服务端没收到，又重新push了）。\n7. 状态同步，主要是已读状态同步，一端阅读消息后，要通过服务器将已读状态分发给其他各端。状态同步，还涉及到一个地方是重练后的状态同步。网络断开、请求超时、心跳超时，前端都会进行重练，重练后需要同步所有的状态，因为你不知道重练期间，究竟发生了什么。当然，重练也有逻辑的，不能一有问题就立即重练，要做延时。否则出问题时，容易滚雪球造成更大问题。\n8. 使用Flash，可以用Flash与服务器创建Tcp链接，激活的页面与服务端及时同步，非激活页面同步时间长。\n\n最后，感谢各位的对技术的热情和毫无保留的解答疑问。\n","source":"_posts/2015-10-04-WebIM实践过程中可能遇到的问题及总结.md","raw":"title: WebIM实践过程中可能遇到的问题及总结\ndate: 2015-10-04 18:55:33\ntags: [Weibo, IM]\ncategories: [随笔]\nthumbnailImage: https://ws3.sinaimg.cn/large/006tKfTcly1frsep4zshhj30cs0cs755.jpg\nthumbnailImagePosition: left\n---\n\n昨天晚上到今天早晨，在微信群QCon可扩展高可用框架群，被 @TimYang 拉进群，主要讨论了一下 WebIM前端的相关问题。\n\n把群里的讨论内容和我自己的一些看法总结如下： <!-- more -->\n\n1. 对于PC端的WebIM，使用WebScoket结合长轮询的方式。使用长轮询，不仅仅因为WebSocket浏览器兼容性问题，还有就是网络原因，有些网络对WebSocket有限制，原来遇到过，能和WebSocket Server建立链接，但是数据包发送，对方收不到的情况。要视情况，切换到长轮训方式。\n2. 关于长轮询，它的及时性是很高的。不同于定时轮询，它的原理是，Client端发请求，Server端Pendding，当有需要推送的消息或者超过一定时间，才会Response。然后Client端再发起请求。这样能保证，推送消息的及时性。同域可以用Ajax，跨域可以用Jsonp。因为url长度限制的原因，Jsonp形式对消息长度有限制。或者限制消息长度，或者消息过长，分多次请求发送。\n3. 在支持http1.1的浏览器里，可以用长链接，用得很少，坑未知。\n4. 移动Web上，用WebSocket兼容性问题少，理论上绝大多数机型，都支持WebScoket，但是耗电量和持续性不好处理，页面在后台时，线程可能被停掉，这样不能保证在停掉期间，消息的及时推送。现在移动端纯Web端，对于及时通信，个人暂时没有了解到比较靠谱的方案。\n5. 对于服务，可以用CometD。如果考虑node的话，可以看一下socket.io。\n6. Ack，为了适应各种『糟糕』的网络情况，和消息相关的都要做ack确认，服务端，在一定时间内，没收到ack，要重新push消息。而前端要对消息进行判重（有可能前端发ack了，服务端没收到，又重新push了）。\n7. 状态同步，主要是已读状态同步，一端阅读消息后，要通过服务器将已读状态分发给其他各端。状态同步，还涉及到一个地方是重练后的状态同步。网络断开、请求超时、心跳超时，前端都会进行重练，重练后需要同步所有的状态，因为你不知道重练期间，究竟发生了什么。当然，重练也有逻辑的，不能一有问题就立即重练，要做延时。否则出问题时，容易滚雪球造成更大问题。\n8. 使用Flash，可以用Flash与服务器创建Tcp链接，激活的页面与服务端及时同步，非激活页面同步时间长。\n\n最后，感谢各位的对技术的热情和毫无保留的解答疑问。\n","slug":"2015-10-04-WebIM实践过程中可能遇到的问题及总结","published":1,"updated":"2018-05-29T10:54:20.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc6s0001hxp4eivhq11h","content":"<p>昨天晚上到今天早晨，在微信群QCon可扩展高可用框架群，被 @TimYang 拉进群，主要讨论了一下 WebIM前端的相关问题。</p>\n<p>把群里的讨论内容和我自己的一些看法总结如下： <a id=\"more\"></a></p>\n<ol>\n<li>对于PC端的WebIM，使用WebScoket结合长轮询的方式。使用长轮询，不仅仅因为WebSocket浏览器兼容性问题，还有就是网络原因，有些网络对WebSocket有限制，原来遇到过，能和WebSocket Server建立链接，但是数据包发送，对方收不到的情况。要视情况，切换到长轮训方式。</li>\n<li>关于长轮询，它的及时性是很高的。不同于定时轮询，它的原理是，Client端发请求，Server端Pendding，当有需要推送的消息或者超过一定时间，才会Response。然后Client端再发起请求。这样能保证，推送消息的及时性。同域可以用Ajax，跨域可以用Jsonp。因为url长度限制的原因，Jsonp形式对消息长度有限制。或者限制消息长度，或者消息过长，分多次请求发送。</li>\n<li>在支持http1.1的浏览器里，可以用长链接，用得很少，坑未知。</li>\n<li>移动Web上，用WebSocket兼容性问题少，理论上绝大多数机型，都支持WebScoket，但是耗电量和持续性不好处理，页面在后台时，线程可能被停掉，这样不能保证在停掉期间，消息的及时推送。现在移动端纯Web端，对于及时通信，个人暂时没有了解到比较靠谱的方案。</li>\n<li>对于服务，可以用CometD。如果考虑node的话，可以看一下socket.io。</li>\n<li>Ack，为了适应各种『糟糕』的网络情况，和消息相关的都要做ack确认，服务端，在一定时间内，没收到ack，要重新push消息。而前端要对消息进行判重（有可能前端发ack了，服务端没收到，又重新push了）。</li>\n<li>状态同步，主要是已读状态同步，一端阅读消息后，要通过服务器将已读状态分发给其他各端。状态同步，还涉及到一个地方是重练后的状态同步。网络断开、请求超时、心跳超时，前端都会进行重练，重练后需要同步所有的状态，因为你不知道重练期间，究竟发生了什么。当然，重练也有逻辑的，不能一有问题就立即重练，要做延时。否则出问题时，容易滚雪球造成更大问题。</li>\n<li>使用Flash，可以用Flash与服务器创建Tcp链接，激活的页面与服务端及时同步，非激活页面同步时间长。</li>\n</ol>\n<p>最后，感谢各位的对技术的热情和毫无保留的解答疑问。</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws3.sinaimg.cn/large/006tKfTcly1frsep4zshhj30cs0cs755.jpg","excerpt":"<p>昨天晚上到今天早晨，在微信群QCon可扩展高可用框架群，被 @TimYang 拉进群，主要讨论了一下 WebIM前端的相关问题。</p>\n<p>把群里的讨论内容和我自己的一些看法总结如下：","more":"</p>\n<ol>\n<li>对于PC端的WebIM，使用WebScoket结合长轮询的方式。使用长轮询，不仅仅因为WebSocket浏览器兼容性问题，还有就是网络原因，有些网络对WebSocket有限制，原来遇到过，能和WebSocket Server建立链接，但是数据包发送，对方收不到的情况。要视情况，切换到长轮训方式。</li>\n<li>关于长轮询，它的及时性是很高的。不同于定时轮询，它的原理是，Client端发请求，Server端Pendding，当有需要推送的消息或者超过一定时间，才会Response。然后Client端再发起请求。这样能保证，推送消息的及时性。同域可以用Ajax，跨域可以用Jsonp。因为url长度限制的原因，Jsonp形式对消息长度有限制。或者限制消息长度，或者消息过长，分多次请求发送。</li>\n<li>在支持http1.1的浏览器里，可以用长链接，用得很少，坑未知。</li>\n<li>移动Web上，用WebSocket兼容性问题少，理论上绝大多数机型，都支持WebScoket，但是耗电量和持续性不好处理，页面在后台时，线程可能被停掉，这样不能保证在停掉期间，消息的及时推送。现在移动端纯Web端，对于及时通信，个人暂时没有了解到比较靠谱的方案。</li>\n<li>对于服务，可以用CometD。如果考虑node的话，可以看一下socket.io。</li>\n<li>Ack，为了适应各种『糟糕』的网络情况，和消息相关的都要做ack确认，服务端，在一定时间内，没收到ack，要重新push消息。而前端要对消息进行判重（有可能前端发ack了，服务端没收到，又重新push了）。</li>\n<li>状态同步，主要是已读状态同步，一端阅读消息后，要通过服务器将已读状态分发给其他各端。状态同步，还涉及到一个地方是重练后的状态同步。网络断开、请求超时、心跳超时，前端都会进行重练，重练后需要同步所有的状态，因为你不知道重练期间，究竟发生了什么。当然，重练也有逻辑的，不能一有问题就立即重练，要做延时。否则出问题时，容易滚雪球造成更大问题。</li>\n<li>使用Flash，可以用Flash与服务器创建Tcp链接，激活的页面与服务端及时同步，非激活页面同步时间长。</li>\n</ol>\n<p>最后，感谢各位的对技术的热情和毫无保留的解答疑问。</p>"},{"title":"前端工程师迈向全栈工程师之路","date":"2015-10-07T09:30:47.000Z","thumbnailImage":"https://ws4.sinaimg.cn/large/006tKfTcly1frsen4axjxj30ru0o6wv8.jpg","thumbnailImagePosition":"left","_content":"\n**What is a Full Stack developer?**  <!-- more -->\n\nIs it reasonable to expect mere mortals to have mastery over every facet of the development stack? Probably not, but Facebook can ask for it. I was told at OSCON by a Facebook employee that they only hire ‘Full Stack’ developers.  Well, what does that mean?\n\nTo me, a Full Stack Developer is someone with familiarity in each layer, if not mastery in many and a genuine interest in all software technology.\n\n<https://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/>\n\n---\n\n上面的蚊帐里对全栈工程师（*Full Stack Engineer*）进行了一下简单的定义。\n\n全栈工程师，也叫全端工程师，是一种新兴的工程师分类，是一类掌握多种技术，并能利用它们独立完成产品的工程师。\n\n技术一般有两种发展方向：一种是深度优先，把一项技术搞深搞透；另一种是广度优先，也就是全栈工程师的发展方向，这个方向的结果更像瑞士军刀。\n\n下面，阐述我的一些理解以及我计划要走的路：\n\n#### 全栈工程师的意义\n\n我理解的全栈工程师的意义，在于全局性思维，可以统筹一个项目，对项目的整体进行架构、技术选型，从而降低项目成员之间的沟通成本。\n而且全栈工程师的意义绝对不是一个人开发一个完整项目。\n\n另外，全栈也分不同的方向，不同的方向对全栈的要求也不同，其中一个很重要的方向是，移动。\n\n#### 移动全栈工程师\n\n移动方向当前非常火热，而且会一直火热下去。而现在移动开发有很多『殇』，例如不同平台的统一、发布部署方式、更新成本等等。\n\n而随着 FaceBook 的 React Native 的发布，混合开发成为了炙手可热的话题。\n但是性能、扩展性等种种问题，也制约着它的发展。\n这就引出一个非常重要的问题：哪些地方该用什么方式？该用什么技术？\n\n**这就需要一个能懂得大部分移动技术的人权衡并确定方案，这个人就是我理解的移动全栈工程师。**\n\n#### 移动全栈工程师需要『精通』什么技术？\n\n* 移动原生开发： iOS 和 Android 等平台的原生开发。\n* 平台间的差异性： 例如推送机制、后台程序机制。\n* 数据平台技术： 服务端技术，和App端更好更稳定地进行数据交互。\n* 移动前端技术： 包括移动 Web 技术和 Hybrid 技术，有些应用场景使用 Web 更适合。\n* 更新和部署： 快速部署、降低更新成本，是产品成长必须攻克的难关\n* 数据安全： 各个环节都会涉及到数据的安全，一个再好的方案，安全不过关，也是很差的。\n* 其他： 开发工具、自动化测试等\n\n#### 为什么我要成为移动全栈工程师？\n\n* 我喜欢学习和尝试各种技术。\n* 精通移动前端，Hybrid 前端方案。\n* 有一定的 Native 开发基础，包括 iOS 和 Android。\n* 有一定服务端技术基础，熟悉 JAVA 的 SSH 以及 PHP、ROR。\n* 对网络技术和原理较为精通。\n* 正在从事这方面工作。\n\n很多全栈型工程师，是因为要创业才成为全栈型工程师的，但是我不是。\n我单纯是对技术的热爱，而且我相信，每个对技术热爱的人，都有一颗成为全栈工程师的心。\n","source":"_posts/2015-10-07-前端工程师迈向全栈工程师之路.md","raw":"title: 前端工程师迈向全栈工程师之路\ndate: 2015-10-07 17:30:47\ncategories: 随笔\ntags: [前端, 全栈]\nthumbnailImage: https://ws4.sinaimg.cn/large/006tKfTcly1frsen4axjxj30ru0o6wv8.jpg\nthumbnailImagePosition: left\n---\n\n**What is a Full Stack developer?**  <!-- more -->\n\nIs it reasonable to expect mere mortals to have mastery over every facet of the development stack? Probably not, but Facebook can ask for it. I was told at OSCON by a Facebook employee that they only hire ‘Full Stack’ developers.  Well, what does that mean?\n\nTo me, a Full Stack Developer is someone with familiarity in each layer, if not mastery in many and a genuine interest in all software technology.\n\n<https://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/>\n\n---\n\n上面的蚊帐里对全栈工程师（*Full Stack Engineer*）进行了一下简单的定义。\n\n全栈工程师，也叫全端工程师，是一种新兴的工程师分类，是一类掌握多种技术，并能利用它们独立完成产品的工程师。\n\n技术一般有两种发展方向：一种是深度优先，把一项技术搞深搞透；另一种是广度优先，也就是全栈工程师的发展方向，这个方向的结果更像瑞士军刀。\n\n下面，阐述我的一些理解以及我计划要走的路：\n\n#### 全栈工程师的意义\n\n我理解的全栈工程师的意义，在于全局性思维，可以统筹一个项目，对项目的整体进行架构、技术选型，从而降低项目成员之间的沟通成本。\n而且全栈工程师的意义绝对不是一个人开发一个完整项目。\n\n另外，全栈也分不同的方向，不同的方向对全栈的要求也不同，其中一个很重要的方向是，移动。\n\n#### 移动全栈工程师\n\n移动方向当前非常火热，而且会一直火热下去。而现在移动开发有很多『殇』，例如不同平台的统一、发布部署方式、更新成本等等。\n\n而随着 FaceBook 的 React Native 的发布，混合开发成为了炙手可热的话题。\n但是性能、扩展性等种种问题，也制约着它的发展。\n这就引出一个非常重要的问题：哪些地方该用什么方式？该用什么技术？\n\n**这就需要一个能懂得大部分移动技术的人权衡并确定方案，这个人就是我理解的移动全栈工程师。**\n\n#### 移动全栈工程师需要『精通』什么技术？\n\n* 移动原生开发： iOS 和 Android 等平台的原生开发。\n* 平台间的差异性： 例如推送机制、后台程序机制。\n* 数据平台技术： 服务端技术，和App端更好更稳定地进行数据交互。\n* 移动前端技术： 包括移动 Web 技术和 Hybrid 技术，有些应用场景使用 Web 更适合。\n* 更新和部署： 快速部署、降低更新成本，是产品成长必须攻克的难关\n* 数据安全： 各个环节都会涉及到数据的安全，一个再好的方案，安全不过关，也是很差的。\n* 其他： 开发工具、自动化测试等\n\n#### 为什么我要成为移动全栈工程师？\n\n* 我喜欢学习和尝试各种技术。\n* 精通移动前端，Hybrid 前端方案。\n* 有一定的 Native 开发基础，包括 iOS 和 Android。\n* 有一定服务端技术基础，熟悉 JAVA 的 SSH 以及 PHP、ROR。\n* 对网络技术和原理较为精通。\n* 正在从事这方面工作。\n\n很多全栈型工程师，是因为要创业才成为全栈型工程师的，但是我不是。\n我单纯是对技术的热爱，而且我相信，每个对技术热爱的人，都有一颗成为全栈工程师的心。\n","slug":"2015-10-07-前端工程师迈向全栈工程师之路","published":1,"updated":"2018-06-25T03:18:28.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc6v0003hxp4oamombca","content":"<p><strong>What is a Full Stack developer?</strong>  <a id=\"more\"></a></p>\n<p>Is it reasonable to expect mere mortals to have mastery over every facet of the development stack? Probably not, but Facebook can ask for it. I was told at OSCON by a Facebook employee that they only hire ‘Full Stack’ developers.  Well, what does that mean?</p>\n<p>To me, a Full Stack Developer is someone with familiarity in each layer, if not mastery in many and a genuine interest in all software technology.</p>\n<p><a href=\"https://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/\" target=\"_blank\" rel=\"noopener\">https://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/</a></p>\n<hr>\n<p>上面的蚊帐里对全栈工程师（<em>Full Stack Engineer</em>）进行了一下简单的定义。</p>\n<p>全栈工程师，也叫全端工程师，是一种新兴的工程师分类，是一类掌握多种技术，并能利用它们独立完成产品的工程师。</p>\n<p>技术一般有两种发展方向：一种是深度优先，把一项技术搞深搞透；另一种是广度优先，也就是全栈工程师的发展方向，这个方向的结果更像瑞士军刀。</p>\n<p>下面，阐述我的一些理解以及我计划要走的路：</p>\n<h4 id=\"全栈工程师的意义\"><a href=\"#全栈工程师的意义\" class=\"headerlink\" title=\"全栈工程师的意义\"></a>全栈工程师的意义</h4><p>我理解的全栈工程师的意义，在于全局性思维，可以统筹一个项目，对项目的整体进行架构、技术选型，从而降低项目成员之间的沟通成本。<br>而且全栈工程师的意义绝对不是一个人开发一个完整项目。</p>\n<p>另外，全栈也分不同的方向，不同的方向对全栈的要求也不同，其中一个很重要的方向是，移动。</p>\n<h4 id=\"移动全栈工程师\"><a href=\"#移动全栈工程师\" class=\"headerlink\" title=\"移动全栈工程师\"></a>移动全栈工程师</h4><p>移动方向当前非常火热，而且会一直火热下去。而现在移动开发有很多『殇』，例如不同平台的统一、发布部署方式、更新成本等等。</p>\n<p>而随着 FaceBook 的 React Native 的发布，混合开发成为了炙手可热的话题。<br>但是性能、扩展性等种种问题，也制约着它的发展。<br>这就引出一个非常重要的问题：哪些地方该用什么方式？该用什么技术？</p>\n<p><strong>这就需要一个能懂得大部分移动技术的人权衡并确定方案，这个人就是我理解的移动全栈工程师。</strong></p>\n<h4 id=\"移动全栈工程师需要『精通』什么技术？\"><a href=\"#移动全栈工程师需要『精通』什么技术？\" class=\"headerlink\" title=\"移动全栈工程师需要『精通』什么技术？\"></a>移动全栈工程师需要『精通』什么技术？</h4><ul>\n<li>移动原生开发： iOS 和 Android 等平台的原生开发。</li>\n<li>平台间的差异性： 例如推送机制、后台程序机制。</li>\n<li>数据平台技术： 服务端技术，和App端更好更稳定地进行数据交互。</li>\n<li>移动前端技术： 包括移动 Web 技术和 Hybrid 技术，有些应用场景使用 Web 更适合。</li>\n<li>更新和部署： 快速部署、降低更新成本，是产品成长必须攻克的难关</li>\n<li>数据安全： 各个环节都会涉及到数据的安全，一个再好的方案，安全不过关，也是很差的。</li>\n<li>其他： 开发工具、自动化测试等</li>\n</ul>\n<h4 id=\"为什么我要成为移动全栈工程师？\"><a href=\"#为什么我要成为移动全栈工程师？\" class=\"headerlink\" title=\"为什么我要成为移动全栈工程师？\"></a>为什么我要成为移动全栈工程师？</h4><ul>\n<li>我喜欢学习和尝试各种技术。</li>\n<li>精通移动前端，Hybrid 前端方案。</li>\n<li>有一定的 Native 开发基础，包括 iOS 和 Android。</li>\n<li>有一定服务端技术基础，熟悉 JAVA 的 SSH 以及 PHP、ROR。</li>\n<li>对网络技术和原理较为精通。</li>\n<li>正在从事这方面工作。</li>\n</ul>\n<p>很多全栈型工程师，是因为要创业才成为全栈型工程师的，但是我不是。<br>我单纯是对技术的热爱，而且我相信，每个对技术热爱的人，都有一颗成为全栈工程师的心。</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws4.sinaimg.cn/large/006tKfTcly1frsen4axjxj30ru0o6wv8.jpg","excerpt":"<p><strong>What is a Full Stack developer?</strong>","more":"</p>\n<p>Is it reasonable to expect mere mortals to have mastery over every facet of the development stack? Probably not, but Facebook can ask for it. I was told at OSCON by a Facebook employee that they only hire ‘Full Stack’ developers.  Well, what does that mean?</p>\n<p>To me, a Full Stack Developer is someone with familiarity in each layer, if not mastery in many and a genuine interest in all software technology.</p>\n<p><a href=\"https://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/\" target=\"_blank\" rel=\"noopener\">https://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/</a></p>\n<hr>\n<p>上面的蚊帐里对全栈工程师（<em>Full Stack Engineer</em>）进行了一下简单的定义。</p>\n<p>全栈工程师，也叫全端工程师，是一种新兴的工程师分类，是一类掌握多种技术，并能利用它们独立完成产品的工程师。</p>\n<p>技术一般有两种发展方向：一种是深度优先，把一项技术搞深搞透；另一种是广度优先，也就是全栈工程师的发展方向，这个方向的结果更像瑞士军刀。</p>\n<p>下面，阐述我的一些理解以及我计划要走的路：</p>\n<h4 id=\"全栈工程师的意义\"><a href=\"#全栈工程师的意义\" class=\"headerlink\" title=\"全栈工程师的意义\"></a>全栈工程师的意义</h4><p>我理解的全栈工程师的意义，在于全局性思维，可以统筹一个项目，对项目的整体进行架构、技术选型，从而降低项目成员之间的沟通成本。<br>而且全栈工程师的意义绝对不是一个人开发一个完整项目。</p>\n<p>另外，全栈也分不同的方向，不同的方向对全栈的要求也不同，其中一个很重要的方向是，移动。</p>\n<h4 id=\"移动全栈工程师\"><a href=\"#移动全栈工程师\" class=\"headerlink\" title=\"移动全栈工程师\"></a>移动全栈工程师</h4><p>移动方向当前非常火热，而且会一直火热下去。而现在移动开发有很多『殇』，例如不同平台的统一、发布部署方式、更新成本等等。</p>\n<p>而随着 FaceBook 的 React Native 的发布，混合开发成为了炙手可热的话题。<br>但是性能、扩展性等种种问题，也制约着它的发展。<br>这就引出一个非常重要的问题：哪些地方该用什么方式？该用什么技术？</p>\n<p><strong>这就需要一个能懂得大部分移动技术的人权衡并确定方案，这个人就是我理解的移动全栈工程师。</strong></p>\n<h4 id=\"移动全栈工程师需要『精通』什么技术？\"><a href=\"#移动全栈工程师需要『精通』什么技术？\" class=\"headerlink\" title=\"移动全栈工程师需要『精通』什么技术？\"></a>移动全栈工程师需要『精通』什么技术？</h4><ul>\n<li>移动原生开发： iOS 和 Android 等平台的原生开发。</li>\n<li>平台间的差异性： 例如推送机制、后台程序机制。</li>\n<li>数据平台技术： 服务端技术，和App端更好更稳定地进行数据交互。</li>\n<li>移动前端技术： 包括移动 Web 技术和 Hybrid 技术，有些应用场景使用 Web 更适合。</li>\n<li>更新和部署： 快速部署、降低更新成本，是产品成长必须攻克的难关</li>\n<li>数据安全： 各个环节都会涉及到数据的安全，一个再好的方案，安全不过关，也是很差的。</li>\n<li>其他： 开发工具、自动化测试等</li>\n</ul>\n<h4 id=\"为什么我要成为移动全栈工程师？\"><a href=\"#为什么我要成为移动全栈工程师？\" class=\"headerlink\" title=\"为什么我要成为移动全栈工程师？\"></a>为什么我要成为移动全栈工程师？</h4><ul>\n<li>我喜欢学习和尝试各种技术。</li>\n<li>精通移动前端，Hybrid 前端方案。</li>\n<li>有一定的 Native 开发基础，包括 iOS 和 Android。</li>\n<li>有一定服务端技术基础，熟悉 JAVA 的 SSH 以及 PHP、ROR。</li>\n<li>对网络技术和原理较为精通。</li>\n<li>正在从事这方面工作。</li>\n</ul>\n<p>很多全栈型工程师，是因为要创业才成为全栈型工程师的，但是我不是。<br>我单纯是对技术的热爱，而且我相信，每个对技术热爱的人，都有一颗成为全栈工程师的心。</p>"},{"title":"移动Hybrid开发加速器——模拟器","date":"2015-10-10T16:00:00.000Z","thumbnailImage":"https://ws1.sinaimg.cn/large/006cGJIjly1fizahur9o3j308k04twel.jpg","_content":"\nHybrid App（混合模式移动应用）是指介于Web App、Native App这两者之间的App，兼具『Native App良好用户交互体验的优势』和『Web App跨平台开发的优势』。<!-- more -->\n\n#### 移动 Hybrid 开发遇到的调试问题\n\n随着 Hybrid 思想的推广和其技术的日益成熟，以及 Cordova(PhoneGap)、React Native、Ionic、Titanium 以及我厂的 Hy 这些 Hybrid 形式框架的推出，开发者使用这项技术创建 Hybrid App 的场景越来越多。\n\n与此同时，在开发中遇到的问题也逐渐显现，由于前端代码需要和Native代码进行逻辑上的交互，而且开发人员都是前端工程师，因此『调试异常繁琐』这个问题尤为显著。\n\n对于调试问题，现有的解决方式是:\n\n* 利用 Chrome 开发者工具的设备模拟选项，来模拟移动设备上的浏览器，同时，利用 Chrome 插件来模拟前端与Native的交互。\n* 真机调试，将 App 装到真实的移动设备上，进行调试。\n\n对于，第一种方案 Chrome 插件不可能完全一致的模拟 Native 环境，例如多页面通信、原生应用服务环境等，是非常难以模拟的；\n而第二种方案，需要通过配置 Host、DNS 或者代理将前端资源指向可调试的代码的方式繁琐、iOS可调试App的安装限制及真机设备成本问题，也是不可避免的。\n\n从上面的描述，我们看到调试是十分繁琐的，严重影响开发的效率。\n\n在这里，我将要准备分享一个较为简便的调试方式——利用模拟器。\n\n#### 对模拟器的误解\n\n对于模拟器，前端开发人员甚至Android开发人员都使用甚少，甚至有很多误解。\n\n* 模拟器是Native开发人员用的，前端开发人员使用起来会很难，并不能快速上手。 By 前端开发人员\n* 模拟器太慢，严重影响开发效率。 By Android开发人员\n* 模拟器中的App是Xcode编译出来的，使用的人需要源代码才能把App装到自己电脑上的模拟器上。 By iOS开发人员\n* 等等\n\n这种种问题我认为都是对模拟器的误解，其实模拟器很好用的。\n\n#### 模拟器现状\n\n##### iOS 模拟器\n\n对于 iOS 模拟器，iOS 开发者并不陌生，安装了 Xcode 后，你的 Mac 就会拥有模拟器（最新版本的，指定版本需要自行下载）。\n\niOS 模拟器和真机差别微乎其微，开发者完全在模拟器上完成项目的开发。\n\nXcode 提供了 `xcrun simctl` 命令来控制模拟器。\n\n```\n~ xcrun simctl\nUsage: simctl [--noxpc] [--set <set path>] <subcommand> ... | help [subcommand]\nCommand line utility to control the Simulator\n\nFor subcommands that require a <device> argument, you may specify a device UDID\nor the special \"booted\" string which will cause simctl to pick a booted device.\nIf multiple devices are booted when the \"booted\" device is selected, simctl\nwill choose one of them.\n\nSubcommands:\n   create              Create a new device.\n   delete              Delete a device or all unavailable devices.\n   pair                Create a new watch / phone pair.\n   unpair              Unpair a watch and phone phone.\n   erase               Erase a device's contents and settings.\n   boot                Boot a device.\n   shutdown            Shutdown a device.\n   rename              Rename a device.\n   getenv              Print an environment variable from a running device.\n   openurl             Open a URL in a device.\n   addphoto            Add photos to the photo library of a device.\n   install             Install an app on a device.\n   uninstall           Uninstall an app from a device.\n   get_app_container   Print the path of the intsalled app's container\n   launch              Launch an application by identifier on a device.\n   spawn               Spawn a process on a device.\n   list                List available devices, device types, runtimes, or device pairs.\n   icloud_sync         Trigger iCloud sync on a device.\n   help                Prints the usage for a given subcommand.\n```\n\n对于前端开发人员，需要知道 `xcrun simctl install {SimulatorID} {AppPath}` 这个命令，来给指定的模拟器安装 App。\n\n当然，也需要知道怎么打开模拟器，就是下面的命令。\n\n```\nopen -a \"iOS Simulator\" --args -CurrentDeviceUDID {SimulatorID}\n```\n\n而 `xcrun simctl list` 来显示模拟器的列表来查看ID。\n\n##### Android 模拟器\n\n对于 Google 提供的模拟器，其性能和效率真不敢恭维，连 Android 开发人员都嫌弃。\n\n但是，一个号称最快Android模拟器的应用横空出世，让利用Andoird模拟器调试不是梦，那就是 **Genymotion**。\n\nGenymotion 提供免费版本，其免费的功能，足够前端开发人员用于调试，提供 Mac 和 Windows 版本。（收费功能主要是和IDE的结合、相机等高级功能的模拟等。）\n\nGenymotion 利用 VisualBox 来运行 Android 系统，用电脑的GPU进行渲染，其效率可想而知。\n\n![Genymotion](https://ww4.sinaimg.cn/bmiddle/71c50075gw1ewxb8swnxlj21kw10c7ds.jpg)\n\n如图所示，用户可以下载不同机型的模拟器的，主流的Google、HTC、三星等的机型都被收录，用户可以直接下载使用。\n\n安装应用，其实非常简单，即可以通过 `adb` 命令来安装，也可以直接将 apk安装文件 放到网盘里，在模拟器直接下载安装。\n\n#### 什么样的 App 能装到模拟器里\n\n##### iOS\n\nApp Store 上的和 ipa 包都不能装到模拟器上。那什么包可以装上呢？为模拟器定制的包可以。\n\niOS开发者需要通过 `xrunbuild` 命令来编译 iOS 项目时，加上参数即可。\n\n```\n-destination='platform=iphonesimulator'\n```\n\n用此命令构建出的App，可以安装到模拟器上。\n\n##### Android\n\n只要是 apk 的 App 都可以装到模拟器上。好爽是不是？\n\n#### 其他技巧\n\n* Android 4.4 App 的 WebView 需要调试，需要 Android 开发人员开启调试配置 `WebView.setWebContentsDebuggingEnabled(true); `。\n* Genymotion 的模拟器配置电脑本机代理，ip 为 `10.0.3.2`。\n* 如果在特定版本的Android和Rom上出问题，而 Genymotion 不提供，则必须使用真机调试。\n\n#### 最后\n\n使用模拟器开发，可以让前端开发效率更高，同时，在模拟器上调试过后，在真机上调试时，出现的问题会很少，大幅减少真机使用率，使真机资源有效利用。\n\n这篇文章，主要介绍了模拟器的现状、简单的使用方式等一些比较基础的知识，而更为详细的模拟器使用说明，请期待笔者之后的文章。\n","source":"_posts/2015-10-11-移动Hybrid开发加速器-模拟器.md","raw":"title: 移动Hybrid开发加速器——模拟器\ndate: 2015-10-11\ncategory: 大前端技术\ntags: [Mobile, Debug, Hybrid]\nthumbnailImage: https://ws1.sinaimg.cn/large/006cGJIjly1fizahur9o3j308k04twel.jpg\n---\n\nHybrid App（混合模式移动应用）是指介于Web App、Native App这两者之间的App，兼具『Native App良好用户交互体验的优势』和『Web App跨平台开发的优势』。<!-- more -->\n\n#### 移动 Hybrid 开发遇到的调试问题\n\n随着 Hybrid 思想的推广和其技术的日益成熟，以及 Cordova(PhoneGap)、React Native、Ionic、Titanium 以及我厂的 Hy 这些 Hybrid 形式框架的推出，开发者使用这项技术创建 Hybrid App 的场景越来越多。\n\n与此同时，在开发中遇到的问题也逐渐显现，由于前端代码需要和Native代码进行逻辑上的交互，而且开发人员都是前端工程师，因此『调试异常繁琐』这个问题尤为显著。\n\n对于调试问题，现有的解决方式是:\n\n* 利用 Chrome 开发者工具的设备模拟选项，来模拟移动设备上的浏览器，同时，利用 Chrome 插件来模拟前端与Native的交互。\n* 真机调试，将 App 装到真实的移动设备上，进行调试。\n\n对于，第一种方案 Chrome 插件不可能完全一致的模拟 Native 环境，例如多页面通信、原生应用服务环境等，是非常难以模拟的；\n而第二种方案，需要通过配置 Host、DNS 或者代理将前端资源指向可调试的代码的方式繁琐、iOS可调试App的安装限制及真机设备成本问题，也是不可避免的。\n\n从上面的描述，我们看到调试是十分繁琐的，严重影响开发的效率。\n\n在这里，我将要准备分享一个较为简便的调试方式——利用模拟器。\n\n#### 对模拟器的误解\n\n对于模拟器，前端开发人员甚至Android开发人员都使用甚少，甚至有很多误解。\n\n* 模拟器是Native开发人员用的，前端开发人员使用起来会很难，并不能快速上手。 By 前端开发人员\n* 模拟器太慢，严重影响开发效率。 By Android开发人员\n* 模拟器中的App是Xcode编译出来的，使用的人需要源代码才能把App装到自己电脑上的模拟器上。 By iOS开发人员\n* 等等\n\n这种种问题我认为都是对模拟器的误解，其实模拟器很好用的。\n\n#### 模拟器现状\n\n##### iOS 模拟器\n\n对于 iOS 模拟器，iOS 开发者并不陌生，安装了 Xcode 后，你的 Mac 就会拥有模拟器（最新版本的，指定版本需要自行下载）。\n\niOS 模拟器和真机差别微乎其微，开发者完全在模拟器上完成项目的开发。\n\nXcode 提供了 `xcrun simctl` 命令来控制模拟器。\n\n```\n~ xcrun simctl\nUsage: simctl [--noxpc] [--set <set path>] <subcommand> ... | help [subcommand]\nCommand line utility to control the Simulator\n\nFor subcommands that require a <device> argument, you may specify a device UDID\nor the special \"booted\" string which will cause simctl to pick a booted device.\nIf multiple devices are booted when the \"booted\" device is selected, simctl\nwill choose one of them.\n\nSubcommands:\n   create              Create a new device.\n   delete              Delete a device or all unavailable devices.\n   pair                Create a new watch / phone pair.\n   unpair              Unpair a watch and phone phone.\n   erase               Erase a device's contents and settings.\n   boot                Boot a device.\n   shutdown            Shutdown a device.\n   rename              Rename a device.\n   getenv              Print an environment variable from a running device.\n   openurl             Open a URL in a device.\n   addphoto            Add photos to the photo library of a device.\n   install             Install an app on a device.\n   uninstall           Uninstall an app from a device.\n   get_app_container   Print the path of the intsalled app's container\n   launch              Launch an application by identifier on a device.\n   spawn               Spawn a process on a device.\n   list                List available devices, device types, runtimes, or device pairs.\n   icloud_sync         Trigger iCloud sync on a device.\n   help                Prints the usage for a given subcommand.\n```\n\n对于前端开发人员，需要知道 `xcrun simctl install {SimulatorID} {AppPath}` 这个命令，来给指定的模拟器安装 App。\n\n当然，也需要知道怎么打开模拟器，就是下面的命令。\n\n```\nopen -a \"iOS Simulator\" --args -CurrentDeviceUDID {SimulatorID}\n```\n\n而 `xcrun simctl list` 来显示模拟器的列表来查看ID。\n\n##### Android 模拟器\n\n对于 Google 提供的模拟器，其性能和效率真不敢恭维，连 Android 开发人员都嫌弃。\n\n但是，一个号称最快Android模拟器的应用横空出世，让利用Andoird模拟器调试不是梦，那就是 **Genymotion**。\n\nGenymotion 提供免费版本，其免费的功能，足够前端开发人员用于调试，提供 Mac 和 Windows 版本。（收费功能主要是和IDE的结合、相机等高级功能的模拟等。）\n\nGenymotion 利用 VisualBox 来运行 Android 系统，用电脑的GPU进行渲染，其效率可想而知。\n\n![Genymotion](https://ww4.sinaimg.cn/bmiddle/71c50075gw1ewxb8swnxlj21kw10c7ds.jpg)\n\n如图所示，用户可以下载不同机型的模拟器的，主流的Google、HTC、三星等的机型都被收录，用户可以直接下载使用。\n\n安装应用，其实非常简单，即可以通过 `adb` 命令来安装，也可以直接将 apk安装文件 放到网盘里，在模拟器直接下载安装。\n\n#### 什么样的 App 能装到模拟器里\n\n##### iOS\n\nApp Store 上的和 ipa 包都不能装到模拟器上。那什么包可以装上呢？为模拟器定制的包可以。\n\niOS开发者需要通过 `xrunbuild` 命令来编译 iOS 项目时，加上参数即可。\n\n```\n-destination='platform=iphonesimulator'\n```\n\n用此命令构建出的App，可以安装到模拟器上。\n\n##### Android\n\n只要是 apk 的 App 都可以装到模拟器上。好爽是不是？\n\n#### 其他技巧\n\n* Android 4.4 App 的 WebView 需要调试，需要 Android 开发人员开启调试配置 `WebView.setWebContentsDebuggingEnabled(true); `。\n* Genymotion 的模拟器配置电脑本机代理，ip 为 `10.0.3.2`。\n* 如果在特定版本的Android和Rom上出问题，而 Genymotion 不提供，则必须使用真机调试。\n\n#### 最后\n\n使用模拟器开发，可以让前端开发效率更高，同时，在模拟器上调试过后，在真机上调试时，出现的问题会很少，大幅减少真机使用率，使真机资源有效利用。\n\n这篇文章，主要介绍了模拟器的现状、简单的使用方式等一些比较基础的知识，而更为详细的模拟器使用说明，请期待笔者之后的文章。\n","slug":"2015-10-11-移动Hybrid开发加速器-模拟器","published":1,"updated":"2018-06-25T03:18:28.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc6z0007hxp44ibzu5b5","content":"<p>Hybrid App（混合模式移动应用）是指介于Web App、Native App这两者之间的App，兼具『Native App良好用户交互体验的优势』和『Web App跨平台开发的优势』。<a id=\"more\"></a></p>\n<h4 id=\"移动-Hybrid-开发遇到的调试问题\"><a href=\"#移动-Hybrid-开发遇到的调试问题\" class=\"headerlink\" title=\"移动 Hybrid 开发遇到的调试问题\"></a>移动 Hybrid 开发遇到的调试问题</h4><p>随着 Hybrid 思想的推广和其技术的日益成熟，以及 Cordova(PhoneGap)、React Native、Ionic、Titanium 以及我厂的 Hy 这些 Hybrid 形式框架的推出，开发者使用这项技术创建 Hybrid App 的场景越来越多。</p>\n<p>与此同时，在开发中遇到的问题也逐渐显现，由于前端代码需要和Native代码进行逻辑上的交互，而且开发人员都是前端工程师，因此『调试异常繁琐』这个问题尤为显著。</p>\n<p>对于调试问题，现有的解决方式是:</p>\n<ul>\n<li>利用 Chrome 开发者工具的设备模拟选项，来模拟移动设备上的浏览器，同时，利用 Chrome 插件来模拟前端与Native的交互。</li>\n<li>真机调试，将 App 装到真实的移动设备上，进行调试。</li>\n</ul>\n<p>对于，第一种方案 Chrome 插件不可能完全一致的模拟 Native 环境，例如多页面通信、原生应用服务环境等，是非常难以模拟的；<br>而第二种方案，需要通过配置 Host、DNS 或者代理将前端资源指向可调试的代码的方式繁琐、iOS可调试App的安装限制及真机设备成本问题，也是不可避免的。</p>\n<p>从上面的描述，我们看到调试是十分繁琐的，严重影响开发的效率。</p>\n<p>在这里，我将要准备分享一个较为简便的调试方式——利用模拟器。</p>\n<h4 id=\"对模拟器的误解\"><a href=\"#对模拟器的误解\" class=\"headerlink\" title=\"对模拟器的误解\"></a>对模拟器的误解</h4><p>对于模拟器，前端开发人员甚至Android开发人员都使用甚少，甚至有很多误解。</p>\n<ul>\n<li>模拟器是Native开发人员用的，前端开发人员使用起来会很难，并不能快速上手。 By 前端开发人员</li>\n<li>模拟器太慢，严重影响开发效率。 By Android开发人员</li>\n<li>模拟器中的App是Xcode编译出来的，使用的人需要源代码才能把App装到自己电脑上的模拟器上。 By iOS开发人员</li>\n<li>等等</li>\n</ul>\n<p>这种种问题我认为都是对模拟器的误解，其实模拟器很好用的。</p>\n<h4 id=\"模拟器现状\"><a href=\"#模拟器现状\" class=\"headerlink\" title=\"模拟器现状\"></a>模拟器现状</h4><h5 id=\"iOS-模拟器\"><a href=\"#iOS-模拟器\" class=\"headerlink\" title=\"iOS 模拟器\"></a>iOS 模拟器</h5><p>对于 iOS 模拟器，iOS 开发者并不陌生，安装了 Xcode 后，你的 Mac 就会拥有模拟器（最新版本的，指定版本需要自行下载）。</p>\n<p>iOS 模拟器和真机差别微乎其微，开发者完全在模拟器上完成项目的开发。</p>\n<p>Xcode 提供了 <code>xcrun simctl</code> 命令来控制模拟器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ xcrun simctl</span><br><span class=\"line\">Usage: simctl [--noxpc] [--set &lt;set path&gt;] &lt;subcommand&gt; ... | help [subcommand]</span><br><span class=\"line\">Command line utility to control the Simulator</span><br><span class=\"line\"></span><br><span class=\"line\">For subcommands that require a &lt;device&gt; argument, you may specify a device UDID</span><br><span class=\"line\">or the special &quot;booted&quot; string which will cause simctl to pick a booted device.</span><br><span class=\"line\">If multiple devices are booted when the &quot;booted&quot; device is selected, simctl</span><br><span class=\"line\">will choose one of them.</span><br><span class=\"line\"></span><br><span class=\"line\">Subcommands:</span><br><span class=\"line\">   create              Create a new device.</span><br><span class=\"line\">   delete              Delete a device or all unavailable devices.</span><br><span class=\"line\">   pair                Create a new watch / phone pair.</span><br><span class=\"line\">   unpair              Unpair a watch and phone phone.</span><br><span class=\"line\">   erase               Erase a device&apos;s contents and settings.</span><br><span class=\"line\">   boot                Boot a device.</span><br><span class=\"line\">   shutdown            Shutdown a device.</span><br><span class=\"line\">   rename              Rename a device.</span><br><span class=\"line\">   getenv              Print an environment variable from a running device.</span><br><span class=\"line\">   openurl             Open a URL in a device.</span><br><span class=\"line\">   addphoto            Add photos to the photo library of a device.</span><br><span class=\"line\">   install             Install an app on a device.</span><br><span class=\"line\">   uninstall           Uninstall an app from a device.</span><br><span class=\"line\">   get_app_container   Print the path of the intsalled app&apos;s container</span><br><span class=\"line\">   launch              Launch an application by identifier on a device.</span><br><span class=\"line\">   spawn               Spawn a process on a device.</span><br><span class=\"line\">   list                List available devices, device types, runtimes, or device pairs.</span><br><span class=\"line\">   icloud_sync         Trigger iCloud sync on a device.</span><br><span class=\"line\">   help                Prints the usage for a given subcommand.</span><br></pre></td></tr></table></figure>\n<p>对于前端开发人员，需要知道 <code>xcrun simctl install {SimulatorID} {AppPath}</code> 这个命令，来给指定的模拟器安装 App。</p>\n<p>当然，也需要知道怎么打开模拟器，就是下面的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open -a &quot;iOS Simulator&quot; --args -CurrentDeviceUDID &#123;SimulatorID&#125;</span><br></pre></td></tr></table></figure>\n<p>而 <code>xcrun simctl list</code> 来显示模拟器的列表来查看ID。</p>\n<h5 id=\"Android-模拟器\"><a href=\"#Android-模拟器\" class=\"headerlink\" title=\"Android 模拟器\"></a>Android 模拟器</h5><p>对于 Google 提供的模拟器，其性能和效率真不敢恭维，连 Android 开发人员都嫌弃。</p>\n<p>但是，一个号称最快Android模拟器的应用横空出世，让利用Andoird模拟器调试不是梦，那就是 <strong>Genymotion</strong>。</p>\n<p>Genymotion 提供免费版本，其免费的功能，足够前端开发人员用于调试，提供 Mac 和 Windows 版本。（收费功能主要是和IDE的结合、相机等高级功能的模拟等。）</p>\n<p>Genymotion 利用 VisualBox 来运行 Android 系统，用电脑的GPU进行渲染，其效率可想而知。</p>\n<p><img src=\"https://ww4.sinaimg.cn/bmiddle/71c50075gw1ewxb8swnxlj21kw10c7ds.jpg\" alt=\"Genymotion\"></p>\n<p>如图所示，用户可以下载不同机型的模拟器的，主流的Google、HTC、三星等的机型都被收录，用户可以直接下载使用。</p>\n<p>安装应用，其实非常简单，即可以通过 <code>adb</code> 命令来安装，也可以直接将 apk安装文件 放到网盘里，在模拟器直接下载安装。</p>\n<h4 id=\"什么样的-App-能装到模拟器里\"><a href=\"#什么样的-App-能装到模拟器里\" class=\"headerlink\" title=\"什么样的 App 能装到模拟器里\"></a>什么样的 App 能装到模拟器里</h4><h5 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h5><p>App Store 上的和 ipa 包都不能装到模拟器上。那什么包可以装上呢？为模拟器定制的包可以。</p>\n<p>iOS开发者需要通过 <code>xrunbuild</code> 命令来编译 iOS 项目时，加上参数即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-destination=&apos;platform=iphonesimulator&apos;</span><br></pre></td></tr></table></figure>\n<p>用此命令构建出的App，可以安装到模拟器上。</p>\n<h5 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h5><p>只要是 apk 的 App 都可以装到模拟器上。好爽是不是？</p>\n<h4 id=\"其他技巧\"><a href=\"#其他技巧\" class=\"headerlink\" title=\"其他技巧\"></a>其他技巧</h4><ul>\n<li>Android 4.4 App 的 WebView 需要调试，需要 Android 开发人员开启调试配置 <code>WebView.setWebContentsDebuggingEnabled(true);</code>。</li>\n<li>Genymotion 的模拟器配置电脑本机代理，ip 为 <code>10.0.3.2</code>。</li>\n<li>如果在特定版本的Android和Rom上出问题，而 Genymotion 不提供，则必须使用真机调试。</li>\n</ul>\n<h4 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h4><p>使用模拟器开发，可以让前端开发效率更高，同时，在模拟器上调试过后，在真机上调试时，出现的问题会很少，大幅减少真机使用率，使真机资源有效利用。</p>\n<p>这篇文章，主要介绍了模拟器的现状、简单的使用方式等一些比较基础的知识，而更为详细的模拟器使用说明，请期待笔者之后的文章。</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws1.sinaimg.cn/large/006cGJIjly1fizahur9o3j308k04twel.jpg","excerpt":"<p>Hybrid App（混合模式移动应用）是指介于Web App、Native App这两者之间的App，兼具『Native App良好用户交互体验的优势』和『Web App跨平台开发的优势』。","more":"</p>\n<h4 id=\"移动-Hybrid-开发遇到的调试问题\"><a href=\"#移动-Hybrid-开发遇到的调试问题\" class=\"headerlink\" title=\"移动 Hybrid 开发遇到的调试问题\"></a>移动 Hybrid 开发遇到的调试问题</h4><p>随着 Hybrid 思想的推广和其技术的日益成熟，以及 Cordova(PhoneGap)、React Native、Ionic、Titanium 以及我厂的 Hy 这些 Hybrid 形式框架的推出，开发者使用这项技术创建 Hybrid App 的场景越来越多。</p>\n<p>与此同时，在开发中遇到的问题也逐渐显现，由于前端代码需要和Native代码进行逻辑上的交互，而且开发人员都是前端工程师，因此『调试异常繁琐』这个问题尤为显著。</p>\n<p>对于调试问题，现有的解决方式是:</p>\n<ul>\n<li>利用 Chrome 开发者工具的设备模拟选项，来模拟移动设备上的浏览器，同时，利用 Chrome 插件来模拟前端与Native的交互。</li>\n<li>真机调试，将 App 装到真实的移动设备上，进行调试。</li>\n</ul>\n<p>对于，第一种方案 Chrome 插件不可能完全一致的模拟 Native 环境，例如多页面通信、原生应用服务环境等，是非常难以模拟的；<br>而第二种方案，需要通过配置 Host、DNS 或者代理将前端资源指向可调试的代码的方式繁琐、iOS可调试App的安装限制及真机设备成本问题，也是不可避免的。</p>\n<p>从上面的描述，我们看到调试是十分繁琐的，严重影响开发的效率。</p>\n<p>在这里，我将要准备分享一个较为简便的调试方式——利用模拟器。</p>\n<h4 id=\"对模拟器的误解\"><a href=\"#对模拟器的误解\" class=\"headerlink\" title=\"对模拟器的误解\"></a>对模拟器的误解</h4><p>对于模拟器，前端开发人员甚至Android开发人员都使用甚少，甚至有很多误解。</p>\n<ul>\n<li>模拟器是Native开发人员用的，前端开发人员使用起来会很难，并不能快速上手。 By 前端开发人员</li>\n<li>模拟器太慢，严重影响开发效率。 By Android开发人员</li>\n<li>模拟器中的App是Xcode编译出来的，使用的人需要源代码才能把App装到自己电脑上的模拟器上。 By iOS开发人员</li>\n<li>等等</li>\n</ul>\n<p>这种种问题我认为都是对模拟器的误解，其实模拟器很好用的。</p>\n<h4 id=\"模拟器现状\"><a href=\"#模拟器现状\" class=\"headerlink\" title=\"模拟器现状\"></a>模拟器现状</h4><h5 id=\"iOS-模拟器\"><a href=\"#iOS-模拟器\" class=\"headerlink\" title=\"iOS 模拟器\"></a>iOS 模拟器</h5><p>对于 iOS 模拟器，iOS 开发者并不陌生，安装了 Xcode 后，你的 Mac 就会拥有模拟器（最新版本的，指定版本需要自行下载）。</p>\n<p>iOS 模拟器和真机差别微乎其微，开发者完全在模拟器上完成项目的开发。</p>\n<p>Xcode 提供了 <code>xcrun simctl</code> 命令来控制模拟器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ xcrun simctl</span><br><span class=\"line\">Usage: simctl [--noxpc] [--set &lt;set path&gt;] &lt;subcommand&gt; ... | help [subcommand]</span><br><span class=\"line\">Command line utility to control the Simulator</span><br><span class=\"line\"></span><br><span class=\"line\">For subcommands that require a &lt;device&gt; argument, you may specify a device UDID</span><br><span class=\"line\">or the special &quot;booted&quot; string which will cause simctl to pick a booted device.</span><br><span class=\"line\">If multiple devices are booted when the &quot;booted&quot; device is selected, simctl</span><br><span class=\"line\">will choose one of them.</span><br><span class=\"line\"></span><br><span class=\"line\">Subcommands:</span><br><span class=\"line\">   create              Create a new device.</span><br><span class=\"line\">   delete              Delete a device or all unavailable devices.</span><br><span class=\"line\">   pair                Create a new watch / phone pair.</span><br><span class=\"line\">   unpair              Unpair a watch and phone phone.</span><br><span class=\"line\">   erase               Erase a device&apos;s contents and settings.</span><br><span class=\"line\">   boot                Boot a device.</span><br><span class=\"line\">   shutdown            Shutdown a device.</span><br><span class=\"line\">   rename              Rename a device.</span><br><span class=\"line\">   getenv              Print an environment variable from a running device.</span><br><span class=\"line\">   openurl             Open a URL in a device.</span><br><span class=\"line\">   addphoto            Add photos to the photo library of a device.</span><br><span class=\"line\">   install             Install an app on a device.</span><br><span class=\"line\">   uninstall           Uninstall an app from a device.</span><br><span class=\"line\">   get_app_container   Print the path of the intsalled app&apos;s container</span><br><span class=\"line\">   launch              Launch an application by identifier on a device.</span><br><span class=\"line\">   spawn               Spawn a process on a device.</span><br><span class=\"line\">   list                List available devices, device types, runtimes, or device pairs.</span><br><span class=\"line\">   icloud_sync         Trigger iCloud sync on a device.</span><br><span class=\"line\">   help                Prints the usage for a given subcommand.</span><br></pre></td></tr></table></figure>\n<p>对于前端开发人员，需要知道 <code>xcrun simctl install {SimulatorID} {AppPath}</code> 这个命令，来给指定的模拟器安装 App。</p>\n<p>当然，也需要知道怎么打开模拟器，就是下面的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open -a &quot;iOS Simulator&quot; --args -CurrentDeviceUDID &#123;SimulatorID&#125;</span><br></pre></td></tr></table></figure>\n<p>而 <code>xcrun simctl list</code> 来显示模拟器的列表来查看ID。</p>\n<h5 id=\"Android-模拟器\"><a href=\"#Android-模拟器\" class=\"headerlink\" title=\"Android 模拟器\"></a>Android 模拟器</h5><p>对于 Google 提供的模拟器，其性能和效率真不敢恭维，连 Android 开发人员都嫌弃。</p>\n<p>但是，一个号称最快Android模拟器的应用横空出世，让利用Andoird模拟器调试不是梦，那就是 <strong>Genymotion</strong>。</p>\n<p>Genymotion 提供免费版本，其免费的功能，足够前端开发人员用于调试，提供 Mac 和 Windows 版本。（收费功能主要是和IDE的结合、相机等高级功能的模拟等。）</p>\n<p>Genymotion 利用 VisualBox 来运行 Android 系统，用电脑的GPU进行渲染，其效率可想而知。</p>\n<p><img src=\"https://ww4.sinaimg.cn/bmiddle/71c50075gw1ewxb8swnxlj21kw10c7ds.jpg\" alt=\"Genymotion\"></p>\n<p>如图所示，用户可以下载不同机型的模拟器的，主流的Google、HTC、三星等的机型都被收录，用户可以直接下载使用。</p>\n<p>安装应用，其实非常简单，即可以通过 <code>adb</code> 命令来安装，也可以直接将 apk安装文件 放到网盘里，在模拟器直接下载安装。</p>\n<h4 id=\"什么样的-App-能装到模拟器里\"><a href=\"#什么样的-App-能装到模拟器里\" class=\"headerlink\" title=\"什么样的 App 能装到模拟器里\"></a>什么样的 App 能装到模拟器里</h4><h5 id=\"iOS\"><a href=\"#iOS\" class=\"headerlink\" title=\"iOS\"></a>iOS</h5><p>App Store 上的和 ipa 包都不能装到模拟器上。那什么包可以装上呢？为模拟器定制的包可以。</p>\n<p>iOS开发者需要通过 <code>xrunbuild</code> 命令来编译 iOS 项目时，加上参数即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-destination=&apos;platform=iphonesimulator&apos;</span><br></pre></td></tr></table></figure>\n<p>用此命令构建出的App，可以安装到模拟器上。</p>\n<h5 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h5><p>只要是 apk 的 App 都可以装到模拟器上。好爽是不是？</p>\n<h4 id=\"其他技巧\"><a href=\"#其他技巧\" class=\"headerlink\" title=\"其他技巧\"></a>其他技巧</h4><ul>\n<li>Android 4.4 App 的 WebView 需要调试，需要 Android 开发人员开启调试配置 <code>WebView.setWebContentsDebuggingEnabled(true);</code>。</li>\n<li>Genymotion 的模拟器配置电脑本机代理，ip 为 <code>10.0.3.2</code>。</li>\n<li>如果在特定版本的Android和Rom上出问题，而 Genymotion 不提供，则必须使用真机调试。</li>\n</ul>\n<h4 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h4><p>使用模拟器开发，可以让前端开发效率更高，同时，在模拟器上调试过后，在真机上调试时，出现的问题会很少，大幅减少真机使用率，使真机资源有效利用。</p>\n<p>这篇文章，主要介绍了模拟器的现状、简单的使用方式等一些比较基础的知识，而更为详细的模拟器使用说明，请期待笔者之后的文章。</p>"},{"title":"2015阿里巴巴D2前端论坛-参会总结","date":"2015-12-20T16:00:00.000Z","thumbnailImage":"https://ws1.sinaimg.cn/large/006cGJIjly1fizh2ar55tj30dc07ot95.jpg","thumbnailImagePosition":"left","_content":"\n去杭州参加了，阿里巴巴第10届D2前端论坛，主题是『融合』，可以说受益匪浅。上一次D2，笔者是从自身技术的角度去听了分享，而此次，却是从团队技术方向和解决方案的角度去听，不同的角度有不同的收获。<!-- more -->\n\n对于论坛的主线，大概分成三个方向：\n\n1. 首当其冲的当然是现在最火的多端一体化方案，像Hybrid，React Native都是此类，同时也是众说纷纭的一类。\n\n2. 另外，则是 Node 在大型项目中的应用的问题，包括多并发处理、性能优化以及其他一些在实战中的经验。\n\n3. 最后，是一些新框架、工具的东西，像数据可视化的DataV，像接口管理的RAP，都是一些不错的东西，也有很多可用的场景。\n\n### React Native 以及 Hybrid 的发展前景\n\n说到这里，不得不提到老生常谈的『 Native vs Web 』的话题。其实，也就是 **Native 的用户体验** 与 **Web 的开发体验** 间的博弈。此时，React Native 横空出世，倍受关注。为什么呢？原因有以下几点：\n\n1. Native API - 用户体验\n2. 编程语言能力 JS Core & 不用编译 - 开发体验\n3. 布局和样式能力 - 开发体验\n4. 声明式编程（组件化）- 开发体验\n5. 开源&社区 - 开发体验\n\n从这五点来看，React Native 非常注重开发者的体验，这也是 React Native 火遍全球的原因之一。\n\n![React Native](https://ws1.sinaimg.cn/large/006cGJIjly1fizh2ar55tj30dc07ot95.jpg)\n\n但，从业务需求上看 **使用 React Native 成本还是比较高的**。一方面，业务的学习迁移成本还是比较高的；另一方面，iOS和Android两个平台分别开发，代码复用率只有 85% 左右，而且对 Touch 平台的兼容也并不是太好（来自阿里手淘团队的分享）。\n\n而另一位来自淘宝的 @元彦 分享了基于 React Native 的适配 iOS、Android、Touch 三平台的框架 Portal，并计划本月底开源，具体细节还没公布（地址为：[https://github.com/taobaofed/react-web](https://github.com/taobaofed/react-web)）。对于Portal，有同仁总结其最大的特点是 **衣帽间业务层代码在无线 Web 和 Native 双平台上实现了 100% 复用率。**（Portal 提供了 React-Web 部分，来适配 Touch 端的展现。） 这套架构的核心是Generator，**发布时代码通过Generator进行打包，分发到各个平台**。具体细节还没有放出，等开源之后可以详细研究其代码结构。最后，这套框架暂时没有使用在阿里核心的业务上，这种方案是否有效，还有待考证。\n\n至此，可以对 React Native 做个简单的总结：**对于原有业务，迁移到React Native 的成本还是比较高的；对于新业务，多端平台代码复用的问题有待考证。**\n\n这里，提一个笔者对 React Native 的疑问：当 Native 原生开发解决开发体验问题或者 Web 开发解决用户体验问题（主要是低端Android）后，React Native 将如何定位？\n\n或许，Native 原生开发解决开发体验问题很难，但是 Web 解决用户体验问题并不困难，至少现在在 iOS 上，Web 的体验可以做得相当好。而一些大数据渲染导致浏览器内存泄露至崩溃的问题，用 React Native 和用原生 Native 做的区别和成本又相差多少呢？很多人和笔者有同样的疑惑，但是并没有很明确的答案。提升 Web 端的性能看似是厂商直接提升硬件和系统般简单，而且 Webkit 也几乎统一了移动端浏览器内核，但是进展究竟如何，并没有很好地预期。\n\n回到分享，手淘分享了他们的方案，他们的方案是 **将Native覆盖在WebView上**，提供 TableView、TabBar、Slider、SideBar四个Native组件，通过引擎将模板渲染成Native和Webview混合的UI，比较固定或者高性能的部分用native，动态内容用web，一起拼装。\n\n![手淘的整体架构（盗自 @yuanyuan 的知乎）](https://ww2.sinaimg.cn/large/71c50075gw1ez9pokagezj218a0gcwi3.jpg)\n\n刚好，另一个会场分享 Baidu 的同学分享 Clouda+ 的 [Blend UI](https://clouda.baidu.com/blendui/introduction/introduction)，和手淘的方案很类似，下面是 Blend UI 的特征：\n\n* 多Webview控制能力。让一个Webapp拆到多个webview中运行，并能用Javascript来调度，解决了页面过大导致卡顿的问题，同时，webview的转场动画由Native代码实现，也解决了转场动画不流畅的问题。\n\n* Native组件嵌入能力。能将Native控件嵌入Webview中，这样就能让页面中那些性能较差的部分用Native来实现，以最大化地提高体验和交互。\n\n![Blend UI](https://ww2.sinaimg.cn/large/71c50075gw1ez9ptmyqmcj210b0l7dhu.jpg)\n\n当然这种方案也有一些问题，例如 Native 和 WebView 的滚动不同步，考虑限制 Native 大部分为 Fixed，对业务限制比较大等等。\n\n其实，类似于国内也有类似 React Native 的项目，GeeZooStudio （用过 BeeFramework 的 iOS 开发者应该知道）的创始人分享了他们实现的 NativeUI 框架，自己实现了引擎，来解析 JS 并用 Native 渲染 UI，预计半年内发布和开源。\n\n今年 D2 上，React Native 被受关注（PS：蚂蚁金融和Strikingly的分享是React 不是 React Native），但是成果并不是很多，毕竟离 React Native 的 Android 版本开源，刚刚三个月的时间，并不被以应用到很多大型项目中。\n\n下面，总结一下笔者在听完D2分享后，对 React Native 和 Hybrid 的一些看法和想法：\n\n* React Native 是值得学习和使用的，但是大公司主要业务项目的实践还不是很多。老业务迁移成本大，新业务可以尝试，鉴于 React Native 迭代速度比较快，核心框架还不是非常稳定，坑较多，所以要走的路还很长。\n* WebView Hybrid 方案，在厂商浏览器性能提升之前，怎么达到 Native 的交互体验仍是比较严重的问题。为此手淘和百度（已经用于百度贴吧）给出的解决方案，是融合 Native 和 WebView，但是这样的 JS 和 Native 交互会很多，多 WebView 通信的问题需要接解决。\n* 刚才说到，React Native 迭代比较快，核心框架还不稳定，因此，如果在稳定之前采用 React Native，那么 **React Native 框架更新** 将是一个问题。同样的，WebView HyBrid 方案也存在缓存离线问题，包括手淘、蚂蚁金服和QZone，都使用 **推拉结合** 的方式，让离线资源尽快更新。\n\n最后，耳闻阿里自己搞了一个Weex框架，是 @勾股 带头搞的，类似于 React Native 框架的东西，但是更轻量，像是 Vue-Native (vue.js @尤小右)。具体的介绍，可以看 [如何看待阿里无线前端发布的Weex?](https://www.zhihu.com/question/37636296)。 @winter 的回答，说明了开源计划和为什么放弃RN。（PS：话说，这个框架好像主要针对于电商场景）\n\n### NodeJS 在大型场景中的应用和性能优化\n\nNodeJS，从前几年只被看好，到现在已经应用到类似大型业务项目中，竞争力逐渐显现。用 NodeJS 要比 Spring 好？比 PHP 快？这些都是相对于言的。NodeJS 已经用在了 **天猫** 和 **Qzone** 两个大型项目中，这足可以证明 NodeJS 的能力。\n\n![吸引眼球的NodeJS](https://www.html5china.com/uploads/allimg/111218/161PC4H-1.png)\n\n@不四 讲了天猫的 NodeJS 方案，而腾讯的同学讲了 QZone 的方案。其实大同小异，主要的内容就几项：\n\n* 怎么处理高并发？\n* 怎么记录日志并快速还原场景？\n* 怎么友好地退出子进程？\n* 怎么做业务分层？\n* 怎么设计中间件？\n* ......\n\n其中，@不四 还分享了使用 Cluster 时的一些经验，例如，Master 只做进程管理，Worker 异常退出后自动重启逻辑使用的模块 cfork，Http 服务优雅退出的模块 graceful 等等。\n\n在其他会场，@朴灵 还分享了 AliNode 和 NodeJS 的性能优化经验，具体细节不再说了，涉及到更改 NodeJS 源码。同时，**问题调试和定位** 作为 NodeJS 服务器端最大痛点的一些处理经验。\n\n最后，其实回到一个问题，为什么用NodeJS？其实大部分答案是 **因为前端所以Node**， NodeJs 驱动的移动端的 H5 开发效率有很大优势，做接口合并、转发等逻辑，大大减小沟通成本。\n\nPS：使用 NodeJS 的原因其实是笔者脑洞的。其实他们选择用 NodeJS 的原因不仅仅为此，更多应该是业务场景的原因。以后需要前端同学更努力，才能使 NodeJS 更广泛的使用。\n\n\n### 工具\n\n关于工具，笔者关注了一下 Web接口管理工具RAP，一个阿里系的接口管理工具。\n\n![图](https://ww4.sinaimg.cn/large/71c50075gw1ez9pw2fk7sj20xy0hy0w1.jpg)\n\n有兴趣的同学可以关注下，简单看了一下，功能非常全，对于电商场景比较适用。\n\n* Github地址: [https://github.com/thx/RAP](https://github.com/thx/RAP)\n\n笔者准备深入研究，构建一个适用于我司业务的Web接口管理工具。\n\n### 其他\n\n之前对 React JS 研究得并不深，所以分享只是大概了解下。\n\n而炫酷阿里的 DataV 数据可视化，可以参见 [视频](https://video.weibo.com/show?fid=1034:fd0a5bc90c7a677e5e70804e2512be33&ep=D99bMDl8y%2C2827596505%2CD99bMDl8y%2C2827596505)，这里也不多说了。\n\n### 总结\n\n今年的D2，主题是融合，火的是多端一体化开发。引用两句话做总结：(非原话，含义相似)\n\n* @玄难：十年前写的Java代码现在还能用，十年前写的JS代码现在绝对用不了\n* @打饭时碰到的路人甲：现在的前端团队不懂Native，是活不下去的（PS：只是意会，不是绝对）\n\n期待明年的D2。更多 D2 的内容，可以参看 [参加第十届D2前端技术论坛，你有什么收获？](https://www.zhihu.com/question/38637676) 中的答案。\n","source":"_posts/2015-12-21-2015阿里巴巴D2前端论坛-参会总结.md","raw":"title: 2015阿里巴巴D2前端论坛-参会总结\ndate: 2015-12-21\ncategory: 随笔\ntags: [Mobile, D2]\nthumbnailImage: https://ws1.sinaimg.cn/large/006cGJIjly1fizh2ar55tj30dc07ot95.jpg\nthumbnailImagePosition: left\n---\n\n去杭州参加了，阿里巴巴第10届D2前端论坛，主题是『融合』，可以说受益匪浅。上一次D2，笔者是从自身技术的角度去听了分享，而此次，却是从团队技术方向和解决方案的角度去听，不同的角度有不同的收获。<!-- more -->\n\n对于论坛的主线，大概分成三个方向：\n\n1. 首当其冲的当然是现在最火的多端一体化方案，像Hybrid，React Native都是此类，同时也是众说纷纭的一类。\n\n2. 另外，则是 Node 在大型项目中的应用的问题，包括多并发处理、性能优化以及其他一些在实战中的经验。\n\n3. 最后，是一些新框架、工具的东西，像数据可视化的DataV，像接口管理的RAP，都是一些不错的东西，也有很多可用的场景。\n\n### React Native 以及 Hybrid 的发展前景\n\n说到这里，不得不提到老生常谈的『 Native vs Web 』的话题。其实，也就是 **Native 的用户体验** 与 **Web 的开发体验** 间的博弈。此时，React Native 横空出世，倍受关注。为什么呢？原因有以下几点：\n\n1. Native API - 用户体验\n2. 编程语言能力 JS Core & 不用编译 - 开发体验\n3. 布局和样式能力 - 开发体验\n4. 声明式编程（组件化）- 开发体验\n5. 开源&社区 - 开发体验\n\n从这五点来看，React Native 非常注重开发者的体验，这也是 React Native 火遍全球的原因之一。\n\n![React Native](https://ws1.sinaimg.cn/large/006cGJIjly1fizh2ar55tj30dc07ot95.jpg)\n\n但，从业务需求上看 **使用 React Native 成本还是比较高的**。一方面，业务的学习迁移成本还是比较高的；另一方面，iOS和Android两个平台分别开发，代码复用率只有 85% 左右，而且对 Touch 平台的兼容也并不是太好（来自阿里手淘团队的分享）。\n\n而另一位来自淘宝的 @元彦 分享了基于 React Native 的适配 iOS、Android、Touch 三平台的框架 Portal，并计划本月底开源，具体细节还没公布（地址为：[https://github.com/taobaofed/react-web](https://github.com/taobaofed/react-web)）。对于Portal，有同仁总结其最大的特点是 **衣帽间业务层代码在无线 Web 和 Native 双平台上实现了 100% 复用率。**（Portal 提供了 React-Web 部分，来适配 Touch 端的展现。） 这套架构的核心是Generator，**发布时代码通过Generator进行打包，分发到各个平台**。具体细节还没有放出，等开源之后可以详细研究其代码结构。最后，这套框架暂时没有使用在阿里核心的业务上，这种方案是否有效，还有待考证。\n\n至此，可以对 React Native 做个简单的总结：**对于原有业务，迁移到React Native 的成本还是比较高的；对于新业务，多端平台代码复用的问题有待考证。**\n\n这里，提一个笔者对 React Native 的疑问：当 Native 原生开发解决开发体验问题或者 Web 开发解决用户体验问题（主要是低端Android）后，React Native 将如何定位？\n\n或许，Native 原生开发解决开发体验问题很难，但是 Web 解决用户体验问题并不困难，至少现在在 iOS 上，Web 的体验可以做得相当好。而一些大数据渲染导致浏览器内存泄露至崩溃的问题，用 React Native 和用原生 Native 做的区别和成本又相差多少呢？很多人和笔者有同样的疑惑，但是并没有很明确的答案。提升 Web 端的性能看似是厂商直接提升硬件和系统般简单，而且 Webkit 也几乎统一了移动端浏览器内核，但是进展究竟如何，并没有很好地预期。\n\n回到分享，手淘分享了他们的方案，他们的方案是 **将Native覆盖在WebView上**，提供 TableView、TabBar、Slider、SideBar四个Native组件，通过引擎将模板渲染成Native和Webview混合的UI，比较固定或者高性能的部分用native，动态内容用web，一起拼装。\n\n![手淘的整体架构（盗自 @yuanyuan 的知乎）](https://ww2.sinaimg.cn/large/71c50075gw1ez9pokagezj218a0gcwi3.jpg)\n\n刚好，另一个会场分享 Baidu 的同学分享 Clouda+ 的 [Blend UI](https://clouda.baidu.com/blendui/introduction/introduction)，和手淘的方案很类似，下面是 Blend UI 的特征：\n\n* 多Webview控制能力。让一个Webapp拆到多个webview中运行，并能用Javascript来调度，解决了页面过大导致卡顿的问题，同时，webview的转场动画由Native代码实现，也解决了转场动画不流畅的问题。\n\n* Native组件嵌入能力。能将Native控件嵌入Webview中，这样就能让页面中那些性能较差的部分用Native来实现，以最大化地提高体验和交互。\n\n![Blend UI](https://ww2.sinaimg.cn/large/71c50075gw1ez9ptmyqmcj210b0l7dhu.jpg)\n\n当然这种方案也有一些问题，例如 Native 和 WebView 的滚动不同步，考虑限制 Native 大部分为 Fixed，对业务限制比较大等等。\n\n其实，类似于国内也有类似 React Native 的项目，GeeZooStudio （用过 BeeFramework 的 iOS 开发者应该知道）的创始人分享了他们实现的 NativeUI 框架，自己实现了引擎，来解析 JS 并用 Native 渲染 UI，预计半年内发布和开源。\n\n今年 D2 上，React Native 被受关注（PS：蚂蚁金融和Strikingly的分享是React 不是 React Native），但是成果并不是很多，毕竟离 React Native 的 Android 版本开源，刚刚三个月的时间，并不被以应用到很多大型项目中。\n\n下面，总结一下笔者在听完D2分享后，对 React Native 和 Hybrid 的一些看法和想法：\n\n* React Native 是值得学习和使用的，但是大公司主要业务项目的实践还不是很多。老业务迁移成本大，新业务可以尝试，鉴于 React Native 迭代速度比较快，核心框架还不是非常稳定，坑较多，所以要走的路还很长。\n* WebView Hybrid 方案，在厂商浏览器性能提升之前，怎么达到 Native 的交互体验仍是比较严重的问题。为此手淘和百度（已经用于百度贴吧）给出的解决方案，是融合 Native 和 WebView，但是这样的 JS 和 Native 交互会很多，多 WebView 通信的问题需要接解决。\n* 刚才说到，React Native 迭代比较快，核心框架还不稳定，因此，如果在稳定之前采用 React Native，那么 **React Native 框架更新** 将是一个问题。同样的，WebView HyBrid 方案也存在缓存离线问题，包括手淘、蚂蚁金服和QZone，都使用 **推拉结合** 的方式，让离线资源尽快更新。\n\n最后，耳闻阿里自己搞了一个Weex框架，是 @勾股 带头搞的，类似于 React Native 框架的东西，但是更轻量，像是 Vue-Native (vue.js @尤小右)。具体的介绍，可以看 [如何看待阿里无线前端发布的Weex?](https://www.zhihu.com/question/37636296)。 @winter 的回答，说明了开源计划和为什么放弃RN。（PS：话说，这个框架好像主要针对于电商场景）\n\n### NodeJS 在大型场景中的应用和性能优化\n\nNodeJS，从前几年只被看好，到现在已经应用到类似大型业务项目中，竞争力逐渐显现。用 NodeJS 要比 Spring 好？比 PHP 快？这些都是相对于言的。NodeJS 已经用在了 **天猫** 和 **Qzone** 两个大型项目中，这足可以证明 NodeJS 的能力。\n\n![吸引眼球的NodeJS](https://www.html5china.com/uploads/allimg/111218/161PC4H-1.png)\n\n@不四 讲了天猫的 NodeJS 方案，而腾讯的同学讲了 QZone 的方案。其实大同小异，主要的内容就几项：\n\n* 怎么处理高并发？\n* 怎么记录日志并快速还原场景？\n* 怎么友好地退出子进程？\n* 怎么做业务分层？\n* 怎么设计中间件？\n* ......\n\n其中，@不四 还分享了使用 Cluster 时的一些经验，例如，Master 只做进程管理，Worker 异常退出后自动重启逻辑使用的模块 cfork，Http 服务优雅退出的模块 graceful 等等。\n\n在其他会场，@朴灵 还分享了 AliNode 和 NodeJS 的性能优化经验，具体细节不再说了，涉及到更改 NodeJS 源码。同时，**问题调试和定位** 作为 NodeJS 服务器端最大痛点的一些处理经验。\n\n最后，其实回到一个问题，为什么用NodeJS？其实大部分答案是 **因为前端所以Node**， NodeJs 驱动的移动端的 H5 开发效率有很大优势，做接口合并、转发等逻辑，大大减小沟通成本。\n\nPS：使用 NodeJS 的原因其实是笔者脑洞的。其实他们选择用 NodeJS 的原因不仅仅为此，更多应该是业务场景的原因。以后需要前端同学更努力，才能使 NodeJS 更广泛的使用。\n\n\n### 工具\n\n关于工具，笔者关注了一下 Web接口管理工具RAP，一个阿里系的接口管理工具。\n\n![图](https://ww4.sinaimg.cn/large/71c50075gw1ez9pw2fk7sj20xy0hy0w1.jpg)\n\n有兴趣的同学可以关注下，简单看了一下，功能非常全，对于电商场景比较适用。\n\n* Github地址: [https://github.com/thx/RAP](https://github.com/thx/RAP)\n\n笔者准备深入研究，构建一个适用于我司业务的Web接口管理工具。\n\n### 其他\n\n之前对 React JS 研究得并不深，所以分享只是大概了解下。\n\n而炫酷阿里的 DataV 数据可视化，可以参见 [视频](https://video.weibo.com/show?fid=1034:fd0a5bc90c7a677e5e70804e2512be33&ep=D99bMDl8y%2C2827596505%2CD99bMDl8y%2C2827596505)，这里也不多说了。\n\n### 总结\n\n今年的D2，主题是融合，火的是多端一体化开发。引用两句话做总结：(非原话，含义相似)\n\n* @玄难：十年前写的Java代码现在还能用，十年前写的JS代码现在绝对用不了\n* @打饭时碰到的路人甲：现在的前端团队不懂Native，是活不下去的（PS：只是意会，不是绝对）\n\n期待明年的D2。更多 D2 的内容，可以参看 [参加第十届D2前端技术论坛，你有什么收获？](https://www.zhihu.com/question/38637676) 中的答案。\n","slug":"2015-12-21-2015阿里巴巴D2前端论坛-参会总结","published":1,"updated":"2018-06-25T03:18:28.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc700009hxp4i5sf1c9w","content":"<p>去杭州参加了，阿里巴巴第10届D2前端论坛，主题是『融合』，可以说受益匪浅。上一次D2，笔者是从自身技术的角度去听了分享，而此次，却是从团队技术方向和解决方案的角度去听，不同的角度有不同的收获。<a id=\"more\"></a></p>\n<p>对于论坛的主线，大概分成三个方向：</p>\n<ol>\n<li><p>首当其冲的当然是现在最火的多端一体化方案，像Hybrid，React Native都是此类，同时也是众说纷纭的一类。</p>\n</li>\n<li><p>另外，则是 Node 在大型项目中的应用的问题，包括多并发处理、性能优化以及其他一些在实战中的经验。</p>\n</li>\n<li><p>最后，是一些新框架、工具的东西，像数据可视化的DataV，像接口管理的RAP，都是一些不错的东西，也有很多可用的场景。</p>\n</li>\n</ol>\n<h3 id=\"React-Native-以及-Hybrid-的发展前景\"><a href=\"#React-Native-以及-Hybrid-的发展前景\" class=\"headerlink\" title=\"React Native 以及 Hybrid 的发展前景\"></a>React Native 以及 Hybrid 的发展前景</h3><p>说到这里，不得不提到老生常谈的『 Native vs Web 』的话题。其实，也就是 <strong>Native 的用户体验</strong> 与 <strong>Web 的开发体验</strong> 间的博弈。此时，React Native 横空出世，倍受关注。为什么呢？原因有以下几点：</p>\n<ol>\n<li>Native API - 用户体验</li>\n<li>编程语言能力 JS Core &amp; 不用编译 - 开发体验</li>\n<li>布局和样式能力 - 开发体验</li>\n<li>声明式编程（组件化）- 开发体验</li>\n<li>开源&amp;社区 - 开发体验</li>\n</ol>\n<p>从这五点来看，React Native 非常注重开发者的体验，这也是 React Native 火遍全球的原因之一。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006cGJIjly1fizh2ar55tj30dc07ot95.jpg\" alt=\"React Native\"></p>\n<p>但，从业务需求上看 <strong>使用 React Native 成本还是比较高的</strong>。一方面，业务的学习迁移成本还是比较高的；另一方面，iOS和Android两个平台分别开发，代码复用率只有 85% 左右，而且对 Touch 平台的兼容也并不是太好（来自阿里手淘团队的分享）。</p>\n<p>而另一位来自淘宝的 @元彦 分享了基于 React Native 的适配 iOS、Android、Touch 三平台的框架 Portal，并计划本月底开源，具体细节还没公布（地址为：<a href=\"https://github.com/taobaofed/react-web\" target=\"_blank\" rel=\"noopener\">https://github.com/taobaofed/react-web</a>）。对于Portal，有同仁总结其最大的特点是 <strong>衣帽间业务层代码在无线 Web 和 Native 双平台上实现了 100% 复用率。</strong>（Portal 提供了 React-Web 部分，来适配 Touch 端的展现。） 这套架构的核心是Generator，<strong>发布时代码通过Generator进行打包，分发到各个平台</strong>。具体细节还没有放出，等开源之后可以详细研究其代码结构。最后，这套框架暂时没有使用在阿里核心的业务上，这种方案是否有效，还有待考证。</p>\n<p>至此，可以对 React Native 做个简单的总结：<strong>对于原有业务，迁移到React Native 的成本还是比较高的；对于新业务，多端平台代码复用的问题有待考证。</strong></p>\n<p>这里，提一个笔者对 React Native 的疑问：当 Native 原生开发解决开发体验问题或者 Web 开发解决用户体验问题（主要是低端Android）后，React Native 将如何定位？</p>\n<p>或许，Native 原生开发解决开发体验问题很难，但是 Web 解决用户体验问题并不困难，至少现在在 iOS 上，Web 的体验可以做得相当好。而一些大数据渲染导致浏览器内存泄露至崩溃的问题，用 React Native 和用原生 Native 做的区别和成本又相差多少呢？很多人和笔者有同样的疑惑，但是并没有很明确的答案。提升 Web 端的性能看似是厂商直接提升硬件和系统般简单，而且 Webkit 也几乎统一了移动端浏览器内核，但是进展究竟如何，并没有很好地预期。</p>\n<p>回到分享，手淘分享了他们的方案，他们的方案是 <strong>将Native覆盖在WebView上</strong>，提供 TableView、TabBar、Slider、SideBar四个Native组件，通过引擎将模板渲染成Native和Webview混合的UI，比较固定或者高性能的部分用native，动态内容用web，一起拼装。</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075gw1ez9pokagezj218a0gcwi3.jpg\" alt=\"手淘的整体架构（盗自 @yuanyuan 的知乎）\"></p>\n<p>刚好，另一个会场分享 Baidu 的同学分享 Clouda+ 的 <a href=\"https://clouda.baidu.com/blendui/introduction/introduction\" target=\"_blank\" rel=\"noopener\">Blend UI</a>，和手淘的方案很类似，下面是 Blend UI 的特征：</p>\n<ul>\n<li><p>多Webview控制能力。让一个Webapp拆到多个webview中运行，并能用Javascript来调度，解决了页面过大导致卡顿的问题，同时，webview的转场动画由Native代码实现，也解决了转场动画不流畅的问题。</p>\n</li>\n<li><p>Native组件嵌入能力。能将Native控件嵌入Webview中，这样就能让页面中那些性能较差的部分用Native来实现，以最大化地提高体验和交互。</p>\n</li>\n</ul>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075gw1ez9ptmyqmcj210b0l7dhu.jpg\" alt=\"Blend UI\"></p>\n<p>当然这种方案也有一些问题，例如 Native 和 WebView 的滚动不同步，考虑限制 Native 大部分为 Fixed，对业务限制比较大等等。</p>\n<p>其实，类似于国内也有类似 React Native 的项目，GeeZooStudio （用过 BeeFramework 的 iOS 开发者应该知道）的创始人分享了他们实现的 NativeUI 框架，自己实现了引擎，来解析 JS 并用 Native 渲染 UI，预计半年内发布和开源。</p>\n<p>今年 D2 上，React Native 被受关注（PS：蚂蚁金融和Strikingly的分享是React 不是 React Native），但是成果并不是很多，毕竟离 React Native 的 Android 版本开源，刚刚三个月的时间，并不被以应用到很多大型项目中。</p>\n<p>下面，总结一下笔者在听完D2分享后，对 React Native 和 Hybrid 的一些看法和想法：</p>\n<ul>\n<li>React Native 是值得学习和使用的，但是大公司主要业务项目的实践还不是很多。老业务迁移成本大，新业务可以尝试，鉴于 React Native 迭代速度比较快，核心框架还不是非常稳定，坑较多，所以要走的路还很长。</li>\n<li>WebView Hybrid 方案，在厂商浏览器性能提升之前，怎么达到 Native 的交互体验仍是比较严重的问题。为此手淘和百度（已经用于百度贴吧）给出的解决方案，是融合 Native 和 WebView，但是这样的 JS 和 Native 交互会很多，多 WebView 通信的问题需要接解决。</li>\n<li>刚才说到，React Native 迭代比较快，核心框架还不稳定，因此，如果在稳定之前采用 React Native，那么 <strong>React Native 框架更新</strong> 将是一个问题。同样的，WebView HyBrid 方案也存在缓存离线问题，包括手淘、蚂蚁金服和QZone，都使用 <strong>推拉结合</strong> 的方式，让离线资源尽快更新。</li>\n</ul>\n<p>最后，耳闻阿里自己搞了一个Weex框架，是 @勾股 带头搞的，类似于 React Native 框架的东西，但是更轻量，像是 Vue-Native (vue.js @尤小右)。具体的介绍，可以看 <a href=\"https://www.zhihu.com/question/37636296\" target=\"_blank\" rel=\"noopener\">如何看待阿里无线前端发布的Weex?</a>。 @winter 的回答，说明了开源计划和为什么放弃RN。（PS：话说，这个框架好像主要针对于电商场景）</p>\n<h3 id=\"NodeJS-在大型场景中的应用和性能优化\"><a href=\"#NodeJS-在大型场景中的应用和性能优化\" class=\"headerlink\" title=\"NodeJS 在大型场景中的应用和性能优化\"></a>NodeJS 在大型场景中的应用和性能优化</h3><p>NodeJS，从前几年只被看好，到现在已经应用到类似大型业务项目中，竞争力逐渐显现。用 NodeJS 要比 Spring 好？比 PHP 快？这些都是相对于言的。NodeJS 已经用在了 <strong>天猫</strong> 和 <strong>Qzone</strong> 两个大型项目中，这足可以证明 NodeJS 的能力。</p>\n<p><img src=\"https://www.html5china.com/uploads/allimg/111218/161PC4H-1.png\" alt=\"吸引眼球的NodeJS\"></p>\n<p>@不四 讲了天猫的 NodeJS 方案，而腾讯的同学讲了 QZone 的方案。其实大同小异，主要的内容就几项：</p>\n<ul>\n<li>怎么处理高并发？</li>\n<li>怎么记录日志并快速还原场景？</li>\n<li>怎么友好地退出子进程？</li>\n<li>怎么做业务分层？</li>\n<li>怎么设计中间件？</li>\n<li>……</li>\n</ul>\n<p>其中，@不四 还分享了使用 Cluster 时的一些经验，例如，Master 只做进程管理，Worker 异常退出后自动重启逻辑使用的模块 cfork，Http 服务优雅退出的模块 graceful 等等。</p>\n<p>在其他会场，@朴灵 还分享了 AliNode 和 NodeJS 的性能优化经验，具体细节不再说了，涉及到更改 NodeJS 源码。同时，<strong>问题调试和定位</strong> 作为 NodeJS 服务器端最大痛点的一些处理经验。</p>\n<p>最后，其实回到一个问题，为什么用NodeJS？其实大部分答案是 <strong>因为前端所以Node</strong>， NodeJs 驱动的移动端的 H5 开发效率有很大优势，做接口合并、转发等逻辑，大大减小沟通成本。</p>\n<p>PS：使用 NodeJS 的原因其实是笔者脑洞的。其实他们选择用 NodeJS 的原因不仅仅为此，更多应该是业务场景的原因。以后需要前端同学更努力，才能使 NodeJS 更广泛的使用。</p>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><p>关于工具，笔者关注了一下 Web接口管理工具RAP，一个阿里系的接口管理工具。</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/71c50075gw1ez9pw2fk7sj20xy0hy0w1.jpg\" alt=\"图\"></p>\n<p>有兴趣的同学可以关注下，简单看了一下，功能非常全，对于电商场景比较适用。</p>\n<ul>\n<li>Github地址: <a href=\"https://github.com/thx/RAP\" target=\"_blank\" rel=\"noopener\">https://github.com/thx/RAP</a></li>\n</ul>\n<p>笔者准备深入研究，构建一个适用于我司业务的Web接口管理工具。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>之前对 React JS 研究得并不深，所以分享只是大概了解下。</p>\n<p>而炫酷阿里的 DataV 数据可视化，可以参见 <a href=\"https://video.weibo.com/show?fid=1034:fd0a5bc90c7a677e5e70804e2512be33&amp;ep=D99bMDl8y%2C2827596505%2CD99bMDl8y%2C2827596505\" target=\"_blank\" rel=\"noopener\">视频</a>，这里也不多说了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>今年的D2，主题是融合，火的是多端一体化开发。引用两句话做总结：(非原话，含义相似)</p>\n<ul>\n<li>@玄难：十年前写的Java代码现在还能用，十年前写的JS代码现在绝对用不了</li>\n<li>@打饭时碰到的路人甲：现在的前端团队不懂Native，是活不下去的（PS：只是意会，不是绝对）</li>\n</ul>\n<p>期待明年的D2。更多 D2 的内容，可以参看 <a href=\"https://www.zhihu.com/question/38637676\" target=\"_blank\" rel=\"noopener\">参加第十届D2前端技术论坛，你有什么收获？</a> 中的答案。</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws1.sinaimg.cn/large/006cGJIjly1fizh2ar55tj30dc07ot95.jpg","excerpt":"<p>去杭州参加了，阿里巴巴第10届D2前端论坛，主题是『融合』，可以说受益匪浅。上一次D2，笔者是从自身技术的角度去听了分享，而此次，却是从团队技术方向和解决方案的角度去听，不同的角度有不同的收获。","more":"</p>\n<p>对于论坛的主线，大概分成三个方向：</p>\n<ol>\n<li><p>首当其冲的当然是现在最火的多端一体化方案，像Hybrid，React Native都是此类，同时也是众说纷纭的一类。</p>\n</li>\n<li><p>另外，则是 Node 在大型项目中的应用的问题，包括多并发处理、性能优化以及其他一些在实战中的经验。</p>\n</li>\n<li><p>最后，是一些新框架、工具的东西，像数据可视化的DataV，像接口管理的RAP，都是一些不错的东西，也有很多可用的场景。</p>\n</li>\n</ol>\n<h3 id=\"React-Native-以及-Hybrid-的发展前景\"><a href=\"#React-Native-以及-Hybrid-的发展前景\" class=\"headerlink\" title=\"React Native 以及 Hybrid 的发展前景\"></a>React Native 以及 Hybrid 的发展前景</h3><p>说到这里，不得不提到老生常谈的『 Native vs Web 』的话题。其实，也就是 <strong>Native 的用户体验</strong> 与 <strong>Web 的开发体验</strong> 间的博弈。此时，React Native 横空出世，倍受关注。为什么呢？原因有以下几点：</p>\n<ol>\n<li>Native API - 用户体验</li>\n<li>编程语言能力 JS Core &amp; 不用编译 - 开发体验</li>\n<li>布局和样式能力 - 开发体验</li>\n<li>声明式编程（组件化）- 开发体验</li>\n<li>开源&amp;社区 - 开发体验</li>\n</ol>\n<p>从这五点来看，React Native 非常注重开发者的体验，这也是 React Native 火遍全球的原因之一。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006cGJIjly1fizh2ar55tj30dc07ot95.jpg\" alt=\"React Native\"></p>\n<p>但，从业务需求上看 <strong>使用 React Native 成本还是比较高的</strong>。一方面，业务的学习迁移成本还是比较高的；另一方面，iOS和Android两个平台分别开发，代码复用率只有 85% 左右，而且对 Touch 平台的兼容也并不是太好（来自阿里手淘团队的分享）。</p>\n<p>而另一位来自淘宝的 @元彦 分享了基于 React Native 的适配 iOS、Android、Touch 三平台的框架 Portal，并计划本月底开源，具体细节还没公布（地址为：<a href=\"https://github.com/taobaofed/react-web\" target=\"_blank\" rel=\"noopener\">https://github.com/taobaofed/react-web</a>）。对于Portal，有同仁总结其最大的特点是 <strong>衣帽间业务层代码在无线 Web 和 Native 双平台上实现了 100% 复用率。</strong>（Portal 提供了 React-Web 部分，来适配 Touch 端的展现。） 这套架构的核心是Generator，<strong>发布时代码通过Generator进行打包，分发到各个平台</strong>。具体细节还没有放出，等开源之后可以详细研究其代码结构。最后，这套框架暂时没有使用在阿里核心的业务上，这种方案是否有效，还有待考证。</p>\n<p>至此，可以对 React Native 做个简单的总结：<strong>对于原有业务，迁移到React Native 的成本还是比较高的；对于新业务，多端平台代码复用的问题有待考证。</strong></p>\n<p>这里，提一个笔者对 React Native 的疑问：当 Native 原生开发解决开发体验问题或者 Web 开发解决用户体验问题（主要是低端Android）后，React Native 将如何定位？</p>\n<p>或许，Native 原生开发解决开发体验问题很难，但是 Web 解决用户体验问题并不困难，至少现在在 iOS 上，Web 的体验可以做得相当好。而一些大数据渲染导致浏览器内存泄露至崩溃的问题，用 React Native 和用原生 Native 做的区别和成本又相差多少呢？很多人和笔者有同样的疑惑，但是并没有很明确的答案。提升 Web 端的性能看似是厂商直接提升硬件和系统般简单，而且 Webkit 也几乎统一了移动端浏览器内核，但是进展究竟如何，并没有很好地预期。</p>\n<p>回到分享，手淘分享了他们的方案，他们的方案是 <strong>将Native覆盖在WebView上</strong>，提供 TableView、TabBar、Slider、SideBar四个Native组件，通过引擎将模板渲染成Native和Webview混合的UI，比较固定或者高性能的部分用native，动态内容用web，一起拼装。</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075gw1ez9pokagezj218a0gcwi3.jpg\" alt=\"手淘的整体架构（盗自 @yuanyuan 的知乎）\"></p>\n<p>刚好，另一个会场分享 Baidu 的同学分享 Clouda+ 的 <a href=\"https://clouda.baidu.com/blendui/introduction/introduction\" target=\"_blank\" rel=\"noopener\">Blend UI</a>，和手淘的方案很类似，下面是 Blend UI 的特征：</p>\n<ul>\n<li><p>多Webview控制能力。让一个Webapp拆到多个webview中运行，并能用Javascript来调度，解决了页面过大导致卡顿的问题，同时，webview的转场动画由Native代码实现，也解决了转场动画不流畅的问题。</p>\n</li>\n<li><p>Native组件嵌入能力。能将Native控件嵌入Webview中，这样就能让页面中那些性能较差的部分用Native来实现，以最大化地提高体验和交互。</p>\n</li>\n</ul>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075gw1ez9ptmyqmcj210b0l7dhu.jpg\" alt=\"Blend UI\"></p>\n<p>当然这种方案也有一些问题，例如 Native 和 WebView 的滚动不同步，考虑限制 Native 大部分为 Fixed，对业务限制比较大等等。</p>\n<p>其实，类似于国内也有类似 React Native 的项目，GeeZooStudio （用过 BeeFramework 的 iOS 开发者应该知道）的创始人分享了他们实现的 NativeUI 框架，自己实现了引擎，来解析 JS 并用 Native 渲染 UI，预计半年内发布和开源。</p>\n<p>今年 D2 上，React Native 被受关注（PS：蚂蚁金融和Strikingly的分享是React 不是 React Native），但是成果并不是很多，毕竟离 React Native 的 Android 版本开源，刚刚三个月的时间，并不被以应用到很多大型项目中。</p>\n<p>下面，总结一下笔者在听完D2分享后，对 React Native 和 Hybrid 的一些看法和想法：</p>\n<ul>\n<li>React Native 是值得学习和使用的，但是大公司主要业务项目的实践还不是很多。老业务迁移成本大，新业务可以尝试，鉴于 React Native 迭代速度比较快，核心框架还不是非常稳定，坑较多，所以要走的路还很长。</li>\n<li>WebView Hybrid 方案，在厂商浏览器性能提升之前，怎么达到 Native 的交互体验仍是比较严重的问题。为此手淘和百度（已经用于百度贴吧）给出的解决方案，是融合 Native 和 WebView，但是这样的 JS 和 Native 交互会很多，多 WebView 通信的问题需要接解决。</li>\n<li>刚才说到，React Native 迭代比较快，核心框架还不稳定，因此，如果在稳定之前采用 React Native，那么 <strong>React Native 框架更新</strong> 将是一个问题。同样的，WebView HyBrid 方案也存在缓存离线问题，包括手淘、蚂蚁金服和QZone，都使用 <strong>推拉结合</strong> 的方式，让离线资源尽快更新。</li>\n</ul>\n<p>最后，耳闻阿里自己搞了一个Weex框架，是 @勾股 带头搞的，类似于 React Native 框架的东西，但是更轻量，像是 Vue-Native (vue.js @尤小右)。具体的介绍，可以看 <a href=\"https://www.zhihu.com/question/37636296\" target=\"_blank\" rel=\"noopener\">如何看待阿里无线前端发布的Weex?</a>。 @winter 的回答，说明了开源计划和为什么放弃RN。（PS：话说，这个框架好像主要针对于电商场景）</p>\n<h3 id=\"NodeJS-在大型场景中的应用和性能优化\"><a href=\"#NodeJS-在大型场景中的应用和性能优化\" class=\"headerlink\" title=\"NodeJS 在大型场景中的应用和性能优化\"></a>NodeJS 在大型场景中的应用和性能优化</h3><p>NodeJS，从前几年只被看好，到现在已经应用到类似大型业务项目中，竞争力逐渐显现。用 NodeJS 要比 Spring 好？比 PHP 快？这些都是相对于言的。NodeJS 已经用在了 <strong>天猫</strong> 和 <strong>Qzone</strong> 两个大型项目中，这足可以证明 NodeJS 的能力。</p>\n<p><img src=\"https://www.html5china.com/uploads/allimg/111218/161PC4H-1.png\" alt=\"吸引眼球的NodeJS\"></p>\n<p>@不四 讲了天猫的 NodeJS 方案，而腾讯的同学讲了 QZone 的方案。其实大同小异，主要的内容就几项：</p>\n<ul>\n<li>怎么处理高并发？</li>\n<li>怎么记录日志并快速还原场景？</li>\n<li>怎么友好地退出子进程？</li>\n<li>怎么做业务分层？</li>\n<li>怎么设计中间件？</li>\n<li>……</li>\n</ul>\n<p>其中，@不四 还分享了使用 Cluster 时的一些经验，例如，Master 只做进程管理，Worker 异常退出后自动重启逻辑使用的模块 cfork，Http 服务优雅退出的模块 graceful 等等。</p>\n<p>在其他会场，@朴灵 还分享了 AliNode 和 NodeJS 的性能优化经验，具体细节不再说了，涉及到更改 NodeJS 源码。同时，<strong>问题调试和定位</strong> 作为 NodeJS 服务器端最大痛点的一些处理经验。</p>\n<p>最后，其实回到一个问题，为什么用NodeJS？其实大部分答案是 <strong>因为前端所以Node</strong>， NodeJs 驱动的移动端的 H5 开发效率有很大优势，做接口合并、转发等逻辑，大大减小沟通成本。</p>\n<p>PS：使用 NodeJS 的原因其实是笔者脑洞的。其实他们选择用 NodeJS 的原因不仅仅为此，更多应该是业务场景的原因。以后需要前端同学更努力，才能使 NodeJS 更广泛的使用。</p>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><p>关于工具，笔者关注了一下 Web接口管理工具RAP，一个阿里系的接口管理工具。</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/71c50075gw1ez9pw2fk7sj20xy0hy0w1.jpg\" alt=\"图\"></p>\n<p>有兴趣的同学可以关注下，简单看了一下，功能非常全，对于电商场景比较适用。</p>\n<ul>\n<li>Github地址: <a href=\"https://github.com/thx/RAP\" target=\"_blank\" rel=\"noopener\">https://github.com/thx/RAP</a></li>\n</ul>\n<p>笔者准备深入研究，构建一个适用于我司业务的Web接口管理工具。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>之前对 React JS 研究得并不深，所以分享只是大概了解下。</p>\n<p>而炫酷阿里的 DataV 数据可视化，可以参见 <a href=\"https://video.weibo.com/show?fid=1034:fd0a5bc90c7a677e5e70804e2512be33&amp;ep=D99bMDl8y%2C2827596505%2CD99bMDl8y%2C2827596505\" target=\"_blank\" rel=\"noopener\">视频</a>，这里也不多说了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>今年的D2，主题是融合，火的是多端一体化开发。引用两句话做总结：(非原话，含义相似)</p>\n<ul>\n<li>@玄难：十年前写的Java代码现在还能用，十年前写的JS代码现在绝对用不了</li>\n<li>@打饭时碰到的路人甲：现在的前端团队不懂Native，是活不下去的（PS：只是意会，不是绝对）</li>\n</ul>\n<p>期待明年的D2。更多 D2 的内容，可以参看 <a href=\"https://www.zhihu.com/question/38637676\" target=\"_blank\" rel=\"noopener\">参加第十届D2前端技术论坛，你有什么收获？</a> 中的答案。</p>"},{"title":"Docker 在前端开发中的应用 —— 快速部署统一开发环境","date":"2016-10-25T16:00:00.000Z","thumbnailImage":"https://ws1.sinaimg.cn/large/006cGJIjly1fizampp49qj308k04tdgg.jpg","thumbnailImagePosition":"left","_content":"\nDocker 刚发布时，定位是一个单机的轻量化虚拟化工具，只被部分运维人员知晓。但伴随着 Docker 大生态的发展，Google 、微软、亚马逊等大厂的加入，Docker 逐渐为开发所知。<!-- more -->\n\nDocker 的意义在于：**Build once， run anything in anywhere at anytime** （笔者仿造 RN 的口号脑补的）。Docker 很像一个打包工具，将你的应用打包，迁移并运行在各种平台、各种环境上，降低了应用对环境的依赖，从最底层降低了开发成本。如此接地气的技术，**将来应该是每个开发者必须掌握的一项技能**，业界都惊呼 Docker 是下一个 Hadoop。\n\n此篇文章要探讨一下 Docker 在前端技术中的应用。有人说，Docker 是服务端技术，和前端没有任何关系。如果你指的是纯粹的前端，纯粹的 HTML + JS + CSS 的话，真的没有什么关系；但是在广义的大前端环境下，你的前端项目要依赖各式各样的打包工具或者你要用 Node 开发一个后端工程，那么关系就很大了。 这里笔者，主要结合前端开发环境上遇到的问题，来探讨 Docker 的应用。\n\n![各大厂商的支持](https://img.ptcms.csdn.net/article/201506/23/5588fb74cab55_middle.jpg)\n\n### 前端开发环境遇到的问题\n\n作为一个前端工程师，当你拿到一个新电脑时，你可能要安装：Node、NVM、NPM、YARN、CNPM、Gulp、Webpack、Browserify、Bower、Sass、Less、Coffee、Babel、React-Native-Cli 甚至还有 pm2、forever 等等。再加上如果你是一个 Windows 用户，那么『天将降大任』就来了。更别说为了兼容多个项目，你要装 Node 4.x 的同时，装 NPM 3.x；也不要提，在大局域网里，被『墙』逼得要死。随着前端的发展，开发环境越来越复杂，这种种问题都会时常遇到，而且这些问题不是所有人都可以很快解决的，尤其对于刚入行的新人。\n\n总结一下上面的阐述，可以抽象为三个主要问题：\n\n1. 依赖的环境很多，本地搭建一套环境成本越来越高，初级人员很难解决环境部署的一些问题。\n2. 环境的版本差异（常见的 Node 版本）及 OS 的差异（例如 Node Sass 依赖 OS）都可能导致线上环境的 BUG 或故障。\n3. 项目的环境大变动时，所有人的环境要重新部署。\n\n对于，一些大厂，会提供给开发人员一些开发机，来保证环境的一致性。 不过，这样做会投入一些开发环境的机器或者虚机，提高了公司的成本；同时，采用开发机的形式，需要把本地的代码同步到开发机，每改动一次代码，都要同步一次，如果网络不畅通或者工程很大，那么会大幅增加时间成本，并且在非公司内网环境，此种方案是无法采用的。\n\n本地如何解决呢？有人说虚拟机就可以解决。对于前两个问题，利用虚拟机是可以解决的，而第三个问题，由于虚拟机的镜像并没有版本概念，同时也没有一个种统一的云端管理方式，以至于，当多人同时操作一个镜像时，很容易出现冲突或遗漏，传输起来也很困难。\n\n而  Docker 作为轻量级虚拟化工具，在提供了仓库和版本的逻辑的同时，体积也比一般的虚拟机镜像小得多，并且支持『秒启』，所以 Docker 几乎可以完美的解决上述三个问题。\n\n![Docker VS VMs](https://img.blog.csdn.net/20140306094828703)\n\n既然解决了问题，那么下面要了解下怎么办。\n\n### 如何使用 Docker\n\n假设一个场景，有这样一个 JS 脚本文件 (index.js)，我期望他每个开发者用 Node 执行后可以输出同样的内容。\n\n```javascript\nconsole.log([process.platform, process.version].join('-'));\n```\n\n代码大家一看就明白，输出相同的内容，需要每个开发者有『相同平台、相同 Node』版本的『开发环境』。\n\n#### Docker 环境\n\n安装 Docker，基本上是傻瓜式安装，可以从 Docker 官网上下载安装包或者国内 DaoCloud 的官网上下载，安装过程并没有什么坑。此时，在你的 Bash 里就存在了 `docker` 命令。\n\n#### 构建一个镜像\n\n首先，你要有一个 Dockerfile，示例如下:\n\n```\nFROM daocloud.io/library/centos\nMAINTAINER edwon lim <adwon.lin@qunar.com>\n\nRUN curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash \\\n    && source /root/.bash_profile \\\n    && nvm install v4.4.4\n```\n\n然后在这个文件所在的目录执行 `docker build --tag node_environment .`，从而构建出一个名为 `node_environment` 的镜像。\n\n代码很好理解，其实就是在一个 centos 的镜像上，安装 nvm 和 4.4.4 版本的 node，从而生成一个新的镜像。\n\n#### 如何运行\n\n```\ndocker run -v ./:/root/workspace node_environment /bin/bash -c \"source ~/.bash_profile; cd /root/workspace; node index.js\"\n```\n\n这句命令也很好理解，就是把当前目录挂在到容器（由镜像创建的运行环境，可以理解为虚拟机）的 `/root/workspace` 下，然后在虚拟环境下执行 `node index.js`，这样输出的结果将一直是 `Linux-v4.4.4`。\n\n这里有人会说，执行的命令太长，那么你可以用 `alias good_node=\"docker run -v $(pwd):/root/workspace node_environment /bin/bash -c \"source ~/.bash_profile; cd /root/workspace; node $1\"`，这样以后只需要执行 `good_node index.js` 即可。\n\n#### 共享给其他人\n\n把镜像共享给他人，才能让所有人都持有统一套环境。常见的有两种方式：\n\n1. 将 Dockerfile push 到版本仓库中，其他人更新并本地 build\n2. 将镜像 push 到 docker 仓库中，其他人通过 docker pull 更新镜像\n\n这节主要简单就一个小案例介绍了一下 Docker 的使用方式。结合实际考虑，项目构建工具，尤其是带有代码编译构建逻辑的，这种方式，**是否能安全有效地避免环境差异造成的一些问题，同时解决多个开发者配置一样的环境所造成的时间、精力成本？** 笔者认为答案是肯定的，而且可以做到 **开发过程中使用的环境和发布时使用的环境完全一致**。\n\n前文简单介绍了一下 Docker，大家大概理解了 Docker 是什么，但是具体怎么使用，还需要很长的路要走。为了，让大家快速上手，将一些常见的使用方式封装成 Dokit 的方式进行使用。\n\n### 接地气的 Dokit\n\nDokit 可以帮助开发者快速部署基于Docker的一体化前端开发环境，介绍文档地址为 <https://ued.qunar.com/dokit/>。\n\nDokit 主要提供了两个功能命令：\n\n1. `dokit`: 初始化创建容器，并进入容器，之后每次直接快速进入容器。\n2. `dokit run 你的命令`: 快速执行命令\n\n![dokit run](https://ww1.sinaimg.cn/large/71c50075gw1f8oii9eenxj20mf08040j.jpg)\n\nDokit 的实现原理很简单，就是封装了 docker 命令和一些经常使用的逻辑，使对 Docker 不是熟悉的用户可以很快上手，三分钟部署好前端环境。\n\nPS：这里感谢我司 OPS 搭建了内网 docker 源，才实现三分钟搭建前端环境的这个艰巨任务（主要是内网下载镜像快）。当然如果你把镜像放到国内最快的源 DaoCloud 上，其实也不会很慢，半小时内肯定能搞定。\n\n### 写在最后\n\nDocker 是当前最火爆的技术之一，而且是很有发展的，笔者建议作为任意方向的开发者都应该学习一下。当然，它也存在一些不完善的地方，但是瑕不掩瑜，Docker 真可以帮我们真正实现环境统一和快速部署，何乐而不为呢？\n","source":"_posts/2016-10-26-Use-Docker-In-Front-End-Development.md","raw":"title: Docker 在前端开发中的应用 —— 快速部署统一开发环境\ndate: 2016-10-26\ncategory: 潮流技术\ntags: [Docker]\nthumbnailImage: https://ws1.sinaimg.cn/large/006cGJIjly1fizampp49qj308k04tdgg.jpg\nthumbnailImagePosition: left\n---\n\nDocker 刚发布时，定位是一个单机的轻量化虚拟化工具，只被部分运维人员知晓。但伴随着 Docker 大生态的发展，Google 、微软、亚马逊等大厂的加入，Docker 逐渐为开发所知。<!-- more -->\n\nDocker 的意义在于：**Build once， run anything in anywhere at anytime** （笔者仿造 RN 的口号脑补的）。Docker 很像一个打包工具，将你的应用打包，迁移并运行在各种平台、各种环境上，降低了应用对环境的依赖，从最底层降低了开发成本。如此接地气的技术，**将来应该是每个开发者必须掌握的一项技能**，业界都惊呼 Docker 是下一个 Hadoop。\n\n此篇文章要探讨一下 Docker 在前端技术中的应用。有人说，Docker 是服务端技术，和前端没有任何关系。如果你指的是纯粹的前端，纯粹的 HTML + JS + CSS 的话，真的没有什么关系；但是在广义的大前端环境下，你的前端项目要依赖各式各样的打包工具或者你要用 Node 开发一个后端工程，那么关系就很大了。 这里笔者，主要结合前端开发环境上遇到的问题，来探讨 Docker 的应用。\n\n![各大厂商的支持](https://img.ptcms.csdn.net/article/201506/23/5588fb74cab55_middle.jpg)\n\n### 前端开发环境遇到的问题\n\n作为一个前端工程师，当你拿到一个新电脑时，你可能要安装：Node、NVM、NPM、YARN、CNPM、Gulp、Webpack、Browserify、Bower、Sass、Less、Coffee、Babel、React-Native-Cli 甚至还有 pm2、forever 等等。再加上如果你是一个 Windows 用户，那么『天将降大任』就来了。更别说为了兼容多个项目，你要装 Node 4.x 的同时，装 NPM 3.x；也不要提，在大局域网里，被『墙』逼得要死。随着前端的发展，开发环境越来越复杂，这种种问题都会时常遇到，而且这些问题不是所有人都可以很快解决的，尤其对于刚入行的新人。\n\n总结一下上面的阐述，可以抽象为三个主要问题：\n\n1. 依赖的环境很多，本地搭建一套环境成本越来越高，初级人员很难解决环境部署的一些问题。\n2. 环境的版本差异（常见的 Node 版本）及 OS 的差异（例如 Node Sass 依赖 OS）都可能导致线上环境的 BUG 或故障。\n3. 项目的环境大变动时，所有人的环境要重新部署。\n\n对于，一些大厂，会提供给开发人员一些开发机，来保证环境的一致性。 不过，这样做会投入一些开发环境的机器或者虚机，提高了公司的成本；同时，采用开发机的形式，需要把本地的代码同步到开发机，每改动一次代码，都要同步一次，如果网络不畅通或者工程很大，那么会大幅增加时间成本，并且在非公司内网环境，此种方案是无法采用的。\n\n本地如何解决呢？有人说虚拟机就可以解决。对于前两个问题，利用虚拟机是可以解决的，而第三个问题，由于虚拟机的镜像并没有版本概念，同时也没有一个种统一的云端管理方式，以至于，当多人同时操作一个镜像时，很容易出现冲突或遗漏，传输起来也很困难。\n\n而  Docker 作为轻量级虚拟化工具，在提供了仓库和版本的逻辑的同时，体积也比一般的虚拟机镜像小得多，并且支持『秒启』，所以 Docker 几乎可以完美的解决上述三个问题。\n\n![Docker VS VMs](https://img.blog.csdn.net/20140306094828703)\n\n既然解决了问题，那么下面要了解下怎么办。\n\n### 如何使用 Docker\n\n假设一个场景，有这样一个 JS 脚本文件 (index.js)，我期望他每个开发者用 Node 执行后可以输出同样的内容。\n\n```javascript\nconsole.log([process.platform, process.version].join('-'));\n```\n\n代码大家一看就明白，输出相同的内容，需要每个开发者有『相同平台、相同 Node』版本的『开发环境』。\n\n#### Docker 环境\n\n安装 Docker，基本上是傻瓜式安装，可以从 Docker 官网上下载安装包或者国内 DaoCloud 的官网上下载，安装过程并没有什么坑。此时，在你的 Bash 里就存在了 `docker` 命令。\n\n#### 构建一个镜像\n\n首先，你要有一个 Dockerfile，示例如下:\n\n```\nFROM daocloud.io/library/centos\nMAINTAINER edwon lim <adwon.lin@qunar.com>\n\nRUN curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash \\\n    && source /root/.bash_profile \\\n    && nvm install v4.4.4\n```\n\n然后在这个文件所在的目录执行 `docker build --tag node_environment .`，从而构建出一个名为 `node_environment` 的镜像。\n\n代码很好理解，其实就是在一个 centos 的镜像上，安装 nvm 和 4.4.4 版本的 node，从而生成一个新的镜像。\n\n#### 如何运行\n\n```\ndocker run -v ./:/root/workspace node_environment /bin/bash -c \"source ~/.bash_profile; cd /root/workspace; node index.js\"\n```\n\n这句命令也很好理解，就是把当前目录挂在到容器（由镜像创建的运行环境，可以理解为虚拟机）的 `/root/workspace` 下，然后在虚拟环境下执行 `node index.js`，这样输出的结果将一直是 `Linux-v4.4.4`。\n\n这里有人会说，执行的命令太长，那么你可以用 `alias good_node=\"docker run -v $(pwd):/root/workspace node_environment /bin/bash -c \"source ~/.bash_profile; cd /root/workspace; node $1\"`，这样以后只需要执行 `good_node index.js` 即可。\n\n#### 共享给其他人\n\n把镜像共享给他人，才能让所有人都持有统一套环境。常见的有两种方式：\n\n1. 将 Dockerfile push 到版本仓库中，其他人更新并本地 build\n2. 将镜像 push 到 docker 仓库中，其他人通过 docker pull 更新镜像\n\n这节主要简单就一个小案例介绍了一下 Docker 的使用方式。结合实际考虑，项目构建工具，尤其是带有代码编译构建逻辑的，这种方式，**是否能安全有效地避免环境差异造成的一些问题，同时解决多个开发者配置一样的环境所造成的时间、精力成本？** 笔者认为答案是肯定的，而且可以做到 **开发过程中使用的环境和发布时使用的环境完全一致**。\n\n前文简单介绍了一下 Docker，大家大概理解了 Docker 是什么，但是具体怎么使用，还需要很长的路要走。为了，让大家快速上手，将一些常见的使用方式封装成 Dokit 的方式进行使用。\n\n### 接地气的 Dokit\n\nDokit 可以帮助开发者快速部署基于Docker的一体化前端开发环境，介绍文档地址为 <https://ued.qunar.com/dokit/>。\n\nDokit 主要提供了两个功能命令：\n\n1. `dokit`: 初始化创建容器，并进入容器，之后每次直接快速进入容器。\n2. `dokit run 你的命令`: 快速执行命令\n\n![dokit run](https://ww1.sinaimg.cn/large/71c50075gw1f8oii9eenxj20mf08040j.jpg)\n\nDokit 的实现原理很简单，就是封装了 docker 命令和一些经常使用的逻辑，使对 Docker 不是熟悉的用户可以很快上手，三分钟部署好前端环境。\n\nPS：这里感谢我司 OPS 搭建了内网 docker 源，才实现三分钟搭建前端环境的这个艰巨任务（主要是内网下载镜像快）。当然如果你把镜像放到国内最快的源 DaoCloud 上，其实也不会很慢，半小时内肯定能搞定。\n\n### 写在最后\n\nDocker 是当前最火爆的技术之一，而且是很有发展的，笔者建议作为任意方向的开发者都应该学习一下。当然，它也存在一些不完善的地方，但是瑕不掩瑜，Docker 真可以帮我们真正实现环境统一和快速部署，何乐而不为呢？\n","slug":"2016-10-26-Use-Docker-In-Front-End-Development","published":1,"updated":"2018-06-25T03:18:28.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc71000ahxp4svaunn58","content":"<p>Docker 刚发布时，定位是一个单机的轻量化虚拟化工具，只被部分运维人员知晓。但伴随着 Docker 大生态的发展，Google 、微软、亚马逊等大厂的加入，Docker 逐渐为开发所知。<a id=\"more\"></a></p>\n<p>Docker 的意义在于：<strong>Build once， run anything in anywhere at anytime</strong> （笔者仿造 RN 的口号脑补的）。Docker 很像一个打包工具，将你的应用打包，迁移并运行在各种平台、各种环境上，降低了应用对环境的依赖，从最底层降低了开发成本。如此接地气的技术，<strong>将来应该是每个开发者必须掌握的一项技能</strong>，业界都惊呼 Docker 是下一个 Hadoop。</p>\n<p>此篇文章要探讨一下 Docker 在前端技术中的应用。有人说，Docker 是服务端技术，和前端没有任何关系。如果你指的是纯粹的前端，纯粹的 HTML + JS + CSS 的话，真的没有什么关系；但是在广义的大前端环境下，你的前端项目要依赖各式各样的打包工具或者你要用 Node 开发一个后端工程，那么关系就很大了。 这里笔者，主要结合前端开发环境上遇到的问题，来探讨 Docker 的应用。</p>\n<p><img src=\"https://img.ptcms.csdn.net/article/201506/23/5588fb74cab55_middle.jpg\" alt=\"各大厂商的支持\"></p>\n<h3 id=\"前端开发环境遇到的问题\"><a href=\"#前端开发环境遇到的问题\" class=\"headerlink\" title=\"前端开发环境遇到的问题\"></a>前端开发环境遇到的问题</h3><p>作为一个前端工程师，当你拿到一个新电脑时，你可能要安装：Node、NVM、NPM、YARN、CNPM、Gulp、Webpack、Browserify、Bower、Sass、Less、Coffee、Babel、React-Native-Cli 甚至还有 pm2、forever 等等。再加上如果你是一个 Windows 用户，那么『天将降大任』就来了。更别说为了兼容多个项目，你要装 Node 4.x 的同时，装 NPM 3.x；也不要提，在大局域网里，被『墙』逼得要死。随着前端的发展，开发环境越来越复杂，这种种问题都会时常遇到，而且这些问题不是所有人都可以很快解决的，尤其对于刚入行的新人。</p>\n<p>总结一下上面的阐述，可以抽象为三个主要问题：</p>\n<ol>\n<li>依赖的环境很多，本地搭建一套环境成本越来越高，初级人员很难解决环境部署的一些问题。</li>\n<li>环境的版本差异（常见的 Node 版本）及 OS 的差异（例如 Node Sass 依赖 OS）都可能导致线上环境的 BUG 或故障。</li>\n<li>项目的环境大变动时，所有人的环境要重新部署。</li>\n</ol>\n<p>对于，一些大厂，会提供给开发人员一些开发机，来保证环境的一致性。 不过，这样做会投入一些开发环境的机器或者虚机，提高了公司的成本；同时，采用开发机的形式，需要把本地的代码同步到开发机，每改动一次代码，都要同步一次，如果网络不畅通或者工程很大，那么会大幅增加时间成本，并且在非公司内网环境，此种方案是无法采用的。</p>\n<p>本地如何解决呢？有人说虚拟机就可以解决。对于前两个问题，利用虚拟机是可以解决的，而第三个问题，由于虚拟机的镜像并没有版本概念，同时也没有一个种统一的云端管理方式，以至于，当多人同时操作一个镜像时，很容易出现冲突或遗漏，传输起来也很困难。</p>\n<p>而  Docker 作为轻量级虚拟化工具，在提供了仓库和版本的逻辑的同时，体积也比一般的虚拟机镜像小得多，并且支持『秒启』，所以 Docker 几乎可以完美的解决上述三个问题。</p>\n<p><img src=\"https://img.blog.csdn.net/20140306094828703\" alt=\"Docker VS VMs\"></p>\n<p>既然解决了问题，那么下面要了解下怎么办。</p>\n<h3 id=\"如何使用-Docker\"><a href=\"#如何使用-Docker\" class=\"headerlink\" title=\"如何使用 Docker\"></a>如何使用 Docker</h3><p>假设一个场景，有这样一个 JS 脚本文件 (index.js)，我期望他每个开发者用 Node 执行后可以输出同样的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log([process.platform, process.version].join(<span class=\"string\">'-'</span>));</span><br></pre></td></tr></table></figure>\n<p>代码大家一看就明白，输出相同的内容，需要每个开发者有『相同平台、相同 Node』版本的『开发环境』。</p>\n<h4 id=\"Docker-环境\"><a href=\"#Docker-环境\" class=\"headerlink\" title=\"Docker 环境\"></a>Docker 环境</h4><p>安装 Docker，基本上是傻瓜式安装，可以从 Docker 官网上下载安装包或者国内 DaoCloud 的官网上下载，安装过程并没有什么坑。此时，在你的 Bash 里就存在了 <code>docker</code> 命令。</p>\n<h4 id=\"构建一个镜像\"><a href=\"#构建一个镜像\" class=\"headerlink\" title=\"构建一个镜像\"></a>构建一个镜像</h4><p>首先，你要有一个 Dockerfile，示例如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM daocloud.io/library/centos</span><br><span class=\"line\">MAINTAINER edwon lim &lt;adwon.lin@qunar.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">RUN curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash \\</span><br><span class=\"line\">    &amp;&amp; source /root/.bash_profile \\</span><br><span class=\"line\">    &amp;&amp; nvm install v4.4.4</span><br></pre></td></tr></table></figure>\n<p>然后在这个文件所在的目录执行 <code>docker build --tag node_environment .</code>，从而构建出一个名为 <code>node_environment</code> 的镜像。</p>\n<p>代码很好理解，其实就是在一个 centos 的镜像上，安装 nvm 和 4.4.4 版本的 node，从而生成一个新的镜像。</p>\n<h4 id=\"如何运行\"><a href=\"#如何运行\" class=\"headerlink\" title=\"如何运行\"></a>如何运行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v ./:/root/workspace node_environment /bin/bash -c &quot;source ~/.bash_profile; cd /root/workspace; node index.js&quot;</span><br></pre></td></tr></table></figure>\n<p>这句命令也很好理解，就是把当前目录挂在到容器（由镜像创建的运行环境，可以理解为虚拟机）的 <code>/root/workspace</code> 下，然后在虚拟环境下执行 <code>node index.js</code>，这样输出的结果将一直是 <code>Linux-v4.4.4</code>。</p>\n<p>这里有人会说，执行的命令太长，那么你可以用 <code>alias good_node=&quot;docker run -v $(pwd):/root/workspace node_environment /bin/bash -c &quot;source ~/.bash_profile; cd /root/workspace; node $1&quot;</code>，这样以后只需要执行 <code>good_node index.js</code> 即可。</p>\n<h4 id=\"共享给其他人\"><a href=\"#共享给其他人\" class=\"headerlink\" title=\"共享给其他人\"></a>共享给其他人</h4><p>把镜像共享给他人，才能让所有人都持有统一套环境。常见的有两种方式：</p>\n<ol>\n<li>将 Dockerfile push 到版本仓库中，其他人更新并本地 build</li>\n<li>将镜像 push 到 docker 仓库中，其他人通过 docker pull 更新镜像</li>\n</ol>\n<p>这节主要简单就一个小案例介绍了一下 Docker 的使用方式。结合实际考虑，项目构建工具，尤其是带有代码编译构建逻辑的，这种方式，<strong>是否能安全有效地避免环境差异造成的一些问题，同时解决多个开发者配置一样的环境所造成的时间、精力成本？</strong> 笔者认为答案是肯定的，而且可以做到 <strong>开发过程中使用的环境和发布时使用的环境完全一致</strong>。</p>\n<p>前文简单介绍了一下 Docker，大家大概理解了 Docker 是什么，但是具体怎么使用，还需要很长的路要走。为了，让大家快速上手，将一些常见的使用方式封装成 Dokit 的方式进行使用。</p>\n<h3 id=\"接地气的-Dokit\"><a href=\"#接地气的-Dokit\" class=\"headerlink\" title=\"接地气的 Dokit\"></a>接地气的 Dokit</h3><p>Dokit 可以帮助开发者快速部署基于Docker的一体化前端开发环境，介绍文档地址为 <a href=\"https://ued.qunar.com/dokit/\" target=\"_blank\" rel=\"noopener\">https://ued.qunar.com/dokit/</a>。</p>\n<p>Dokit 主要提供了两个功能命令：</p>\n<ol>\n<li><code>dokit</code>: 初始化创建容器，并进入容器，之后每次直接快速进入容器。</li>\n<li><code>dokit run 你的命令</code>: 快速执行命令</li>\n</ol>\n<p><img src=\"https://ww1.sinaimg.cn/large/71c50075gw1f8oii9eenxj20mf08040j.jpg\" alt=\"dokit run\"></p>\n<p>Dokit 的实现原理很简单，就是封装了 docker 命令和一些经常使用的逻辑，使对 Docker 不是熟悉的用户可以很快上手，三分钟部署好前端环境。</p>\n<p>PS：这里感谢我司 OPS 搭建了内网 docker 源，才实现三分钟搭建前端环境的这个艰巨任务（主要是内网下载镜像快）。当然如果你把镜像放到国内最快的源 DaoCloud 上，其实也不会很慢，半小时内肯定能搞定。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>Docker 是当前最火爆的技术之一，而且是很有发展的，笔者建议作为任意方向的开发者都应该学习一下。当然，它也存在一些不完善的地方，但是瑕不掩瑜，Docker 真可以帮我们真正实现环境统一和快速部署，何乐而不为呢？</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws1.sinaimg.cn/large/006cGJIjly1fizampp49qj308k04tdgg.jpg","excerpt":"<p>Docker 刚发布时，定位是一个单机的轻量化虚拟化工具，只被部分运维人员知晓。但伴随着 Docker 大生态的发展，Google 、微软、亚马逊等大厂的加入，Docker 逐渐为开发所知。","more":"</p>\n<p>Docker 的意义在于：<strong>Build once， run anything in anywhere at anytime</strong> （笔者仿造 RN 的口号脑补的）。Docker 很像一个打包工具，将你的应用打包，迁移并运行在各种平台、各种环境上，降低了应用对环境的依赖，从最底层降低了开发成本。如此接地气的技术，<strong>将来应该是每个开发者必须掌握的一项技能</strong>，业界都惊呼 Docker 是下一个 Hadoop。</p>\n<p>此篇文章要探讨一下 Docker 在前端技术中的应用。有人说，Docker 是服务端技术，和前端没有任何关系。如果你指的是纯粹的前端，纯粹的 HTML + JS + CSS 的话，真的没有什么关系；但是在广义的大前端环境下，你的前端项目要依赖各式各样的打包工具或者你要用 Node 开发一个后端工程，那么关系就很大了。 这里笔者，主要结合前端开发环境上遇到的问题，来探讨 Docker 的应用。</p>\n<p><img src=\"https://img.ptcms.csdn.net/article/201506/23/5588fb74cab55_middle.jpg\" alt=\"各大厂商的支持\"></p>\n<h3 id=\"前端开发环境遇到的问题\"><a href=\"#前端开发环境遇到的问题\" class=\"headerlink\" title=\"前端开发环境遇到的问题\"></a>前端开发环境遇到的问题</h3><p>作为一个前端工程师，当你拿到一个新电脑时，你可能要安装：Node、NVM、NPM、YARN、CNPM、Gulp、Webpack、Browserify、Bower、Sass、Less、Coffee、Babel、React-Native-Cli 甚至还有 pm2、forever 等等。再加上如果你是一个 Windows 用户，那么『天将降大任』就来了。更别说为了兼容多个项目，你要装 Node 4.x 的同时，装 NPM 3.x；也不要提，在大局域网里，被『墙』逼得要死。随着前端的发展，开发环境越来越复杂，这种种问题都会时常遇到，而且这些问题不是所有人都可以很快解决的，尤其对于刚入行的新人。</p>\n<p>总结一下上面的阐述，可以抽象为三个主要问题：</p>\n<ol>\n<li>依赖的环境很多，本地搭建一套环境成本越来越高，初级人员很难解决环境部署的一些问题。</li>\n<li>环境的版本差异（常见的 Node 版本）及 OS 的差异（例如 Node Sass 依赖 OS）都可能导致线上环境的 BUG 或故障。</li>\n<li>项目的环境大变动时，所有人的环境要重新部署。</li>\n</ol>\n<p>对于，一些大厂，会提供给开发人员一些开发机，来保证环境的一致性。 不过，这样做会投入一些开发环境的机器或者虚机，提高了公司的成本；同时，采用开发机的形式，需要把本地的代码同步到开发机，每改动一次代码，都要同步一次，如果网络不畅通或者工程很大，那么会大幅增加时间成本，并且在非公司内网环境，此种方案是无法采用的。</p>\n<p>本地如何解决呢？有人说虚拟机就可以解决。对于前两个问题，利用虚拟机是可以解决的，而第三个问题，由于虚拟机的镜像并没有版本概念，同时也没有一个种统一的云端管理方式，以至于，当多人同时操作一个镜像时，很容易出现冲突或遗漏，传输起来也很困难。</p>\n<p>而  Docker 作为轻量级虚拟化工具，在提供了仓库和版本的逻辑的同时，体积也比一般的虚拟机镜像小得多，并且支持『秒启』，所以 Docker 几乎可以完美的解决上述三个问题。</p>\n<p><img src=\"https://img.blog.csdn.net/20140306094828703\" alt=\"Docker VS VMs\"></p>\n<p>既然解决了问题，那么下面要了解下怎么办。</p>\n<h3 id=\"如何使用-Docker\"><a href=\"#如何使用-Docker\" class=\"headerlink\" title=\"如何使用 Docker\"></a>如何使用 Docker</h3><p>假设一个场景，有这样一个 JS 脚本文件 (index.js)，我期望他每个开发者用 Node 执行后可以输出同样的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log([process.platform, process.version].join(<span class=\"string\">'-'</span>));</span><br></pre></td></tr></table></figure>\n<p>代码大家一看就明白，输出相同的内容，需要每个开发者有『相同平台、相同 Node』版本的『开发环境』。</p>\n<h4 id=\"Docker-环境\"><a href=\"#Docker-环境\" class=\"headerlink\" title=\"Docker 环境\"></a>Docker 环境</h4><p>安装 Docker，基本上是傻瓜式安装，可以从 Docker 官网上下载安装包或者国内 DaoCloud 的官网上下载，安装过程并没有什么坑。此时，在你的 Bash 里就存在了 <code>docker</code> 命令。</p>\n<h4 id=\"构建一个镜像\"><a href=\"#构建一个镜像\" class=\"headerlink\" title=\"构建一个镜像\"></a>构建一个镜像</h4><p>首先，你要有一个 Dockerfile，示例如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM daocloud.io/library/centos</span><br><span class=\"line\">MAINTAINER edwon lim &lt;adwon.lin@qunar.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">RUN curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash \\</span><br><span class=\"line\">    &amp;&amp; source /root/.bash_profile \\</span><br><span class=\"line\">    &amp;&amp; nvm install v4.4.4</span><br></pre></td></tr></table></figure>\n<p>然后在这个文件所在的目录执行 <code>docker build --tag node_environment .</code>，从而构建出一个名为 <code>node_environment</code> 的镜像。</p>\n<p>代码很好理解，其实就是在一个 centos 的镜像上，安装 nvm 和 4.4.4 版本的 node，从而生成一个新的镜像。</p>\n<h4 id=\"如何运行\"><a href=\"#如何运行\" class=\"headerlink\" title=\"如何运行\"></a>如何运行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v ./:/root/workspace node_environment /bin/bash -c &quot;source ~/.bash_profile; cd /root/workspace; node index.js&quot;</span><br></pre></td></tr></table></figure>\n<p>这句命令也很好理解，就是把当前目录挂在到容器（由镜像创建的运行环境，可以理解为虚拟机）的 <code>/root/workspace</code> 下，然后在虚拟环境下执行 <code>node index.js</code>，这样输出的结果将一直是 <code>Linux-v4.4.4</code>。</p>\n<p>这里有人会说，执行的命令太长，那么你可以用 <code>alias good_node=&quot;docker run -v $(pwd):/root/workspace node_environment /bin/bash -c &quot;source ~/.bash_profile; cd /root/workspace; node $1&quot;</code>，这样以后只需要执行 <code>good_node index.js</code> 即可。</p>\n<h4 id=\"共享给其他人\"><a href=\"#共享给其他人\" class=\"headerlink\" title=\"共享给其他人\"></a>共享给其他人</h4><p>把镜像共享给他人，才能让所有人都持有统一套环境。常见的有两种方式：</p>\n<ol>\n<li>将 Dockerfile push 到版本仓库中，其他人更新并本地 build</li>\n<li>将镜像 push 到 docker 仓库中，其他人通过 docker pull 更新镜像</li>\n</ol>\n<p>这节主要简单就一个小案例介绍了一下 Docker 的使用方式。结合实际考虑，项目构建工具，尤其是带有代码编译构建逻辑的，这种方式，<strong>是否能安全有效地避免环境差异造成的一些问题，同时解决多个开发者配置一样的环境所造成的时间、精力成本？</strong> 笔者认为答案是肯定的，而且可以做到 <strong>开发过程中使用的环境和发布时使用的环境完全一致</strong>。</p>\n<p>前文简单介绍了一下 Docker，大家大概理解了 Docker 是什么，但是具体怎么使用，还需要很长的路要走。为了，让大家快速上手，将一些常见的使用方式封装成 Dokit 的方式进行使用。</p>\n<h3 id=\"接地气的-Dokit\"><a href=\"#接地气的-Dokit\" class=\"headerlink\" title=\"接地气的 Dokit\"></a>接地气的 Dokit</h3><p>Dokit 可以帮助开发者快速部署基于Docker的一体化前端开发环境，介绍文档地址为 <a href=\"https://ued.qunar.com/dokit/\" target=\"_blank\" rel=\"noopener\">https://ued.qunar.com/dokit/</a>。</p>\n<p>Dokit 主要提供了两个功能命令：</p>\n<ol>\n<li><code>dokit</code>: 初始化创建容器，并进入容器，之后每次直接快速进入容器。</li>\n<li><code>dokit run 你的命令</code>: 快速执行命令</li>\n</ol>\n<p><img src=\"https://ww1.sinaimg.cn/large/71c50075gw1f8oii9eenxj20mf08040j.jpg\" alt=\"dokit run\"></p>\n<p>Dokit 的实现原理很简单，就是封装了 docker 命令和一些经常使用的逻辑，使对 Docker 不是熟悉的用户可以很快上手，三分钟部署好前端环境。</p>\n<p>PS：这里感谢我司 OPS 搭建了内网 docker 源，才实现三分钟搭建前端环境的这个艰巨任务（主要是内网下载镜像快）。当然如果你把镜像放到国内最快的源 DaoCloud 上，其实也不会很慢，半小时内肯定能搞定。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>Docker 是当前最火爆的技术之一，而且是很有发展的，笔者建议作为任意方向的开发者都应该学习一下。当然，它也存在一些不完善的地方，但是瑕不掩瑜，Docker 真可以帮我们真正实现环境统一和快速部署，何乐而不为呢？</p>"},{"title":"Hy —— 为了 Native 与 Web 彼此间的美好","date":"2016-12-31T16:00:00.000Z","author":"林洋","thumbnailImage":"https://ws1.sinaimg.cn/large/006cGJIjly1fizanxiax2j308k04twfh.jpg","thumbnailImagePosition":"left","_content":"\n随着移动浪潮的兴起，业务在移动端App 的需求量迅速扩大，应用迭代更新的频率也随之极速攀升，但与此同时纯 Native 的开发和更新成本成为了业务增长难以逾越的瓶颈。因此，引入一种开发更高效、成本更低的解决方案势在必行，而在去哪儿这个解决方案就是 Hy。<!-- more -->\n\nHy 方案是平台事业部移动框架组耗时近两年完成的跨平台移动开发 Hybrid一体化的渐进式解决方案，旨在让开发者使用前端技术开发跨平台的移动应用程序。Hy 方案从设计之初到现在经历了非常多的变化，战场从小型独立客户端到去哪儿大客户端，业务从零个到近百个。一路走来，Hy 经历了无数考验，并获得了璀璨的成果，在公司内受到了大家的肯定。\n\n![](https://ww1.sinaimg.cn/large/71c50075jw1fbb8xvl2ivj20l90ibjx2.jpg)\n\n下面，将从几个方面介绍Hy，包括它的架构、理念以及作为开发者的我们经历的一些心路历程。\n\n### 天下武功，唯快不破。\n\n在当前的移动互联网环境下，iOS和Android上的App已经成了每个互联网产品的标配。如果一个用户端产品并不提供相应 App 版本，几乎会直接定义成一个不完整的产品。而被互联网人尊为铁律的『唯快不破』—— 快速开发、高速迭代、低成本上线，同时也是移动时代每个开发团队所追求的目标。综合以上两点原因，『Native 搭台，Web 唱戏』的 Hybrid 开发模式，以『快』的特点赢得了大家的青睐，并纷纷投入大量开发力量，使这种开发模式迅速走红。\n\nHybrid 开发模式是什么？它兼顾Web App『快』和Native App『全』的一种开发模式；它不依赖版本的实时更新，快速实现跨平台需求，同时，又能通过 Native 提供的Api 调用原生功能，解决了纯 Naitve 原生架构，开发『慢』、发布『慢』、更新『慢』的问题，使迭代速度『快』得可以完全满足产品的需求。\n\n![](https://ww2.sinaimg.cn/large/71c50075jw1fbb91bndggj20no08tgma.jpg)\n\n与此同时，2014、2015年正是去哪儿在移动端发力、业务增长迅猛的一段关键时期，因此公司决定更广泛使用 Hybrid 开发模式，同时我们团队也肩负起 Hybrid 方案架构设计和开发的艰巨使命。当然，我们并没有辜负大家的期望，于2015年初上线了第一个 Hy 方案独立 App（ CRM App），并于年中正式提供 Hy 1.0 完整方案，并且终于在最近完成了自我进化——Hy 2.0 发布，基于最新的 React 进行架构，提供更好的技术、工具、文档、统计支持。\n\n### 不仅仅是混合，更多的其实是融合。\n\n对于 Hybrid 开发模式，有人认为它会把Web App扼杀在摇篮里，有人认为它会把Native App引向一个新阶段。而我们的观点是，Hybrid 开发模式更像萃取两方精华、剔除两方糟粕的一条崭新道路，它不会替代任何一方，只是给开发者更多的选择。而 Hy 方案的架构、设计方向正如文章标题所说，Native 和 Web 都有它们自己的『美好』，也有各自的『痛点』，而 Hy 方案要做的不是纠正他们的错误，而是融合他们的『美好』，用对方的『美好』，解决自己的『痛点』，让它们真正地『在一起』。\n\n![](https://ww4.sinaimg.cn/large/71c50075jw1fbb94ek5ufj20lo0dk0va.jpg)\n\n关于融合，其实要从两方面来谈。第一个方面是 Web 融合 Native，也是大家通常所认知的Hybrid —— Native 给 Web 暴露 API，使 Web 具有调用 Native 功能的能力，最著名的代表就是 Codova（PhoneGap）；第二个方面则是 Native 融合 Web，Web 所具有强大的发布能力和大规模协作的能力是 Native 所不具备的，因此 Native 结合自身的特点对 Web 的优秀能力进行融合是必要的。\n\nHy 方案在融合上进行了很深入的探索和实践。在 Web 融合 Native 方面，适配层不仅仅支持了 iOS 和 Android 的壳，还对微信、Touch 进行了充分适配；在 Native 融合 Web 方面，Hy 方案提供了完善的离线资源更新机制，让业务发布 App 上的业务和发布常规业务一样快速简洁，并方便管理。\n\n### 『磨』平平台差异，真正的跨平台。\n\n其实，在谈到前端Hybrid 或者 HTML5 时，大家第一印象其实是『跨平台』——Wrtie Once，Run Anywhere。C 的跨平台基于它的编译器跨平台，Java 的跨平台基于它的运行时 JVM 跨平台，而前端跨平台其实是基于浏览器。虽然 Google、Apple 等大公司主导的开源浏览器内核 WebKit 占领的绝大大部分移动市场，但是由于开源，手机厂商都会对自己设备上 WebView（浏览器）进行『所谓的调优』，因此最终导致现在并没有像JVM 一样统一、靠谱的前端运行环境，使『跨平台』的成本大大加大。\n\n![](https://ww4.sinaimg.cn/large/71c50075jw1fbb967wpzlj20gp0c0mzy.jpg)\n\n其实不仅仅是跨平台，交互尤其是富交互的一致性、离线状态展示等都是业务经常会遇到的问题。面临这样严峻的问题，作为框架的  Hy 方案必须要在这个方面做出突破，将业务经常遇到的坑填平，真正抹平各个平台的差异。\n\n因此，团队下足了功夫。不论从样式到组件逻辑，还是从整体架构到细节处理，都深入去研究、实践、测试。例如，对于高清屏边框1px 的方案，先后更换了三次方案，最终基本完美的解决了问题。这不仅仅是技术，更重要的是态度，一点点打磨，最终磨平平台差异，实现真正的跨平台。\n\n### 坚持渐进式，坚持组件、插件化，坚持不断的进化。\n\n从设计使用至今，Hy 方案一直保持着其渐进式的特点，而且为了保持这个特点，在框架设计和开发时，一直坚持组件、插件化，使框架本身核心健壮的同时，拥有很强的扩展性。\n\n以 Hy 方案 2.0 版本举例， 整个『大礼包』，它共分为5大部分：\n\n * 前端层 Yo：包括样式、组件及前端路由。\n * 适配层 HySDK：适配和客户端环境，同时也适配微信和 Touch。\n * Native 底层 Hytive：提供定制化 WebView，以API 形式提供 Native 功能，并以自定义插件的形式扩展业务功能。\n * 离线包和热更新机制：提供静态资源离线缓存机制与平台化的资源管理服务。\n * Ykit 工具集：提供定制化的工具方案。\n\n![](https://ww2.sinaimg.cn/large/71c50075jw1fbb972154nj20mn0ck400.jpg)\n\n开发者在使用时，并不需要使用完整的『大礼包』，而是根据实际情况，渐进式地选择 Hy 2.0 的某个部分进行使用，并可随时根据自己的业务场景进行扩展。如果开发者只是做简单的页面，可以只使用 Yo 的样式；当需要一些页面组件时，可以通过 Ykit工具加入相关的组件；当需要开发内嵌到客户端或者微信内的项目时，可以使用 HySDK；最后，开发者觉得项目有必要离线、弱网可用，那可以在热更新平台进行离线包的发布。\n\n和 Hy 1.0 相比，Hy 2.0 保持了渐进式的设计思路，但是对概念进行了简化合并，并同时对代码基于 React 进行重构，在引入业界先进思想的同时，对实现方式进行了一下大幅度优化，提升在设备上的运行效率。\n\n重构不是造轮子，是一个破立而后生、不断进化的过程。\n\n### Hybrid 是不是『银弹』？要优化的路还很长。\n\n业界有这样一套正反逻辑，始终处在争论的最中心。正逻辑：当移动设备性能尤其浏览器性能提高了，Hybrid 开发模式足以代替原生开发模式；反逻辑：当移动设备性能提高了，原生方案和 Hybrid 开发模式的性能同时提高，两个开发模式之间还会有性能差距，而 Hybrid 会永远处于追赶的地位。\n\n![](https://ww2.sinaimg.cn/large/71c50075jw1fbb97q5vh2j20jb0a2taj.jpg)\n\n其实，不论哪个逻辑实现，Hybrid 做好自己就行，它的目标只有一个：使用 Hybrid 开发模式开发的产品能满足用户的体验即可。而 Hy方案的目标也是有一个，就是尽可能的进行优化，将开发体验和用户体验提升到极致，努力成为去哪儿乃至整个集团最优秀的 Hybrid 解决方案，满足公司绝大部分的业务场景，减少业务线的开发成本，至于是不是『银弹』，由时间来评定。\n\n### 对于 React-Native，是兄弟也是竞争对手。\n\n提到 Hybrid 肯定要提到近一段时间的『网红』—— React-Native，而我们团队也根据去哪儿的实际情况推出了 QRN —— 去哪儿基于 React Native 深度定制的移动平台框架，旨在让移动开发者使用 JavaScript 进行移动平台的高效开发；它拥有极高的代码复用率、丰富的 API 扩展、更快的加载速度、完善的部署系统等优秀特性。这时，难免大家会有疑问，Hy 和 QRN 究竟是什么关系？\n\n![](https://ww2.sinaimg.cn/large/71c50075jw1fbb98x0wqbj20iu0c0mzn.jpg)\n\n大家如果喜爱金庸武侠的话，应该听过这样一个说法：金庸武侠中最强的武功不是九阳神功更不是九阴真经，而是双手互搏。双手互搏可以让武者同时使用两种武功，更好的应对实时变化的战局。而老顽童周伯通在桃花岛的山洞里也是靠着双手互搏，模拟对战，来提升对武功的理解和自身实力的。\n\nHybrid 和 QRN 就像两种武功，而团队在使用双手互搏。在应对不同的场景时，推荐业务使用不同的解决方案。例如，在处理多数据多图片的需求时，QRN 处理的比较好；而一些纯的展示需求， 或许 Hy 方案会有更好的表现。在应对不同业务场景的同时，两个方案也是竞争对手。虽然开发框架的同一个团队，但毕竟是两个项目，两个项目之间的重点部分可以时常作比较，例如首屏速度和 List 性能，把相互的优点作为各自目标来优化本身，同时促进两个方案的快速成长。\n\n### 写于最后。\n\n正如标题所讲，Hy 方案的出现不是为了替代谁，更多的是为了『彼此间的美好』，让 Native 和 Web 更关注自身的优势，最终可以形成一个辅助业务团队进行快速开发、高速迭代，而且降低开发、更新成本的一套实用、务实的一体化渐进式解决方案。\n\n回顾这两年走过的路，Hy 的发展史几乎等同于我们团队的发展史，从一个概念化的雏形，走到现在各方面都比较完备的产品，种种的经历也使我们不断地成长。在这期间，公司各个业务线也给予我们的方案和团队极大的肯定和支持，在这里表示下我们的感谢。最后，我们团队将在今后的工作中，继续发扬自己的风格，为业务提供更多更好的移动前端解决方案。\n","source":"_posts/2017-01-01-Hy为了Native与Web彼此间的美好.md","raw":"title: Hy —— 为了 Native 与 Web 彼此间的美好\ndate: 2017-01-01\nauthor: 林洋\ncategory: 大前端技术\ntags: [Hybrid]\nthumbnailImage: https://ws1.sinaimg.cn/large/006cGJIjly1fizanxiax2j308k04twfh.jpg\nthumbnailImagePosition: left\n---\n\n随着移动浪潮的兴起，业务在移动端App 的需求量迅速扩大，应用迭代更新的频率也随之极速攀升，但与此同时纯 Native 的开发和更新成本成为了业务增长难以逾越的瓶颈。因此，引入一种开发更高效、成本更低的解决方案势在必行，而在去哪儿这个解决方案就是 Hy。<!-- more -->\n\nHy 方案是平台事业部移动框架组耗时近两年完成的跨平台移动开发 Hybrid一体化的渐进式解决方案，旨在让开发者使用前端技术开发跨平台的移动应用程序。Hy 方案从设计之初到现在经历了非常多的变化，战场从小型独立客户端到去哪儿大客户端，业务从零个到近百个。一路走来，Hy 经历了无数考验，并获得了璀璨的成果，在公司内受到了大家的肯定。\n\n![](https://ww1.sinaimg.cn/large/71c50075jw1fbb8xvl2ivj20l90ibjx2.jpg)\n\n下面，将从几个方面介绍Hy，包括它的架构、理念以及作为开发者的我们经历的一些心路历程。\n\n### 天下武功，唯快不破。\n\n在当前的移动互联网环境下，iOS和Android上的App已经成了每个互联网产品的标配。如果一个用户端产品并不提供相应 App 版本，几乎会直接定义成一个不完整的产品。而被互联网人尊为铁律的『唯快不破』—— 快速开发、高速迭代、低成本上线，同时也是移动时代每个开发团队所追求的目标。综合以上两点原因，『Native 搭台，Web 唱戏』的 Hybrid 开发模式，以『快』的特点赢得了大家的青睐，并纷纷投入大量开发力量，使这种开发模式迅速走红。\n\nHybrid 开发模式是什么？它兼顾Web App『快』和Native App『全』的一种开发模式；它不依赖版本的实时更新，快速实现跨平台需求，同时，又能通过 Native 提供的Api 调用原生功能，解决了纯 Naitve 原生架构，开发『慢』、发布『慢』、更新『慢』的问题，使迭代速度『快』得可以完全满足产品的需求。\n\n![](https://ww2.sinaimg.cn/large/71c50075jw1fbb91bndggj20no08tgma.jpg)\n\n与此同时，2014、2015年正是去哪儿在移动端发力、业务增长迅猛的一段关键时期，因此公司决定更广泛使用 Hybrid 开发模式，同时我们团队也肩负起 Hybrid 方案架构设计和开发的艰巨使命。当然，我们并没有辜负大家的期望，于2015年初上线了第一个 Hy 方案独立 App（ CRM App），并于年中正式提供 Hy 1.0 完整方案，并且终于在最近完成了自我进化——Hy 2.0 发布，基于最新的 React 进行架构，提供更好的技术、工具、文档、统计支持。\n\n### 不仅仅是混合，更多的其实是融合。\n\n对于 Hybrid 开发模式，有人认为它会把Web App扼杀在摇篮里，有人认为它会把Native App引向一个新阶段。而我们的观点是，Hybrid 开发模式更像萃取两方精华、剔除两方糟粕的一条崭新道路，它不会替代任何一方，只是给开发者更多的选择。而 Hy 方案的架构、设计方向正如文章标题所说，Native 和 Web 都有它们自己的『美好』，也有各自的『痛点』，而 Hy 方案要做的不是纠正他们的错误，而是融合他们的『美好』，用对方的『美好』，解决自己的『痛点』，让它们真正地『在一起』。\n\n![](https://ww4.sinaimg.cn/large/71c50075jw1fbb94ek5ufj20lo0dk0va.jpg)\n\n关于融合，其实要从两方面来谈。第一个方面是 Web 融合 Native，也是大家通常所认知的Hybrid —— Native 给 Web 暴露 API，使 Web 具有调用 Native 功能的能力，最著名的代表就是 Codova（PhoneGap）；第二个方面则是 Native 融合 Web，Web 所具有强大的发布能力和大规模协作的能力是 Native 所不具备的，因此 Native 结合自身的特点对 Web 的优秀能力进行融合是必要的。\n\nHy 方案在融合上进行了很深入的探索和实践。在 Web 融合 Native 方面，适配层不仅仅支持了 iOS 和 Android 的壳，还对微信、Touch 进行了充分适配；在 Native 融合 Web 方面，Hy 方案提供了完善的离线资源更新机制，让业务发布 App 上的业务和发布常规业务一样快速简洁，并方便管理。\n\n### 『磨』平平台差异，真正的跨平台。\n\n其实，在谈到前端Hybrid 或者 HTML5 时，大家第一印象其实是『跨平台』——Wrtie Once，Run Anywhere。C 的跨平台基于它的编译器跨平台，Java 的跨平台基于它的运行时 JVM 跨平台，而前端跨平台其实是基于浏览器。虽然 Google、Apple 等大公司主导的开源浏览器内核 WebKit 占领的绝大大部分移动市场，但是由于开源，手机厂商都会对自己设备上 WebView（浏览器）进行『所谓的调优』，因此最终导致现在并没有像JVM 一样统一、靠谱的前端运行环境，使『跨平台』的成本大大加大。\n\n![](https://ww4.sinaimg.cn/large/71c50075jw1fbb967wpzlj20gp0c0mzy.jpg)\n\n其实不仅仅是跨平台，交互尤其是富交互的一致性、离线状态展示等都是业务经常会遇到的问题。面临这样严峻的问题，作为框架的  Hy 方案必须要在这个方面做出突破，将业务经常遇到的坑填平，真正抹平各个平台的差异。\n\n因此，团队下足了功夫。不论从样式到组件逻辑，还是从整体架构到细节处理，都深入去研究、实践、测试。例如，对于高清屏边框1px 的方案，先后更换了三次方案，最终基本完美的解决了问题。这不仅仅是技术，更重要的是态度，一点点打磨，最终磨平平台差异，实现真正的跨平台。\n\n### 坚持渐进式，坚持组件、插件化，坚持不断的进化。\n\n从设计使用至今，Hy 方案一直保持着其渐进式的特点，而且为了保持这个特点，在框架设计和开发时，一直坚持组件、插件化，使框架本身核心健壮的同时，拥有很强的扩展性。\n\n以 Hy 方案 2.0 版本举例， 整个『大礼包』，它共分为5大部分：\n\n * 前端层 Yo：包括样式、组件及前端路由。\n * 适配层 HySDK：适配和客户端环境，同时也适配微信和 Touch。\n * Native 底层 Hytive：提供定制化 WebView，以API 形式提供 Native 功能，并以自定义插件的形式扩展业务功能。\n * 离线包和热更新机制：提供静态资源离线缓存机制与平台化的资源管理服务。\n * Ykit 工具集：提供定制化的工具方案。\n\n![](https://ww2.sinaimg.cn/large/71c50075jw1fbb972154nj20mn0ck400.jpg)\n\n开发者在使用时，并不需要使用完整的『大礼包』，而是根据实际情况，渐进式地选择 Hy 2.0 的某个部分进行使用，并可随时根据自己的业务场景进行扩展。如果开发者只是做简单的页面，可以只使用 Yo 的样式；当需要一些页面组件时，可以通过 Ykit工具加入相关的组件；当需要开发内嵌到客户端或者微信内的项目时，可以使用 HySDK；最后，开发者觉得项目有必要离线、弱网可用，那可以在热更新平台进行离线包的发布。\n\n和 Hy 1.0 相比，Hy 2.0 保持了渐进式的设计思路，但是对概念进行了简化合并，并同时对代码基于 React 进行重构，在引入业界先进思想的同时，对实现方式进行了一下大幅度优化，提升在设备上的运行效率。\n\n重构不是造轮子，是一个破立而后生、不断进化的过程。\n\n### Hybrid 是不是『银弹』？要优化的路还很长。\n\n业界有这样一套正反逻辑，始终处在争论的最中心。正逻辑：当移动设备性能尤其浏览器性能提高了，Hybrid 开发模式足以代替原生开发模式；反逻辑：当移动设备性能提高了，原生方案和 Hybrid 开发模式的性能同时提高，两个开发模式之间还会有性能差距，而 Hybrid 会永远处于追赶的地位。\n\n![](https://ww2.sinaimg.cn/large/71c50075jw1fbb97q5vh2j20jb0a2taj.jpg)\n\n其实，不论哪个逻辑实现，Hybrid 做好自己就行，它的目标只有一个：使用 Hybrid 开发模式开发的产品能满足用户的体验即可。而 Hy方案的目标也是有一个，就是尽可能的进行优化，将开发体验和用户体验提升到极致，努力成为去哪儿乃至整个集团最优秀的 Hybrid 解决方案，满足公司绝大部分的业务场景，减少业务线的开发成本，至于是不是『银弹』，由时间来评定。\n\n### 对于 React-Native，是兄弟也是竞争对手。\n\n提到 Hybrid 肯定要提到近一段时间的『网红』—— React-Native，而我们团队也根据去哪儿的实际情况推出了 QRN —— 去哪儿基于 React Native 深度定制的移动平台框架，旨在让移动开发者使用 JavaScript 进行移动平台的高效开发；它拥有极高的代码复用率、丰富的 API 扩展、更快的加载速度、完善的部署系统等优秀特性。这时，难免大家会有疑问，Hy 和 QRN 究竟是什么关系？\n\n![](https://ww2.sinaimg.cn/large/71c50075jw1fbb98x0wqbj20iu0c0mzn.jpg)\n\n大家如果喜爱金庸武侠的话，应该听过这样一个说法：金庸武侠中最强的武功不是九阳神功更不是九阴真经，而是双手互搏。双手互搏可以让武者同时使用两种武功，更好的应对实时变化的战局。而老顽童周伯通在桃花岛的山洞里也是靠着双手互搏，模拟对战，来提升对武功的理解和自身实力的。\n\nHybrid 和 QRN 就像两种武功，而团队在使用双手互搏。在应对不同的场景时，推荐业务使用不同的解决方案。例如，在处理多数据多图片的需求时，QRN 处理的比较好；而一些纯的展示需求， 或许 Hy 方案会有更好的表现。在应对不同业务场景的同时，两个方案也是竞争对手。虽然开发框架的同一个团队，但毕竟是两个项目，两个项目之间的重点部分可以时常作比较，例如首屏速度和 List 性能，把相互的优点作为各自目标来优化本身，同时促进两个方案的快速成长。\n\n### 写于最后。\n\n正如标题所讲，Hy 方案的出现不是为了替代谁，更多的是为了『彼此间的美好』，让 Native 和 Web 更关注自身的优势，最终可以形成一个辅助业务团队进行快速开发、高速迭代，而且降低开发、更新成本的一套实用、务实的一体化渐进式解决方案。\n\n回顾这两年走过的路，Hy 的发展史几乎等同于我们团队的发展史，从一个概念化的雏形，走到现在各方面都比较完备的产品，种种的经历也使我们不断地成长。在这期间，公司各个业务线也给予我们的方案和团队极大的肯定和支持，在这里表示下我们的感谢。最后，我们团队将在今后的工作中，继续发扬自己的风格，为业务提供更多更好的移动前端解决方案。\n","slug":"2017-01-01-Hy为了Native与Web彼此间的美好","published":1,"updated":"2018-06-25T03:18:28.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc73000dhxp4p2nuyhpa","content":"<p>随着移动浪潮的兴起，业务在移动端App 的需求量迅速扩大，应用迭代更新的频率也随之极速攀升，但与此同时纯 Native 的开发和更新成本成为了业务增长难以逾越的瓶颈。因此，引入一种开发更高效、成本更低的解决方案势在必行，而在去哪儿这个解决方案就是 Hy。<a id=\"more\"></a></p>\n<p>Hy 方案是平台事业部移动框架组耗时近两年完成的跨平台移动开发 Hybrid一体化的渐进式解决方案，旨在让开发者使用前端技术开发跨平台的移动应用程序。Hy 方案从设计之初到现在经历了非常多的变化，战场从小型独立客户端到去哪儿大客户端，业务从零个到近百个。一路走来，Hy 经历了无数考验，并获得了璀璨的成果，在公司内受到了大家的肯定。</p>\n<p><img src=\"https://ww1.sinaimg.cn/large/71c50075jw1fbb8xvl2ivj20l90ibjx2.jpg\" alt=\"\"></p>\n<p>下面，将从几个方面介绍Hy，包括它的架构、理念以及作为开发者的我们经历的一些心路历程。</p>\n<h3 id=\"天下武功，唯快不破。\"><a href=\"#天下武功，唯快不破。\" class=\"headerlink\" title=\"天下武功，唯快不破。\"></a>天下武功，唯快不破。</h3><p>在当前的移动互联网环境下，iOS和Android上的App已经成了每个互联网产品的标配。如果一个用户端产品并不提供相应 App 版本，几乎会直接定义成一个不完整的产品。而被互联网人尊为铁律的『唯快不破』—— 快速开发、高速迭代、低成本上线，同时也是移动时代每个开发团队所追求的目标。综合以上两点原因，『Native 搭台，Web 唱戏』的 Hybrid 开发模式，以『快』的特点赢得了大家的青睐，并纷纷投入大量开发力量，使这种开发模式迅速走红。</p>\n<p>Hybrid 开发模式是什么？它兼顾Web App『快』和Native App『全』的一种开发模式；它不依赖版本的实时更新，快速实现跨平台需求，同时，又能通过 Native 提供的Api 调用原生功能，解决了纯 Naitve 原生架构，开发『慢』、发布『慢』、更新『慢』的问题，使迭代速度『快』得可以完全满足产品的需求。</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075jw1fbb91bndggj20no08tgma.jpg\" alt=\"\"></p>\n<p>与此同时，2014、2015年正是去哪儿在移动端发力、业务增长迅猛的一段关键时期，因此公司决定更广泛使用 Hybrid 开发模式，同时我们团队也肩负起 Hybrid 方案架构设计和开发的艰巨使命。当然，我们并没有辜负大家的期望，于2015年初上线了第一个 Hy 方案独立 App（ CRM App），并于年中正式提供 Hy 1.0 完整方案，并且终于在最近完成了自我进化——Hy 2.0 发布，基于最新的 React 进行架构，提供更好的技术、工具、文档、统计支持。</p>\n<h3 id=\"不仅仅是混合，更多的其实是融合。\"><a href=\"#不仅仅是混合，更多的其实是融合。\" class=\"headerlink\" title=\"不仅仅是混合，更多的其实是融合。\"></a>不仅仅是混合，更多的其实是融合。</h3><p>对于 Hybrid 开发模式，有人认为它会把Web App扼杀在摇篮里，有人认为它会把Native App引向一个新阶段。而我们的观点是，Hybrid 开发模式更像萃取两方精华、剔除两方糟粕的一条崭新道路，它不会替代任何一方，只是给开发者更多的选择。而 Hy 方案的架构、设计方向正如文章标题所说，Native 和 Web 都有它们自己的『美好』，也有各自的『痛点』，而 Hy 方案要做的不是纠正他们的错误，而是融合他们的『美好』，用对方的『美好』，解决自己的『痛点』，让它们真正地『在一起』。</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/71c50075jw1fbb94ek5ufj20lo0dk0va.jpg\" alt=\"\"></p>\n<p>关于融合，其实要从两方面来谈。第一个方面是 Web 融合 Native，也是大家通常所认知的Hybrid —— Native 给 Web 暴露 API，使 Web 具有调用 Native 功能的能力，最著名的代表就是 Codova（PhoneGap）；第二个方面则是 Native 融合 Web，Web 所具有强大的发布能力和大规模协作的能力是 Native 所不具备的，因此 Native 结合自身的特点对 Web 的优秀能力进行融合是必要的。</p>\n<p>Hy 方案在融合上进行了很深入的探索和实践。在 Web 融合 Native 方面，适配层不仅仅支持了 iOS 和 Android 的壳，还对微信、Touch 进行了充分适配；在 Native 融合 Web 方面，Hy 方案提供了完善的离线资源更新机制，让业务发布 App 上的业务和发布常规业务一样快速简洁，并方便管理。</p>\n<h3 id=\"『磨』平平台差异，真正的跨平台。\"><a href=\"#『磨』平平台差异，真正的跨平台。\" class=\"headerlink\" title=\"『磨』平平台差异，真正的跨平台。\"></a>『磨』平平台差异，真正的跨平台。</h3><p>其实，在谈到前端Hybrid 或者 HTML5 时，大家第一印象其实是『跨平台』——Wrtie Once，Run Anywhere。C 的跨平台基于它的编译器跨平台，Java 的跨平台基于它的运行时 JVM 跨平台，而前端跨平台其实是基于浏览器。虽然 Google、Apple 等大公司主导的开源浏览器内核 WebKit 占领的绝大大部分移动市场，但是由于开源，手机厂商都会对自己设备上 WebView（浏览器）进行『所谓的调优』，因此最终导致现在并没有像JVM 一样统一、靠谱的前端运行环境，使『跨平台』的成本大大加大。</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/71c50075jw1fbb967wpzlj20gp0c0mzy.jpg\" alt=\"\"></p>\n<p>其实不仅仅是跨平台，交互尤其是富交互的一致性、离线状态展示等都是业务经常会遇到的问题。面临这样严峻的问题，作为框架的  Hy 方案必须要在这个方面做出突破，将业务经常遇到的坑填平，真正抹平各个平台的差异。</p>\n<p>因此，团队下足了功夫。不论从样式到组件逻辑，还是从整体架构到细节处理，都深入去研究、实践、测试。例如，对于高清屏边框1px 的方案，先后更换了三次方案，最终基本完美的解决了问题。这不仅仅是技术，更重要的是态度，一点点打磨，最终磨平平台差异，实现真正的跨平台。</p>\n<h3 id=\"坚持渐进式，坚持组件、插件化，坚持不断的进化。\"><a href=\"#坚持渐进式，坚持组件、插件化，坚持不断的进化。\" class=\"headerlink\" title=\"坚持渐进式，坚持组件、插件化，坚持不断的进化。\"></a>坚持渐进式，坚持组件、插件化，坚持不断的进化。</h3><p>从设计使用至今，Hy 方案一直保持着其渐进式的特点，而且为了保持这个特点，在框架设计和开发时，一直坚持组件、插件化，使框架本身核心健壮的同时，拥有很强的扩展性。</p>\n<p>以 Hy 方案 2.0 版本举例， 整个『大礼包』，它共分为5大部分：</p>\n<ul>\n<li>前端层 Yo：包括样式、组件及前端路由。</li>\n<li>适配层 HySDK：适配和客户端环境，同时也适配微信和 Touch。</li>\n<li>Native 底层 Hytive：提供定制化 WebView，以API 形式提供 Native 功能，并以自定义插件的形式扩展业务功能。</li>\n<li>离线包和热更新机制：提供静态资源离线缓存机制与平台化的资源管理服务。</li>\n<li>Ykit 工具集：提供定制化的工具方案。</li>\n</ul>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075jw1fbb972154nj20mn0ck400.jpg\" alt=\"\"></p>\n<p>开发者在使用时，并不需要使用完整的『大礼包』，而是根据实际情况，渐进式地选择 Hy 2.0 的某个部分进行使用，并可随时根据自己的业务场景进行扩展。如果开发者只是做简单的页面，可以只使用 Yo 的样式；当需要一些页面组件时，可以通过 Ykit工具加入相关的组件；当需要开发内嵌到客户端或者微信内的项目时，可以使用 HySDK；最后，开发者觉得项目有必要离线、弱网可用，那可以在热更新平台进行离线包的发布。</p>\n<p>和 Hy 1.0 相比，Hy 2.0 保持了渐进式的设计思路，但是对概念进行了简化合并，并同时对代码基于 React 进行重构，在引入业界先进思想的同时，对实现方式进行了一下大幅度优化，提升在设备上的运行效率。</p>\n<p>重构不是造轮子，是一个破立而后生、不断进化的过程。</p>\n<h3 id=\"Hybrid-是不是『银弹』？要优化的路还很长。\"><a href=\"#Hybrid-是不是『银弹』？要优化的路还很长。\" class=\"headerlink\" title=\"Hybrid 是不是『银弹』？要优化的路还很长。\"></a>Hybrid 是不是『银弹』？要优化的路还很长。</h3><p>业界有这样一套正反逻辑，始终处在争论的最中心。正逻辑：当移动设备性能尤其浏览器性能提高了，Hybrid 开发模式足以代替原生开发模式；反逻辑：当移动设备性能提高了，原生方案和 Hybrid 开发模式的性能同时提高，两个开发模式之间还会有性能差距，而 Hybrid 会永远处于追赶的地位。</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075jw1fbb97q5vh2j20jb0a2taj.jpg\" alt=\"\"></p>\n<p>其实，不论哪个逻辑实现，Hybrid 做好自己就行，它的目标只有一个：使用 Hybrid 开发模式开发的产品能满足用户的体验即可。而 Hy方案的目标也是有一个，就是尽可能的进行优化，将开发体验和用户体验提升到极致，努力成为去哪儿乃至整个集团最优秀的 Hybrid 解决方案，满足公司绝大部分的业务场景，减少业务线的开发成本，至于是不是『银弹』，由时间来评定。</p>\n<h3 id=\"对于-React-Native，是兄弟也是竞争对手。\"><a href=\"#对于-React-Native，是兄弟也是竞争对手。\" class=\"headerlink\" title=\"对于 React-Native，是兄弟也是竞争对手。\"></a>对于 React-Native，是兄弟也是竞争对手。</h3><p>提到 Hybrid 肯定要提到近一段时间的『网红』—— React-Native，而我们团队也根据去哪儿的实际情况推出了 QRN —— 去哪儿基于 React Native 深度定制的移动平台框架，旨在让移动开发者使用 JavaScript 进行移动平台的高效开发；它拥有极高的代码复用率、丰富的 API 扩展、更快的加载速度、完善的部署系统等优秀特性。这时，难免大家会有疑问，Hy 和 QRN 究竟是什么关系？</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075jw1fbb98x0wqbj20iu0c0mzn.jpg\" alt=\"\"></p>\n<p>大家如果喜爱金庸武侠的话，应该听过这样一个说法：金庸武侠中最强的武功不是九阳神功更不是九阴真经，而是双手互搏。双手互搏可以让武者同时使用两种武功，更好的应对实时变化的战局。而老顽童周伯通在桃花岛的山洞里也是靠着双手互搏，模拟对战，来提升对武功的理解和自身实力的。</p>\n<p>Hybrid 和 QRN 就像两种武功，而团队在使用双手互搏。在应对不同的场景时，推荐业务使用不同的解决方案。例如，在处理多数据多图片的需求时，QRN 处理的比较好；而一些纯的展示需求， 或许 Hy 方案会有更好的表现。在应对不同业务场景的同时，两个方案也是竞争对手。虽然开发框架的同一个团队，但毕竟是两个项目，两个项目之间的重点部分可以时常作比较，例如首屏速度和 List 性能，把相互的优点作为各自目标来优化本身，同时促进两个方案的快速成长。</p>\n<h3 id=\"写于最后。\"><a href=\"#写于最后。\" class=\"headerlink\" title=\"写于最后。\"></a>写于最后。</h3><p>正如标题所讲，Hy 方案的出现不是为了替代谁，更多的是为了『彼此间的美好』，让 Native 和 Web 更关注自身的优势，最终可以形成一个辅助业务团队进行快速开发、高速迭代，而且降低开发、更新成本的一套实用、务实的一体化渐进式解决方案。</p>\n<p>回顾这两年走过的路，Hy 的发展史几乎等同于我们团队的发展史，从一个概念化的雏形，走到现在各方面都比较完备的产品，种种的经历也使我们不断地成长。在这期间，公司各个业务线也给予我们的方案和团队极大的肯定和支持，在这里表示下我们的感谢。最后，我们团队将在今后的工作中，继续发扬自己的风格，为业务提供更多更好的移动前端解决方案。</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws1.sinaimg.cn/large/006cGJIjly1fizanxiax2j308k04twfh.jpg","excerpt":"<p>随着移动浪潮的兴起，业务在移动端App 的需求量迅速扩大，应用迭代更新的频率也随之极速攀升，但与此同时纯 Native 的开发和更新成本成为了业务增长难以逾越的瓶颈。因此，引入一种开发更高效、成本更低的解决方案势在必行，而在去哪儿这个解决方案就是 Hy。","more":"</p>\n<p>Hy 方案是平台事业部移动框架组耗时近两年完成的跨平台移动开发 Hybrid一体化的渐进式解决方案，旨在让开发者使用前端技术开发跨平台的移动应用程序。Hy 方案从设计之初到现在经历了非常多的变化，战场从小型独立客户端到去哪儿大客户端，业务从零个到近百个。一路走来，Hy 经历了无数考验，并获得了璀璨的成果，在公司内受到了大家的肯定。</p>\n<p><img src=\"https://ww1.sinaimg.cn/large/71c50075jw1fbb8xvl2ivj20l90ibjx2.jpg\" alt=\"\"></p>\n<p>下面，将从几个方面介绍Hy，包括它的架构、理念以及作为开发者的我们经历的一些心路历程。</p>\n<h3 id=\"天下武功，唯快不破。\"><a href=\"#天下武功，唯快不破。\" class=\"headerlink\" title=\"天下武功，唯快不破。\"></a>天下武功，唯快不破。</h3><p>在当前的移动互联网环境下，iOS和Android上的App已经成了每个互联网产品的标配。如果一个用户端产品并不提供相应 App 版本，几乎会直接定义成一个不完整的产品。而被互联网人尊为铁律的『唯快不破』—— 快速开发、高速迭代、低成本上线，同时也是移动时代每个开发团队所追求的目标。综合以上两点原因，『Native 搭台，Web 唱戏』的 Hybrid 开发模式，以『快』的特点赢得了大家的青睐，并纷纷投入大量开发力量，使这种开发模式迅速走红。</p>\n<p>Hybrid 开发模式是什么？它兼顾Web App『快』和Native App『全』的一种开发模式；它不依赖版本的实时更新，快速实现跨平台需求，同时，又能通过 Native 提供的Api 调用原生功能，解决了纯 Naitve 原生架构，开发『慢』、发布『慢』、更新『慢』的问题，使迭代速度『快』得可以完全满足产品的需求。</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075jw1fbb91bndggj20no08tgma.jpg\" alt=\"\"></p>\n<p>与此同时，2014、2015年正是去哪儿在移动端发力、业务增长迅猛的一段关键时期，因此公司决定更广泛使用 Hybrid 开发模式，同时我们团队也肩负起 Hybrid 方案架构设计和开发的艰巨使命。当然，我们并没有辜负大家的期望，于2015年初上线了第一个 Hy 方案独立 App（ CRM App），并于年中正式提供 Hy 1.0 完整方案，并且终于在最近完成了自我进化——Hy 2.0 发布，基于最新的 React 进行架构，提供更好的技术、工具、文档、统计支持。</p>\n<h3 id=\"不仅仅是混合，更多的其实是融合。\"><a href=\"#不仅仅是混合，更多的其实是融合。\" class=\"headerlink\" title=\"不仅仅是混合，更多的其实是融合。\"></a>不仅仅是混合，更多的其实是融合。</h3><p>对于 Hybrid 开发模式，有人认为它会把Web App扼杀在摇篮里，有人认为它会把Native App引向一个新阶段。而我们的观点是，Hybrid 开发模式更像萃取两方精华、剔除两方糟粕的一条崭新道路，它不会替代任何一方，只是给开发者更多的选择。而 Hy 方案的架构、设计方向正如文章标题所说，Native 和 Web 都有它们自己的『美好』，也有各自的『痛点』，而 Hy 方案要做的不是纠正他们的错误，而是融合他们的『美好』，用对方的『美好』，解决自己的『痛点』，让它们真正地『在一起』。</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/71c50075jw1fbb94ek5ufj20lo0dk0va.jpg\" alt=\"\"></p>\n<p>关于融合，其实要从两方面来谈。第一个方面是 Web 融合 Native，也是大家通常所认知的Hybrid —— Native 给 Web 暴露 API，使 Web 具有调用 Native 功能的能力，最著名的代表就是 Codova（PhoneGap）；第二个方面则是 Native 融合 Web，Web 所具有强大的发布能力和大规模协作的能力是 Native 所不具备的，因此 Native 结合自身的特点对 Web 的优秀能力进行融合是必要的。</p>\n<p>Hy 方案在融合上进行了很深入的探索和实践。在 Web 融合 Native 方面，适配层不仅仅支持了 iOS 和 Android 的壳，还对微信、Touch 进行了充分适配；在 Native 融合 Web 方面，Hy 方案提供了完善的离线资源更新机制，让业务发布 App 上的业务和发布常规业务一样快速简洁，并方便管理。</p>\n<h3 id=\"『磨』平平台差异，真正的跨平台。\"><a href=\"#『磨』平平台差异，真正的跨平台。\" class=\"headerlink\" title=\"『磨』平平台差异，真正的跨平台。\"></a>『磨』平平台差异，真正的跨平台。</h3><p>其实，在谈到前端Hybrid 或者 HTML5 时，大家第一印象其实是『跨平台』——Wrtie Once，Run Anywhere。C 的跨平台基于它的编译器跨平台，Java 的跨平台基于它的运行时 JVM 跨平台，而前端跨平台其实是基于浏览器。虽然 Google、Apple 等大公司主导的开源浏览器内核 WebKit 占领的绝大大部分移动市场，但是由于开源，手机厂商都会对自己设备上 WebView（浏览器）进行『所谓的调优』，因此最终导致现在并没有像JVM 一样统一、靠谱的前端运行环境，使『跨平台』的成本大大加大。</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/71c50075jw1fbb967wpzlj20gp0c0mzy.jpg\" alt=\"\"></p>\n<p>其实不仅仅是跨平台，交互尤其是富交互的一致性、离线状态展示等都是业务经常会遇到的问题。面临这样严峻的问题，作为框架的  Hy 方案必须要在这个方面做出突破，将业务经常遇到的坑填平，真正抹平各个平台的差异。</p>\n<p>因此，团队下足了功夫。不论从样式到组件逻辑，还是从整体架构到细节处理，都深入去研究、实践、测试。例如，对于高清屏边框1px 的方案，先后更换了三次方案，最终基本完美的解决了问题。这不仅仅是技术，更重要的是态度，一点点打磨，最终磨平平台差异，实现真正的跨平台。</p>\n<h3 id=\"坚持渐进式，坚持组件、插件化，坚持不断的进化。\"><a href=\"#坚持渐进式，坚持组件、插件化，坚持不断的进化。\" class=\"headerlink\" title=\"坚持渐进式，坚持组件、插件化，坚持不断的进化。\"></a>坚持渐进式，坚持组件、插件化，坚持不断的进化。</h3><p>从设计使用至今，Hy 方案一直保持着其渐进式的特点，而且为了保持这个特点，在框架设计和开发时，一直坚持组件、插件化，使框架本身核心健壮的同时，拥有很强的扩展性。</p>\n<p>以 Hy 方案 2.0 版本举例， 整个『大礼包』，它共分为5大部分：</p>\n<ul>\n<li>前端层 Yo：包括样式、组件及前端路由。</li>\n<li>适配层 HySDK：适配和客户端环境，同时也适配微信和 Touch。</li>\n<li>Native 底层 Hytive：提供定制化 WebView，以API 形式提供 Native 功能，并以自定义插件的形式扩展业务功能。</li>\n<li>离线包和热更新机制：提供静态资源离线缓存机制与平台化的资源管理服务。</li>\n<li>Ykit 工具集：提供定制化的工具方案。</li>\n</ul>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075jw1fbb972154nj20mn0ck400.jpg\" alt=\"\"></p>\n<p>开发者在使用时，并不需要使用完整的『大礼包』，而是根据实际情况，渐进式地选择 Hy 2.0 的某个部分进行使用，并可随时根据自己的业务场景进行扩展。如果开发者只是做简单的页面，可以只使用 Yo 的样式；当需要一些页面组件时，可以通过 Ykit工具加入相关的组件；当需要开发内嵌到客户端或者微信内的项目时，可以使用 HySDK；最后，开发者觉得项目有必要离线、弱网可用，那可以在热更新平台进行离线包的发布。</p>\n<p>和 Hy 1.0 相比，Hy 2.0 保持了渐进式的设计思路，但是对概念进行了简化合并，并同时对代码基于 React 进行重构，在引入业界先进思想的同时，对实现方式进行了一下大幅度优化，提升在设备上的运行效率。</p>\n<p>重构不是造轮子，是一个破立而后生、不断进化的过程。</p>\n<h3 id=\"Hybrid-是不是『银弹』？要优化的路还很长。\"><a href=\"#Hybrid-是不是『银弹』？要优化的路还很长。\" class=\"headerlink\" title=\"Hybrid 是不是『银弹』？要优化的路还很长。\"></a>Hybrid 是不是『银弹』？要优化的路还很长。</h3><p>业界有这样一套正反逻辑，始终处在争论的最中心。正逻辑：当移动设备性能尤其浏览器性能提高了，Hybrid 开发模式足以代替原生开发模式；反逻辑：当移动设备性能提高了，原生方案和 Hybrid 开发模式的性能同时提高，两个开发模式之间还会有性能差距，而 Hybrid 会永远处于追赶的地位。</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075jw1fbb97q5vh2j20jb0a2taj.jpg\" alt=\"\"></p>\n<p>其实，不论哪个逻辑实现，Hybrid 做好自己就行，它的目标只有一个：使用 Hybrid 开发模式开发的产品能满足用户的体验即可。而 Hy方案的目标也是有一个，就是尽可能的进行优化，将开发体验和用户体验提升到极致，努力成为去哪儿乃至整个集团最优秀的 Hybrid 解决方案，满足公司绝大部分的业务场景，减少业务线的开发成本，至于是不是『银弹』，由时间来评定。</p>\n<h3 id=\"对于-React-Native，是兄弟也是竞争对手。\"><a href=\"#对于-React-Native，是兄弟也是竞争对手。\" class=\"headerlink\" title=\"对于 React-Native，是兄弟也是竞争对手。\"></a>对于 React-Native，是兄弟也是竞争对手。</h3><p>提到 Hybrid 肯定要提到近一段时间的『网红』—— React-Native，而我们团队也根据去哪儿的实际情况推出了 QRN —— 去哪儿基于 React Native 深度定制的移动平台框架，旨在让移动开发者使用 JavaScript 进行移动平台的高效开发；它拥有极高的代码复用率、丰富的 API 扩展、更快的加载速度、完善的部署系统等优秀特性。这时，难免大家会有疑问，Hy 和 QRN 究竟是什么关系？</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/71c50075jw1fbb98x0wqbj20iu0c0mzn.jpg\" alt=\"\"></p>\n<p>大家如果喜爱金庸武侠的话，应该听过这样一个说法：金庸武侠中最强的武功不是九阳神功更不是九阴真经，而是双手互搏。双手互搏可以让武者同时使用两种武功，更好的应对实时变化的战局。而老顽童周伯通在桃花岛的山洞里也是靠着双手互搏，模拟对战，来提升对武功的理解和自身实力的。</p>\n<p>Hybrid 和 QRN 就像两种武功，而团队在使用双手互搏。在应对不同的场景时，推荐业务使用不同的解决方案。例如，在处理多数据多图片的需求时，QRN 处理的比较好；而一些纯的展示需求， 或许 Hy 方案会有更好的表现。在应对不同业务场景的同时，两个方案也是竞争对手。虽然开发框架的同一个团队，但毕竟是两个项目，两个项目之间的重点部分可以时常作比较，例如首屏速度和 List 性能，把相互的优点作为各自目标来优化本身，同时促进两个方案的快速成长。</p>\n<h3 id=\"写于最后。\"><a href=\"#写于最后。\" class=\"headerlink\" title=\"写于最后。\"></a>写于最后。</h3><p>正如标题所讲，Hy 方案的出现不是为了替代谁，更多的是为了『彼此间的美好』，让 Native 和 Web 更关注自身的优势，最终可以形成一个辅助业务团队进行快速开发、高速迭代，而且降低开发、更新成本的一套实用、务实的一体化渐进式解决方案。</p>\n<p>回顾这两年走过的路，Hy 的发展史几乎等同于我们团队的发展史，从一个概念化的雏形，走到现在各方面都比较完备的产品，种种的经历也使我们不断地成长。在这期间，公司各个业务线也给予我们的方案和团队极大的肯定和支持，在这里表示下我们的感谢。最后，我们团队将在今后的工作中，继续发扬自己的风格，为业务提供更多更好的移动前端解决方案。</p>"},{"title":"移动混合开发中的 JSBridge","date":"2017-04-25T16:00:00.000Z","thumbnailImage":"https://wx1.sinaimg.cn/mw690/71c50075ly1feyxr21wdkj20n905n74c.jpg","_content":"\n【导读】关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。那么，JSBridge 到底是什么？它的出现是为了什么？它究竟是怎么实现的？在这篇文章中，会在移动混合开发的范畴内，将给大家带来 JSBridge 的深入剖析。<!-- more -->\n\n![](https://ws1.sinaimg.cn/large/006cGJIjly1fiza4vwhtkj30b40640sz.jpg)\n\n# 前言\n\n有些童鞋听到 JSBridge 这个名词，就是觉得非常高上大，有了它 Web 和 Native 可以进行交互，就像『进化药水』，让 Web 摇身一变，成为移动战场的『上将一名』。其实并非如此，JSBridge 其实真是一个很简单的东西，更多的是一种形式、一种思想。\n\n# JSBridge 的起源\n\n为什么是 JSBridge ？而不是 PythonBridge 或是 RubyBridge ？\n\n当然不是因为 JavaScript 语言高人一等（虽然斯坦福大学已经把算法导论的语言从 Java 改成 JavaScript，小得意一下，嘻嘻），主要的原因还是因为 JavaScript 主要载体 Web 是当前世界上的 **最易编写** 、 **最易维护** 、 **最易部署** 的 UI 构建方式。工程师可以用很简单的 HTML 标签和 CSS 样式快速的构建出一个页面，并且在服务端部署后，用户不需要主动更新，就能看到最新的 UI 展现。\n\n因此，**开发维护成本** 和 **更新成本** 较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。因此，基于上面种种原因，JSBridge 应运而生。\n\nPhoneGap（Codova 的前身）作为 Hybrid 鼻祖框架，应该是最先被开发者广泛认知的 JSBridge 的应用场景；而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现，主要用途是在网页中通过 JSBridge 设置分享内容。\n\n![](https://wx2.sinaimg.cn/mw690/71c50075ly1feyt6lzpb5j208c03mq4d.jpg)\n\n移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上：\n* 基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案\n* 非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native\n\n【注】：微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。\n\n# JSBridge 的用途\n\nJSBridge 简单来讲，主要是 **给 JavaScript 提供调用 Native 功能的接口**，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。\n\n既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 **构建 Native 和非 Native 间消息通信的通道**，而且是 **双向通信的通道**。\n\n![](https://wx1.sinaimg.cn/mw690/71c50075ly1feyxr21wdkj20n905n74c.jpg)\n\n所谓 **双向通信的通道**:\n* JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。\n* Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。\n\n这里有些同学有疑问了：<u>*消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？*</u>\n对于这个问题，在下一节里会给出解释。\n\n# JSBridge 的实现原理\n\nJavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的  Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。如此一来我们可以按照通常的 RPC 方式来进行设计和实现。\n\n![](https://wx4.sinaimg.cn/mw690/71c50075ly1fez44p2jolj20a409dwet.jpg)\n\n在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：**通信调用（Native 与 JS 通信）** 和 **句柄解析调用**。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）\n\n通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 **Hybrid 方案** 为案例从这几点来剖析 JSBridge 的实现原理。\n\n## JSBridge 的通信原理\n\nHybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。\n\n### JavaScript 调用 Native\n\nJavaScript 调用 Native 的方式，主要有两种：**注入 API** 和 **拦截 URL SCHEME**。\n\n#### 注入API\n\n注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。\n\n对于 iOS 的 UIWebView，实例如下：\n\n```\nJSContext *context = [uiWebView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n\ncontext[@\"postBridgeMessage\"] = ^(NSArray<NSArray *> *calls) {\n    // Native 逻辑\n};\n\n```\n\n前端调用方式：\n\n```js\nwindow.postBridgeMessage(message);\n```\n\n对于 iOS 的 WKWebView 可以用以下方式：\n\n```\n@interface WKWebVIewVC ()<WKScriptMessageHandler>\n\n@implementation WKWebVIewVC\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];\n    configuration.userContentController = [[WKUserContentController alloc] init];\n    WKUserContentController *userCC = configuration.userContentController;\n    // 注入对象，前端调用其方法时，Native 可以捕获到\n    [userCC addScriptMessageHandler:self name:@\"nativeBridge\"];\n\n    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];\n\n    // TODO 显示 WebView\n}\n\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {\n    if ([message.name isEqualToString:@\"nativeBridge\"]) {\n        NSLog(@\"前端传递的数据 %@: \",message.body);\n        // Native 逻辑\n    }\n}\n```\n\n前端调用方式：\n\n```js\nwindow.webkit.messageHandlers.nativeBridge.postMessage(message);\n```\n\n对于 Android 可以采用下面的方式：\n\n```java\npublic class JavaScriptInterfaceDemoActivity extends Activity {\n\tprivate WebView Wv;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Wv = (WebView)findViewById(R.id.webView);\n        final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);\n\n        Wv.getSettings().setJavaScriptEnabled(true);\n        Wv.addJavascriptInterface(myJavaScriptInterface, \"nativeBridge\");\n\n        // TODO 显示 WebView\n\n    }\n\n    public class JavaScriptInterface {\n         Context mContext;\n\n         JavaScriptInterface(Context c) {\n             mContext = c;\n         }\n\n         public void postMessage(String webMessage){\n             // Native 逻辑\n         }\n     }\n}\n```\n\n前端调用方式：\n\n```js\nwindow.nativeBridge.postMessage(message);\n```\n\n在 4.2 之前，Android 注入 JavaScript 对象的接口是 addJavascriptInterface，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 @JavascriptInterface（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是 **有兼容性问题的**。（4.2 之前很多方案都采用拦截 prompt 的方式来实现，因为篇幅有限，这里就不展开了。）\n\n#### 拦截 URL SCHEME\n\n先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=[https://ymfe.org](https://ymfe.org)，protocol 是 qunarhy，host 则是 hy。\n\n拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。\n\n在时间过程中，这种方式有一定的 **缺陷**：\n* 使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。\n* 创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。\n\n但是之前为什么很多方案使用这种方式呢？因为它 **支持 iOS6**。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 **并不优雅** 的方式。\n\n【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。\n\n【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。\n\n### Native 调用 JavaScript\n\n相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。\n\nNative 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）\n\n对于 iOS 的 UIWebView，示例如下：\n\n```\nresult = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString];\n```\n\n对于 iOS 的 WKWebView，示例如下：\n\n```\n[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler];\n\n```\n\n对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现：\n\n```java\nwebView.loadUrl(\"javascript:\" + javaScriptString);\n```\n\n而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现：\n\n```java\nwebView.evaluateJavascript(javaScriptString, new ValueCallback<String>() {\n    @Override\n    public void onReceiveValue(String value) {\n\n    }\n});\n```\n\n【注】：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。\n\n### 通信原理小总结\n\n通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，笔者推荐的实现方式如下：\n* JavaScript 调用 Native 推荐使用 **注入 API** 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。\n* Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。\n\n对于其他方式，诸如 React Native、微信小程序 的通信方式都与上描述的近似，并根据实际情况进行优化。\n\n以 React Native 的 iOS 端举例：JavaScript 运行在 JSCore 中，实际上可以与上面的方式一样，利用注入 API 来实现 JavaScript 调用 Native 功能。不过 React Native 并没有设计成 JavaScript 直接调用 Object-C，而是 **为了与 Native 开发里事件响应机制一致**，设计成 **需要在 Object-C 去调 JavaScript 时才通过返回值触发调用**。原理基本一样，只是实现方式不同。\n\n当然不仅仅 iOS 和 Android，其他手机操作系统也用相应的 API，例如 WMP（Win 10）下可以用 window.external.notify 和 WebView.InvokeScript/InvokeScriptAsync 进行双向通信。其他系统也类似。\n\n## JSBridge 接口实现\n\n从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：**调用 Native（给 Native 发消息）** 和 **接被 Native 调用（接收 Native 消息）**。因此，JSBridge 可以设计如下：\n\n```js\nwindow.JSBridge = {\n    // 调用 Native\n    invoke: function(msg) {\n        // 判断环境，获取不同的 nativeBridge\n        nativeBridge.postMessage(msg);\n    },\n    receiveMessage: function(msg) {\n        // 处理 msg\n    }\n};\n```\n\n在上面的文章中，提到过 RPC 中有一个非常重要的环节是 **句柄解析调用** ，这点在 JSBridge 中体现为 **句柄与功能对应关系**。同时，我们将句柄抽象为 **桥名（BridgeName）**，最终演化为 **一个 BridgeName 对应一个 Native 功能或者一类 Native 消息**。 基于此点，JSBridge 的实现可以优化为如下：\n\n```js\nwindow.JSBridge = {\n    // 调用 Native\n    invoke: function(bridgeName, data) {\n        // 判断环境，获取不同的 nativeBridge\n        nativeBridge.postMessage({\n            bridgeName: bridgeName,\n            data: data || {}\n        });\n    },\n    receiveMessage: function(msg) {\n        var bridgeName = msg.bridgeName,\n            data = msg.data || {};\n        // 具体逻辑\n    }\n};\n```\n\nJSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：**消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？**\n\n对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释：\n\n> 当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 **当前页面唯一** 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。\n\n由此可见，callback 参数这个 **唯一标识** 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。\n\n```js\n(function () {\n    var id = 0,\n        callbacks = {};\n\n    window.JSBridge = {\n        // 调用 Native\n        invoke: function(bridgeName, callback, data) {\n            // 判断环境，获取不同的 nativeBridge\n            var thisId = id ++; // 获取唯一 id\n            callbacks[thisId] = callback; // 存储 Callback\n            nativeBridge.postMessage({\n                bridgeName: bridgeName,\n                data: data || {},\n                callbackId: thisId // 传到 Native 端\n            });\n        },\n        receiveMessage: function(msg) {\n            var bridgeName = msg.bridgeName,\n                data = msg.data || {},\n                callbackId = msg.callbackId; // Native 将 callbackId 原封不动传回\n            // 具体逻辑\n            // bridgeName 和 callbackId 不会同时存在\n            if (callbackId) {\n                if (callbacks[callbackId]) { // 找到相应句柄\n                    callbacks[callbackId](msg.data); // 执行调用\n                }\n            } else if (bridgeName) {\n\n            }\n        }\n    };\n})();\n```\n\n最后用同样的方式加上 Native 调用的回调逻辑，同时对代码进行一些优化，就大概实现了一个功能比较完整的 JSBridge。其代码如下：\n\n```js\n(function () {\n    var id = 0,\n        callbacks = {},\n        registerFuncs = {};\n\n    window.JSBridge = {\n        // 调用 Native\n        invoke: function(bridgeName, callback, data) {\n            // 判断环境，获取不同的 nativeBridge\n            var thisId = id ++; // 获取唯一 id\n            callbacks[thisId] = callback; // 存储 Callback\n            nativeBridge.postMessage({\n                bridgeName: bridgeName,\n                data: data || {},\n                callbackId: thisId // 传到 Native 端\n            });\n        },\n        receiveMessage: function(msg) {\n            var bridgeName = msg.bridgeName,\n                data = msg.data || {},\n                callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回\n                responstId = msg.responstId;\n            // 具体逻辑\n            // bridgeName 和 callbackId 不会同时存在\n            if (callbackId) {\n                if (callbacks[callbackId]) { // 找到相应句柄\n                    callbacks[callbackId](msg.data); // 执行调用\n                }\n            } else if (bridgeName) {\n                if (registerFuncs[bridgeName]) { // 通过 bridgeName 找到句柄\n                    var ret = {},\n                        flag = false;\n                    registerFuncs[bridgeName].forEach(function(callback) => {\n                        callback(data, function(r) {\n                            flag = true;\n                            ret = Object.assign(ret, r);\n                        });\n                    });\n                    if (flag) {\n                        nativeBridge.postMessage({ // 回调 Native\n                            responstId: responstId,\n                            ret: ret\n                        });\n                    }\n                }\n            }\n        },\n        register: function(bridgeName, callback) {\n            if (!registerFuncs[bridgeName])  {\n                registerFuncs[bridgeName] = [];\n            }\n            registerFuncs[bridgeName].push(callback); // 存储回调\n        }\n    };\n})();\n```\n\n当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。\n\n【注】：这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 => 解析参数，拿到 bridgeName、data 和 callbackId => 根据 bridgeName 找到功能方法，以 data 为参数执行 => 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。\n\n# JSBridge 如何引用\n\n对于 JSBridge 的引用，常用有两种方式，各有利弊。\n\n## 由 Native 端进行注入\n\n注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。\n\n它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。\n\n## 由 JavaScript 端引用\n\n直接与 JavaScript 一起执行。\n\n与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。\n\n# 总结\n\n这篇文章主要剖析的 JSBridge 的实现及应用，包括 **JavaScript 与 Native 间的通信原理**，**JSBridge 的 JavaScript 端实现** 以及 **引用方式**，并给出了一些示例代码，希望对读者有一定的帮助。\n","source":"_posts/2017-04-26-混合开发中的JSBridge.md","raw":"title: 移动混合开发中的 JSBridge\ndate: 2017-04-26\ncategory: 大前端技术\ntags: [Mobile, Bridge, Hybrid]\nthumbnailImage: https://wx1.sinaimg.cn/mw690/71c50075ly1feyxr21wdkj20n905n74c.jpg\n---\n\n【导读】关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。那么，JSBridge 到底是什么？它的出现是为了什么？它究竟是怎么实现的？在这篇文章中，会在移动混合开发的范畴内，将给大家带来 JSBridge 的深入剖析。<!-- more -->\n\n![](https://ws1.sinaimg.cn/large/006cGJIjly1fiza4vwhtkj30b40640sz.jpg)\n\n# 前言\n\n有些童鞋听到 JSBridge 这个名词，就是觉得非常高上大，有了它 Web 和 Native 可以进行交互，就像『进化药水』，让 Web 摇身一变，成为移动战场的『上将一名』。其实并非如此，JSBridge 其实真是一个很简单的东西，更多的是一种形式、一种思想。\n\n# JSBridge 的起源\n\n为什么是 JSBridge ？而不是 PythonBridge 或是 RubyBridge ？\n\n当然不是因为 JavaScript 语言高人一等（虽然斯坦福大学已经把算法导论的语言从 Java 改成 JavaScript，小得意一下，嘻嘻），主要的原因还是因为 JavaScript 主要载体 Web 是当前世界上的 **最易编写** 、 **最易维护** 、 **最易部署** 的 UI 构建方式。工程师可以用很简单的 HTML 标签和 CSS 样式快速的构建出一个页面，并且在服务端部署后，用户不需要主动更新，就能看到最新的 UI 展现。\n\n因此，**开发维护成本** 和 **更新成本** 较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。因此，基于上面种种原因，JSBridge 应运而生。\n\nPhoneGap（Codova 的前身）作为 Hybrid 鼻祖框架，应该是最先被开发者广泛认知的 JSBridge 的应用场景；而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现，主要用途是在网页中通过 JSBridge 设置分享内容。\n\n![](https://wx2.sinaimg.cn/mw690/71c50075ly1feyt6lzpb5j208c03mq4d.jpg)\n\n移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上：\n* 基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案\n* 非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native\n\n【注】：微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。\n\n# JSBridge 的用途\n\nJSBridge 简单来讲，主要是 **给 JavaScript 提供调用 Native 功能的接口**，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。\n\n既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 **构建 Native 和非 Native 间消息通信的通道**，而且是 **双向通信的通道**。\n\n![](https://wx1.sinaimg.cn/mw690/71c50075ly1feyxr21wdkj20n905n74c.jpg)\n\n所谓 **双向通信的通道**:\n* JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。\n* Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。\n\n这里有些同学有疑问了：<u>*消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？*</u>\n对于这个问题，在下一节里会给出解释。\n\n# JSBridge 的实现原理\n\nJavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的  Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。如此一来我们可以按照通常的 RPC 方式来进行设计和实现。\n\n![](https://wx4.sinaimg.cn/mw690/71c50075ly1fez44p2jolj20a409dwet.jpg)\n\n在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：**通信调用（Native 与 JS 通信）** 和 **句柄解析调用**。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）\n\n通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 **Hybrid 方案** 为案例从这几点来剖析 JSBridge 的实现原理。\n\n## JSBridge 的通信原理\n\nHybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。\n\n### JavaScript 调用 Native\n\nJavaScript 调用 Native 的方式，主要有两种：**注入 API** 和 **拦截 URL SCHEME**。\n\n#### 注入API\n\n注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。\n\n对于 iOS 的 UIWebView，实例如下：\n\n```\nJSContext *context = [uiWebView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n\ncontext[@\"postBridgeMessage\"] = ^(NSArray<NSArray *> *calls) {\n    // Native 逻辑\n};\n\n```\n\n前端调用方式：\n\n```js\nwindow.postBridgeMessage(message);\n```\n\n对于 iOS 的 WKWebView 可以用以下方式：\n\n```\n@interface WKWebVIewVC ()<WKScriptMessageHandler>\n\n@implementation WKWebVIewVC\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];\n    configuration.userContentController = [[WKUserContentController alloc] init];\n    WKUserContentController *userCC = configuration.userContentController;\n    // 注入对象，前端调用其方法时，Native 可以捕获到\n    [userCC addScriptMessageHandler:self name:@\"nativeBridge\"];\n\n    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];\n\n    // TODO 显示 WebView\n}\n\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {\n    if ([message.name isEqualToString:@\"nativeBridge\"]) {\n        NSLog(@\"前端传递的数据 %@: \",message.body);\n        // Native 逻辑\n    }\n}\n```\n\n前端调用方式：\n\n```js\nwindow.webkit.messageHandlers.nativeBridge.postMessage(message);\n```\n\n对于 Android 可以采用下面的方式：\n\n```java\npublic class JavaScriptInterfaceDemoActivity extends Activity {\n\tprivate WebView Wv;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Wv = (WebView)findViewById(R.id.webView);\n        final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);\n\n        Wv.getSettings().setJavaScriptEnabled(true);\n        Wv.addJavascriptInterface(myJavaScriptInterface, \"nativeBridge\");\n\n        // TODO 显示 WebView\n\n    }\n\n    public class JavaScriptInterface {\n         Context mContext;\n\n         JavaScriptInterface(Context c) {\n             mContext = c;\n         }\n\n         public void postMessage(String webMessage){\n             // Native 逻辑\n         }\n     }\n}\n```\n\n前端调用方式：\n\n```js\nwindow.nativeBridge.postMessage(message);\n```\n\n在 4.2 之前，Android 注入 JavaScript 对象的接口是 addJavascriptInterface，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 @JavascriptInterface（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是 **有兼容性问题的**。（4.2 之前很多方案都采用拦截 prompt 的方式来实现，因为篇幅有限，这里就不展开了。）\n\n#### 拦截 URL SCHEME\n\n先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=[https://ymfe.org](https://ymfe.org)，protocol 是 qunarhy，host 则是 hy。\n\n拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。\n\n在时间过程中，这种方式有一定的 **缺陷**：\n* 使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。\n* 创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。\n\n但是之前为什么很多方案使用这种方式呢？因为它 **支持 iOS6**。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 **并不优雅** 的方式。\n\n【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。\n\n【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。\n\n### Native 调用 JavaScript\n\n相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。\n\nNative 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）\n\n对于 iOS 的 UIWebView，示例如下：\n\n```\nresult = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString];\n```\n\n对于 iOS 的 WKWebView，示例如下：\n\n```\n[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler];\n\n```\n\n对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现：\n\n```java\nwebView.loadUrl(\"javascript:\" + javaScriptString);\n```\n\n而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现：\n\n```java\nwebView.evaluateJavascript(javaScriptString, new ValueCallback<String>() {\n    @Override\n    public void onReceiveValue(String value) {\n\n    }\n});\n```\n\n【注】：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。\n\n### 通信原理小总结\n\n通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，笔者推荐的实现方式如下：\n* JavaScript 调用 Native 推荐使用 **注入 API** 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。\n* Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。\n\n对于其他方式，诸如 React Native、微信小程序 的通信方式都与上描述的近似，并根据实际情况进行优化。\n\n以 React Native 的 iOS 端举例：JavaScript 运行在 JSCore 中，实际上可以与上面的方式一样，利用注入 API 来实现 JavaScript 调用 Native 功能。不过 React Native 并没有设计成 JavaScript 直接调用 Object-C，而是 **为了与 Native 开发里事件响应机制一致**，设计成 **需要在 Object-C 去调 JavaScript 时才通过返回值触发调用**。原理基本一样，只是实现方式不同。\n\n当然不仅仅 iOS 和 Android，其他手机操作系统也用相应的 API，例如 WMP（Win 10）下可以用 window.external.notify 和 WebView.InvokeScript/InvokeScriptAsync 进行双向通信。其他系统也类似。\n\n## JSBridge 接口实现\n\n从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：**调用 Native（给 Native 发消息）** 和 **接被 Native 调用（接收 Native 消息）**。因此，JSBridge 可以设计如下：\n\n```js\nwindow.JSBridge = {\n    // 调用 Native\n    invoke: function(msg) {\n        // 判断环境，获取不同的 nativeBridge\n        nativeBridge.postMessage(msg);\n    },\n    receiveMessage: function(msg) {\n        // 处理 msg\n    }\n};\n```\n\n在上面的文章中，提到过 RPC 中有一个非常重要的环节是 **句柄解析调用** ，这点在 JSBridge 中体现为 **句柄与功能对应关系**。同时，我们将句柄抽象为 **桥名（BridgeName）**，最终演化为 **一个 BridgeName 对应一个 Native 功能或者一类 Native 消息**。 基于此点，JSBridge 的实现可以优化为如下：\n\n```js\nwindow.JSBridge = {\n    // 调用 Native\n    invoke: function(bridgeName, data) {\n        // 判断环境，获取不同的 nativeBridge\n        nativeBridge.postMessage({\n            bridgeName: bridgeName,\n            data: data || {}\n        });\n    },\n    receiveMessage: function(msg) {\n        var bridgeName = msg.bridgeName,\n            data = msg.data || {};\n        // 具体逻辑\n    }\n};\n```\n\nJSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：**消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？**\n\n对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释：\n\n> 当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 **当前页面唯一** 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。\n\n由此可见，callback 参数这个 **唯一标识** 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。\n\n```js\n(function () {\n    var id = 0,\n        callbacks = {};\n\n    window.JSBridge = {\n        // 调用 Native\n        invoke: function(bridgeName, callback, data) {\n            // 判断环境，获取不同的 nativeBridge\n            var thisId = id ++; // 获取唯一 id\n            callbacks[thisId] = callback; // 存储 Callback\n            nativeBridge.postMessage({\n                bridgeName: bridgeName,\n                data: data || {},\n                callbackId: thisId // 传到 Native 端\n            });\n        },\n        receiveMessage: function(msg) {\n            var bridgeName = msg.bridgeName,\n                data = msg.data || {},\n                callbackId = msg.callbackId; // Native 将 callbackId 原封不动传回\n            // 具体逻辑\n            // bridgeName 和 callbackId 不会同时存在\n            if (callbackId) {\n                if (callbacks[callbackId]) { // 找到相应句柄\n                    callbacks[callbackId](msg.data); // 执行调用\n                }\n            } else if (bridgeName) {\n\n            }\n        }\n    };\n})();\n```\n\n最后用同样的方式加上 Native 调用的回调逻辑，同时对代码进行一些优化，就大概实现了一个功能比较完整的 JSBridge。其代码如下：\n\n```js\n(function () {\n    var id = 0,\n        callbacks = {},\n        registerFuncs = {};\n\n    window.JSBridge = {\n        // 调用 Native\n        invoke: function(bridgeName, callback, data) {\n            // 判断环境，获取不同的 nativeBridge\n            var thisId = id ++; // 获取唯一 id\n            callbacks[thisId] = callback; // 存储 Callback\n            nativeBridge.postMessage({\n                bridgeName: bridgeName,\n                data: data || {},\n                callbackId: thisId // 传到 Native 端\n            });\n        },\n        receiveMessage: function(msg) {\n            var bridgeName = msg.bridgeName,\n                data = msg.data || {},\n                callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回\n                responstId = msg.responstId;\n            // 具体逻辑\n            // bridgeName 和 callbackId 不会同时存在\n            if (callbackId) {\n                if (callbacks[callbackId]) { // 找到相应句柄\n                    callbacks[callbackId](msg.data); // 执行调用\n                }\n            } else if (bridgeName) {\n                if (registerFuncs[bridgeName]) { // 通过 bridgeName 找到句柄\n                    var ret = {},\n                        flag = false;\n                    registerFuncs[bridgeName].forEach(function(callback) => {\n                        callback(data, function(r) {\n                            flag = true;\n                            ret = Object.assign(ret, r);\n                        });\n                    });\n                    if (flag) {\n                        nativeBridge.postMessage({ // 回调 Native\n                            responstId: responstId,\n                            ret: ret\n                        });\n                    }\n                }\n            }\n        },\n        register: function(bridgeName, callback) {\n            if (!registerFuncs[bridgeName])  {\n                registerFuncs[bridgeName] = [];\n            }\n            registerFuncs[bridgeName].push(callback); // 存储回调\n        }\n    };\n})();\n```\n\n当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。\n\n【注】：这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 => 解析参数，拿到 bridgeName、data 和 callbackId => 根据 bridgeName 找到功能方法，以 data 为参数执行 => 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。\n\n# JSBridge 如何引用\n\n对于 JSBridge 的引用，常用有两种方式，各有利弊。\n\n## 由 Native 端进行注入\n\n注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。\n\n它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。\n\n## 由 JavaScript 端引用\n\n直接与 JavaScript 一起执行。\n\n与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。\n\n# 总结\n\n这篇文章主要剖析的 JSBridge 的实现及应用，包括 **JavaScript 与 Native 间的通信原理**，**JSBridge 的 JavaScript 端实现** 以及 **引用方式**，并给出了一些示例代码，希望对读者有一定的帮助。\n","slug":"2017-04-26-混合开发中的JSBridge","published":1,"updated":"2018-06-25T03:18:53.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc75000ehxp44s19ubrl","content":"<p>【导读】关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。那么，JSBridge 到底是什么？它的出现是为了什么？它究竟是怎么实现的？在这篇文章中，会在移动混合开发的范畴内，将给大家带来 JSBridge 的深入剖析。<a id=\"more\"></a></p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006cGJIjly1fiza4vwhtkj30b40640sz.jpg\" alt=\"\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>有些童鞋听到 JSBridge 这个名词，就是觉得非常高上大，有了它 Web 和 Native 可以进行交互，就像『进化药水』，让 Web 摇身一变，成为移动战场的『上将一名』。其实并非如此，JSBridge 其实真是一个很简单的东西，更多的是一种形式、一种思想。</p>\n<h1 id=\"JSBridge-的起源\"><a href=\"#JSBridge-的起源\" class=\"headerlink\" title=\"JSBridge 的起源\"></a>JSBridge 的起源</h1><p>为什么是 JSBridge ？而不是 PythonBridge 或是 RubyBridge ？</p>\n<p>当然不是因为 JavaScript 语言高人一等（虽然斯坦福大学已经把算法导论的语言从 Java 改成 JavaScript，小得意一下，嘻嘻），主要的原因还是因为 JavaScript 主要载体 Web 是当前世界上的 <strong>最易编写</strong> 、 <strong>最易维护</strong> 、 <strong>最易部署</strong> 的 UI 构建方式。工程师可以用很简单的 HTML 标签和 CSS 样式快速的构建出一个页面，并且在服务端部署后，用户不需要主动更新，就能看到最新的 UI 展现。</p>\n<p>因此，<strong>开发维护成本</strong> 和 <strong>更新成本</strong> 较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。因此，基于上面种种原因，JSBridge 应运而生。</p>\n<p>PhoneGap（Codova 的前身）作为 Hybrid 鼻祖框架，应该是最先被开发者广泛认知的 JSBridge 的应用场景；而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现，主要用途是在网页中通过 JSBridge 设置分享内容。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw690/71c50075ly1feyt6lzpb5j208c03mq4d.jpg\" alt=\"\"></p>\n<p>移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上：</p>\n<ul>\n<li>基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案</li>\n<li>非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native</li>\n</ul>\n<p>【注】：微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。</p>\n<h1 id=\"JSBridge-的用途\"><a href=\"#JSBridge-的用途\" class=\"headerlink\" title=\"JSBridge 的用途\"></a>JSBridge 的用途</h1><p>JSBridge 简单来讲，主要是 <strong>给 JavaScript 提供调用 Native 功能的接口</strong>，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。</p>\n<p>既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 <strong>构建 Native 和非 Native 间消息通信的通道</strong>，而且是 <strong>双向通信的通道</strong>。</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw690/71c50075ly1feyxr21wdkj20n905n74c.jpg\" alt=\"\"></p>\n<p>所谓 <strong>双向通信的通道</strong>:</p>\n<ul>\n<li>JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。</li>\n<li>Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。</li>\n</ul>\n<p>这里有些同学有疑问了：<u><em>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</em></u><br>对于这个问题，在下一节里会给出解释。</p>\n<h1 id=\"JSBridge-的实现原理\"><a href=\"#JSBridge-的实现原理\" class=\"headerlink\" title=\"JSBridge 的实现原理\"></a>JSBridge 的实现原理</h1><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的  Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。如此一来我们可以按照通常的 RPC 方式来进行设计和实现。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/71c50075ly1fez44p2jolj20a409dwet.jpg\" alt=\"\"></p>\n<p>在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：<strong>通信调用（Native 与 JS 通信）</strong> 和 <strong>句柄解析调用</strong>。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）</p>\n<p>通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 <strong>Hybrid 方案</strong> 为案例从这几点来剖析 JSBridge 的实现原理。</p>\n<h2 id=\"JSBridge-的通信原理\"><a href=\"#JSBridge-的通信原理\" class=\"headerlink\" title=\"JSBridge 的通信原理\"></a>JSBridge 的通信原理</h2><p>Hybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。</p>\n<h3 id=\"JavaScript-调用-Native\"><a href=\"#JavaScript-调用-Native\" class=\"headerlink\" title=\"JavaScript 调用 Native\"></a>JavaScript 调用 Native</h3><p>JavaScript 调用 Native 的方式，主要有两种：<strong>注入 API</strong> 和 <strong>拦截 URL SCHEME</strong>。</p>\n<h4 id=\"注入API\"><a href=\"#注入API\" class=\"headerlink\" title=\"注入API\"></a>注入API</h4><p>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p>\n<p>对于 iOS 的 UIWebView，实例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) &#123;</span><br><span class=\"line\">    // Native 逻辑</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>前端调用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.postBridgeMessage(message);</span><br></pre></td></tr></table></figure>\n<p>对于 iOS 的 WKWebView 可以用以下方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface WKWebVIewVC ()&lt;WKScriptMessageHandler&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation WKWebVIewVC</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class=\"line\">    configuration.userContentController = [[WKUserContentController alloc] init];</span><br><span class=\"line\">    WKUserContentController *userCC = configuration.userContentController;</span><br><span class=\"line\">    // 注入对象，前端调用其方法时，Native 可以捕获到</span><br><span class=\"line\">    [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];</span><br><span class=\"line\"></span><br><span class=\"line\">    // TODO 显示 WebView</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class=\"line\">    if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;前端传递的数据 %@: &quot;,message.body);</span><br><span class=\"line\">        // Native 逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前端调用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.nativeBridge.postMessage(message);</span><br></pre></td></tr></table></figure>\n<p>对于 Android 可以采用下面的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaScriptInterfaceDemoActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> WebView Wv;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">        Wv = (WebView)findViewById(R.id.webView);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> JavaScriptInterface myJavaScriptInterface = <span class=\"keyword\">new</span> JavaScriptInterface(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Wv.getSettings().setJavaScriptEnabled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Wv.addJavascriptInterface(myJavaScriptInterface, <span class=\"string\">\"nativeBridge\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// TODO 显示 WebView</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaScriptInterface</span> </span>&#123;</span><br><span class=\"line\">         Context mContext;</span><br><span class=\"line\"></span><br><span class=\"line\">         JavaScriptInterface(Context c) &#123;</span><br><span class=\"line\">             mContext = c;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postMessage</span><span class=\"params\">(String webMessage)</span></span>&#123;</span><br><span class=\"line\">             <span class=\"comment\">// Native 逻辑</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前端调用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.nativeBridge.postMessage(message);</span><br></pre></td></tr></table></figure>\n<p>在 4.2 之前，Android 注入 JavaScript 对象的接口是 addJavascriptInterface，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 @JavascriptInterface（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是 <strong>有兼容性问题的</strong>。（4.2 之前很多方案都采用拦截 prompt 的方式来实现，因为篇幅有限，这里就不展开了。）</p>\n<h4 id=\"拦截-URL-SCHEME\"><a href=\"#拦截-URL-SCHEME\" class=\"headerlink\" title=\"拦截 URL SCHEME\"></a>拦截 URL SCHEME</h4><p>先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=<a href=\"https://ymfe.org\" target=\"_blank\" rel=\"noopener\">https://ymfe.org</a>，protocol 是 qunarhy，host 则是 hy。</p>\n<p>拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p>\n<p>在时间过程中，这种方式有一定的 <strong>缺陷</strong>：</p>\n<ul>\n<li>使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</li>\n<li>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</li>\n</ul>\n<p>但是之前为什么很多方案使用这种方式呢？因为它 <strong>支持 iOS6</strong>。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 <strong>并不优雅</strong> 的方式。</p>\n<p>【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。</p>\n<p>【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。</p>\n<h3 id=\"Native-调用-JavaScript\"><a href=\"#Native-调用-JavaScript\" class=\"headerlink\" title=\"Native 调用 JavaScript\"></a>Native 调用 JavaScript</h3><p>相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。</p>\n<p>Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）</p>\n<p>对于 iOS 的 UIWebView，示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString];</span><br></pre></td></tr></table></figure>\n<p>对于 iOS 的 WKWebView，示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler];</span><br></pre></td></tr></table></figure>\n<p>对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webView.loadUrl(<span class=\"string\">\"javascript:\"</span> + javaScriptString);</span><br></pre></td></tr></table></figure>\n<p>而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webView.evaluateJavascript(javaScriptString, <span class=\"keyword\">new</span> ValueCallback&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceiveValue</span><span class=\"params\">(String value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>【注】：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。</p>\n<h3 id=\"通信原理小总结\"><a href=\"#通信原理小总结\" class=\"headerlink\" title=\"通信原理小总结\"></a>通信原理小总结</h3><p>通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，笔者推荐的实现方式如下：</p>\n<ul>\n<li>JavaScript 调用 Native 推荐使用 <strong>注入 API</strong> 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。</li>\n<li>Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。</li>\n</ul>\n<p>对于其他方式，诸如 React Native、微信小程序 的通信方式都与上描述的近似，并根据实际情况进行优化。</p>\n<p>以 React Native 的 iOS 端举例：JavaScript 运行在 JSCore 中，实际上可以与上面的方式一样，利用注入 API 来实现 JavaScript 调用 Native 功能。不过 React Native 并没有设计成 JavaScript 直接调用 Object-C，而是 <strong>为了与 Native 开发里事件响应机制一致</strong>，设计成 <strong>需要在 Object-C 去调 JavaScript 时才通过返回值触发调用</strong>。原理基本一样，只是实现方式不同。</p>\n<p>当然不仅仅 iOS 和 Android，其他手机操作系统也用相应的 API，例如 WMP（Win 10）下可以用 window.external.notify 和 WebView.InvokeScript/InvokeScriptAsync 进行双向通信。其他系统也类似。</p>\n<h2 id=\"JSBridge-接口实现\"><a href=\"#JSBridge-接口实现\" class=\"headerlink\" title=\"JSBridge 接口实现\"></a>JSBridge 接口实现</h2><p>从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：<strong>调用 Native（给 Native 发消息）</strong> 和 <strong>接被 Native 调用（接收 Native 消息）</strong>。因此，JSBridge 可以设计如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.JSBridge = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 Native</span></span><br><span class=\"line\">    invoke: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断环境，获取不同的 nativeBridge</span></span><br><span class=\"line\">        nativeBridge.postMessage(msg);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    receiveMessage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理 msg</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在上面的文章中，提到过 RPC 中有一个非常重要的环节是 <strong>句柄解析调用</strong> ，这点在 JSBridge 中体现为 <strong>句柄与功能对应关系</strong>。同时，我们将句柄抽象为 <strong>桥名（BridgeName）</strong>，最终演化为 <strong>一个 BridgeName 对应一个 Native 功能或者一类 Native 消息</strong>。 基于此点，JSBridge 的实现可以优化为如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.JSBridge = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 Native</span></span><br><span class=\"line\">    invoke: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridgeName, data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断环境，获取不同的 nativeBridge</span></span><br><span class=\"line\">        nativeBridge.postMessage(&#123;</span><br><span class=\"line\">            bridgeName: bridgeName,</span><br><span class=\"line\">            data: data || &#123;&#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    receiveMessage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bridgeName = msg.bridgeName,</span><br><span class=\"line\">            data = msg.data || &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 具体逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>JSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：<strong>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</strong></p>\n<p>对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释：</p>\n<blockquote>\n<p>当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 <strong>当前页面唯一</strong> 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。</p>\n</blockquote>\n<p>由此可见，callback 参数这个 <strong>唯一标识</strong> 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span>,</span><br><span class=\"line\">        callbacks = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.JSBridge = &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 Native</span></span><br><span class=\"line\">        invoke: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridgeName, callback, data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断环境，获取不同的 nativeBridge</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> thisId = id ++; <span class=\"comment\">// 获取唯一 id</span></span><br><span class=\"line\">            callbacks[thisId] = callback; <span class=\"comment\">// 存储 Callback</span></span><br><span class=\"line\">            nativeBridge.postMessage(&#123;</span><br><span class=\"line\">                bridgeName: bridgeName,</span><br><span class=\"line\">                data: data || &#123;&#125;,</span><br><span class=\"line\">                callbackId: thisId <span class=\"comment\">// 传到 Native 端</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        receiveMessage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bridgeName = msg.bridgeName,</span><br><span class=\"line\">                data = msg.data || &#123;&#125;,</span><br><span class=\"line\">                callbackId = msg.callbackId; <span class=\"comment\">// Native 将 callbackId 原封不动传回</span></span><br><span class=\"line\">            <span class=\"comment\">// 具体逻辑</span></span><br><span class=\"line\">            <span class=\"comment\">// bridgeName 和 callbackId 不会同时存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (callbackId) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (callbacks[callbackId]) &#123; <span class=\"comment\">// 找到相应句柄</span></span><br><span class=\"line\">                    callbacks[callbackId](msg.data); <span class=\"comment\">// 执行调用</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bridgeName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>最后用同样的方式加上 Native 调用的回调逻辑，同时对代码进行一些优化，就大概实现了一个功能比较完整的 JSBridge。其代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span>,</span><br><span class=\"line\">        callbacks = &#123;&#125;,</span><br><span class=\"line\">        registerFuncs = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.JSBridge = &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 Native</span></span><br><span class=\"line\">        invoke: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridgeName, callback, data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断环境，获取不同的 nativeBridge</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> thisId = id ++; <span class=\"comment\">// 获取唯一 id</span></span><br><span class=\"line\">            callbacks[thisId] = callback; <span class=\"comment\">// 存储 Callback</span></span><br><span class=\"line\">            nativeBridge.postMessage(&#123;</span><br><span class=\"line\">                bridgeName: bridgeName,</span><br><span class=\"line\">                data: data || &#123;&#125;,</span><br><span class=\"line\">                callbackId: thisId <span class=\"comment\">// 传到 Native 端</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        receiveMessage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bridgeName = msg.bridgeName,</span><br><span class=\"line\">                data = msg.data || &#123;&#125;,</span><br><span class=\"line\">                callbackId = msg.callbackId, <span class=\"comment\">// Native 将 callbackId 原封不动传回</span></span><br><span class=\"line\">                responstId = msg.responstId;</span><br><span class=\"line\">            <span class=\"comment\">// 具体逻辑</span></span><br><span class=\"line\">            <span class=\"comment\">// bridgeName 和 callbackId 不会同时存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (callbackId) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (callbacks[callbackId]) &#123; <span class=\"comment\">// 找到相应句柄</span></span><br><span class=\"line\">                    callbacks[callbackId](msg.data); <span class=\"comment\">// 执行调用</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bridgeName) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (registerFuncs[bridgeName]) &#123; <span class=\"comment\">// 通过 bridgeName 找到句柄</span></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> ret = &#123;&#125;,</span><br><span class=\"line\">                        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    registerFuncs[bridgeName].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) =&gt; </span>&#123;</span><br><span class=\"line\">                        callback(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">                            flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                            ret = <span class=\"built_in\">Object</span>.assign(ret, r);</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                        nativeBridge.postMessage(&#123; <span class=\"comment\">// 回调 Native</span></span><br><span class=\"line\">                            responstId: responstId,</span><br><span class=\"line\">                            ret: ret</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridgeName, callback</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!registerFuncs[bridgeName])  &#123;</span><br><span class=\"line\">                registerFuncs[bridgeName] = [];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            registerFuncs[bridgeName].push(callback); <span class=\"comment\">// 存储回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。</p>\n<p>【注】：这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 =&gt; 解析参数，拿到 bridgeName、data 和 callbackId =&gt; 根据 bridgeName 找到功能方法，以 data 为参数执行 =&gt; 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。</p>\n<h1 id=\"JSBridge-如何引用\"><a href=\"#JSBridge-如何引用\" class=\"headerlink\" title=\"JSBridge 如何引用\"></a>JSBridge 如何引用</h1><p>对于 JSBridge 的引用，常用有两种方式，各有利弊。</p>\n<h2 id=\"由-Native-端进行注入\"><a href=\"#由-Native-端进行注入\" class=\"headerlink\" title=\"由 Native 端进行注入\"></a>由 Native 端进行注入</h2><p>注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。</p>\n<p>它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。</p>\n<h2 id=\"由-JavaScript-端引用\"><a href=\"#由-JavaScript-端引用\" class=\"headerlink\" title=\"由 JavaScript 端引用\"></a>由 JavaScript 端引用</h2><p>直接与 JavaScript 一起执行。</p>\n<p>与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这篇文章主要剖析的 JSBridge 的实现及应用，包括 <strong>JavaScript 与 Native 间的通信原理</strong>，<strong>JSBridge 的 JavaScript 端实现</strong> 以及 <strong>引用方式</strong>，并给出了一些示例代码，希望对读者有一定的帮助。</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://wx1.sinaimg.cn/mw690/71c50075ly1feyxr21wdkj20n905n74c.jpg","excerpt":"<p>【导读】关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。那么，JSBridge 到底是什么？它的出现是为了什么？它究竟是怎么实现的？在这篇文章中，会在移动混合开发的范畴内，将给大家带来 JSBridge 的深入剖析。","more":"</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006cGJIjly1fiza4vwhtkj30b40640sz.jpg\" alt=\"\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>有些童鞋听到 JSBridge 这个名词，就是觉得非常高上大，有了它 Web 和 Native 可以进行交互，就像『进化药水』，让 Web 摇身一变，成为移动战场的『上将一名』。其实并非如此，JSBridge 其实真是一个很简单的东西，更多的是一种形式、一种思想。</p>\n<h1 id=\"JSBridge-的起源\"><a href=\"#JSBridge-的起源\" class=\"headerlink\" title=\"JSBridge 的起源\"></a>JSBridge 的起源</h1><p>为什么是 JSBridge ？而不是 PythonBridge 或是 RubyBridge ？</p>\n<p>当然不是因为 JavaScript 语言高人一等（虽然斯坦福大学已经把算法导论的语言从 Java 改成 JavaScript，小得意一下，嘻嘻），主要的原因还是因为 JavaScript 主要载体 Web 是当前世界上的 <strong>最易编写</strong> 、 <strong>最易维护</strong> 、 <strong>最易部署</strong> 的 UI 构建方式。工程师可以用很简单的 HTML 标签和 CSS 样式快速的构建出一个页面，并且在服务端部署后，用户不需要主动更新，就能看到最新的 UI 展现。</p>\n<p>因此，<strong>开发维护成本</strong> 和 <strong>更新成本</strong> 较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。因此，基于上面种种原因，JSBridge 应运而生。</p>\n<p>PhoneGap（Codova 的前身）作为 Hybrid 鼻祖框架，应该是最先被开发者广泛认知的 JSBridge 的应用场景；而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现，主要用途是在网页中通过 JSBridge 设置分享内容。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw690/71c50075ly1feyt6lzpb5j208c03mq4d.jpg\" alt=\"\"></p>\n<p>移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上：</p>\n<ul>\n<li>基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案</li>\n<li>非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native</li>\n</ul>\n<p>【注】：微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。</p>\n<h1 id=\"JSBridge-的用途\"><a href=\"#JSBridge-的用途\" class=\"headerlink\" title=\"JSBridge 的用途\"></a>JSBridge 的用途</h1><p>JSBridge 简单来讲，主要是 <strong>给 JavaScript 提供调用 Native 功能的接口</strong>，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。</p>\n<p>既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 <strong>构建 Native 和非 Native 间消息通信的通道</strong>，而且是 <strong>双向通信的通道</strong>。</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw690/71c50075ly1feyxr21wdkj20n905n74c.jpg\" alt=\"\"></p>\n<p>所谓 <strong>双向通信的通道</strong>:</p>\n<ul>\n<li>JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。</li>\n<li>Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。</li>\n</ul>\n<p>这里有些同学有疑问了：<u><em>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</em></u><br>对于这个问题，在下一节里会给出解释。</p>\n<h1 id=\"JSBridge-的实现原理\"><a href=\"#JSBridge-的实现原理\" class=\"headerlink\" title=\"JSBridge 的实现原理\"></a>JSBridge 的实现原理</h1><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的  Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。如此一来我们可以按照通常的 RPC 方式来进行设计和实现。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/71c50075ly1fez44p2jolj20a409dwet.jpg\" alt=\"\"></p>\n<p>在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：<strong>通信调用（Native 与 JS 通信）</strong> 和 <strong>句柄解析调用</strong>。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）</p>\n<p>通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 <strong>Hybrid 方案</strong> 为案例从这几点来剖析 JSBridge 的实现原理。</p>\n<h2 id=\"JSBridge-的通信原理\"><a href=\"#JSBridge-的通信原理\" class=\"headerlink\" title=\"JSBridge 的通信原理\"></a>JSBridge 的通信原理</h2><p>Hybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。</p>\n<h3 id=\"JavaScript-调用-Native\"><a href=\"#JavaScript-调用-Native\" class=\"headerlink\" title=\"JavaScript 调用 Native\"></a>JavaScript 调用 Native</h3><p>JavaScript 调用 Native 的方式，主要有两种：<strong>注入 API</strong> 和 <strong>拦截 URL SCHEME</strong>。</p>\n<h4 id=\"注入API\"><a href=\"#注入API\" class=\"headerlink\" title=\"注入API\"></a>注入API</h4><p>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p>\n<p>对于 iOS 的 UIWebView，实例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) &#123;</span><br><span class=\"line\">    // Native 逻辑</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>前端调用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.postBridgeMessage(message);</span><br></pre></td></tr></table></figure>\n<p>对于 iOS 的 WKWebView 可以用以下方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface WKWebVIewVC ()&lt;WKScriptMessageHandler&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation WKWebVIewVC</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];</span><br><span class=\"line\">    configuration.userContentController = [[WKUserContentController alloc] init];</span><br><span class=\"line\">    WKUserContentController *userCC = configuration.userContentController;</span><br><span class=\"line\">    // 注入对象，前端调用其方法时，Native 可以捕获到</span><br><span class=\"line\">    [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];</span><br><span class=\"line\"></span><br><span class=\"line\">    // TODO 显示 WebView</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class=\"line\">    if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;前端传递的数据 %@: &quot;,message.body);</span><br><span class=\"line\">        // Native 逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前端调用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.webkit.messageHandlers.nativeBridge.postMessage(message);</span><br></pre></td></tr></table></figure>\n<p>对于 Android 可以采用下面的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaScriptInterfaceDemoActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> WebView Wv;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">        Wv = (WebView)findViewById(R.id.webView);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> JavaScriptInterface myJavaScriptInterface = <span class=\"keyword\">new</span> JavaScriptInterface(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Wv.getSettings().setJavaScriptEnabled(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        Wv.addJavascriptInterface(myJavaScriptInterface, <span class=\"string\">\"nativeBridge\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// TODO 显示 WebView</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaScriptInterface</span> </span>&#123;</span><br><span class=\"line\">         Context mContext;</span><br><span class=\"line\"></span><br><span class=\"line\">         JavaScriptInterface(Context c) &#123;</span><br><span class=\"line\">             mContext = c;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postMessage</span><span class=\"params\">(String webMessage)</span></span>&#123;</span><br><span class=\"line\">             <span class=\"comment\">// Native 逻辑</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前端调用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.nativeBridge.postMessage(message);</span><br></pre></td></tr></table></figure>\n<p>在 4.2 之前，Android 注入 JavaScript 对象的接口是 addJavascriptInterface，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 @JavascriptInterface（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是 <strong>有兼容性问题的</strong>。（4.2 之前很多方案都采用拦截 prompt 的方式来实现，因为篇幅有限，这里就不展开了。）</p>\n<h4 id=\"拦截-URL-SCHEME\"><a href=\"#拦截-URL-SCHEME\" class=\"headerlink\" title=\"拦截 URL SCHEME\"></a>拦截 URL SCHEME</h4><p>先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=<a href=\"https://ymfe.org\" target=\"_blank\" rel=\"noopener\">https://ymfe.org</a>，protocol 是 qunarhy，host 则是 hy。</p>\n<p>拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p>\n<p>在时间过程中，这种方式有一定的 <strong>缺陷</strong>：</p>\n<ul>\n<li>使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</li>\n<li>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</li>\n</ul>\n<p>但是之前为什么很多方案使用这种方式呢？因为它 <strong>支持 iOS6</strong>。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 <strong>并不优雅</strong> 的方式。</p>\n<p>【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。</p>\n<p>【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。</p>\n<h3 id=\"Native-调用-JavaScript\"><a href=\"#Native-调用-JavaScript\" class=\"headerlink\" title=\"Native 调用 JavaScript\"></a>Native 调用 JavaScript</h3><p>相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。</p>\n<p>Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）</p>\n<p>对于 iOS 的 UIWebView，示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString];</span><br></pre></td></tr></table></figure>\n<p>对于 iOS 的 WKWebView，示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler];</span><br></pre></td></tr></table></figure>\n<p>对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webView.loadUrl(<span class=\"string\">\"javascript:\"</span> + javaScriptString);</span><br></pre></td></tr></table></figure>\n<p>而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webView.evaluateJavascript(javaScriptString, <span class=\"keyword\">new</span> ValueCallback&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceiveValue</span><span class=\"params\">(String value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>【注】：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。</p>\n<h3 id=\"通信原理小总结\"><a href=\"#通信原理小总结\" class=\"headerlink\" title=\"通信原理小总结\"></a>通信原理小总结</h3><p>通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，笔者推荐的实现方式如下：</p>\n<ul>\n<li>JavaScript 调用 Native 推荐使用 <strong>注入 API</strong> 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。</li>\n<li>Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。</li>\n</ul>\n<p>对于其他方式，诸如 React Native、微信小程序 的通信方式都与上描述的近似，并根据实际情况进行优化。</p>\n<p>以 React Native 的 iOS 端举例：JavaScript 运行在 JSCore 中，实际上可以与上面的方式一样，利用注入 API 来实现 JavaScript 调用 Native 功能。不过 React Native 并没有设计成 JavaScript 直接调用 Object-C，而是 <strong>为了与 Native 开发里事件响应机制一致</strong>，设计成 <strong>需要在 Object-C 去调 JavaScript 时才通过返回值触发调用</strong>。原理基本一样，只是实现方式不同。</p>\n<p>当然不仅仅 iOS 和 Android，其他手机操作系统也用相应的 API，例如 WMP（Win 10）下可以用 window.external.notify 和 WebView.InvokeScript/InvokeScriptAsync 进行双向通信。其他系统也类似。</p>\n<h2 id=\"JSBridge-接口实现\"><a href=\"#JSBridge-接口实现\" class=\"headerlink\" title=\"JSBridge 接口实现\"></a>JSBridge 接口实现</h2><p>从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：<strong>调用 Native（给 Native 发消息）</strong> 和 <strong>接被 Native 调用（接收 Native 消息）</strong>。因此，JSBridge 可以设计如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.JSBridge = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 Native</span></span><br><span class=\"line\">    invoke: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断环境，获取不同的 nativeBridge</span></span><br><span class=\"line\">        nativeBridge.postMessage(msg);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    receiveMessage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理 msg</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在上面的文章中，提到过 RPC 中有一个非常重要的环节是 <strong>句柄解析调用</strong> ，这点在 JSBridge 中体现为 <strong>句柄与功能对应关系</strong>。同时，我们将句柄抽象为 <strong>桥名（BridgeName）</strong>，最终演化为 <strong>一个 BridgeName 对应一个 Native 功能或者一类 Native 消息</strong>。 基于此点，JSBridge 的实现可以优化为如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.JSBridge = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 Native</span></span><br><span class=\"line\">    invoke: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridgeName, data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断环境，获取不同的 nativeBridge</span></span><br><span class=\"line\">        nativeBridge.postMessage(&#123;</span><br><span class=\"line\">            bridgeName: bridgeName,</span><br><span class=\"line\">            data: data || &#123;&#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    receiveMessage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> bridgeName = msg.bridgeName,</span><br><span class=\"line\">            data = msg.data || &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">// 具体逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>JSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：<strong>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</strong></p>\n<p>对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释：</p>\n<blockquote>\n<p>当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 <strong>当前页面唯一</strong> 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。</p>\n</blockquote>\n<p>由此可见，callback 参数这个 <strong>唯一标识</strong> 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span>,</span><br><span class=\"line\">        callbacks = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.JSBridge = &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 Native</span></span><br><span class=\"line\">        invoke: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridgeName, callback, data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断环境，获取不同的 nativeBridge</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> thisId = id ++; <span class=\"comment\">// 获取唯一 id</span></span><br><span class=\"line\">            callbacks[thisId] = callback; <span class=\"comment\">// 存储 Callback</span></span><br><span class=\"line\">            nativeBridge.postMessage(&#123;</span><br><span class=\"line\">                bridgeName: bridgeName,</span><br><span class=\"line\">                data: data || &#123;&#125;,</span><br><span class=\"line\">                callbackId: thisId <span class=\"comment\">// 传到 Native 端</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        receiveMessage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bridgeName = msg.bridgeName,</span><br><span class=\"line\">                data = msg.data || &#123;&#125;,</span><br><span class=\"line\">                callbackId = msg.callbackId; <span class=\"comment\">// Native 将 callbackId 原封不动传回</span></span><br><span class=\"line\">            <span class=\"comment\">// 具体逻辑</span></span><br><span class=\"line\">            <span class=\"comment\">// bridgeName 和 callbackId 不会同时存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (callbackId) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (callbacks[callbackId]) &#123; <span class=\"comment\">// 找到相应句柄</span></span><br><span class=\"line\">                    callbacks[callbackId](msg.data); <span class=\"comment\">// 执行调用</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bridgeName) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>最后用同样的方式加上 Native 调用的回调逻辑，同时对代码进行一些优化，就大概实现了一个功能比较完整的 JSBridge。其代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span>,</span><br><span class=\"line\">        callbacks = &#123;&#125;,</span><br><span class=\"line\">        registerFuncs = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.JSBridge = &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 Native</span></span><br><span class=\"line\">        invoke: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridgeName, callback, data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断环境，获取不同的 nativeBridge</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> thisId = id ++; <span class=\"comment\">// 获取唯一 id</span></span><br><span class=\"line\">            callbacks[thisId] = callback; <span class=\"comment\">// 存储 Callback</span></span><br><span class=\"line\">            nativeBridge.postMessage(&#123;</span><br><span class=\"line\">                bridgeName: bridgeName,</span><br><span class=\"line\">                data: data || &#123;&#125;,</span><br><span class=\"line\">                callbackId: thisId <span class=\"comment\">// 传到 Native 端</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        receiveMessage: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> bridgeName = msg.bridgeName,</span><br><span class=\"line\">                data = msg.data || &#123;&#125;,</span><br><span class=\"line\">                callbackId = msg.callbackId, <span class=\"comment\">// Native 将 callbackId 原封不动传回</span></span><br><span class=\"line\">                responstId = msg.responstId;</span><br><span class=\"line\">            <span class=\"comment\">// 具体逻辑</span></span><br><span class=\"line\">            <span class=\"comment\">// bridgeName 和 callbackId 不会同时存在</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (callbackId) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (callbacks[callbackId]) &#123; <span class=\"comment\">// 找到相应句柄</span></span><br><span class=\"line\">                    callbacks[callbackId](msg.data); <span class=\"comment\">// 执行调用</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bridgeName) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (registerFuncs[bridgeName]) &#123; <span class=\"comment\">// 通过 bridgeName 找到句柄</span></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> ret = &#123;&#125;,</span><br><span class=\"line\">                        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    registerFuncs[bridgeName].forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) =&gt; </span>&#123;</span><br><span class=\"line\">                        callback(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">                            flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                            ret = <span class=\"built_in\">Object</span>.assign(ret, r);</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                        nativeBridge.postMessage(&#123; <span class=\"comment\">// 回调 Native</span></span><br><span class=\"line\">                            responstId: responstId,</span><br><span class=\"line\">                            ret: ret</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bridgeName, callback</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!registerFuncs[bridgeName])  &#123;</span><br><span class=\"line\">                registerFuncs[bridgeName] = [];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            registerFuncs[bridgeName].push(callback); <span class=\"comment\">// 存储回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。</p>\n<p>【注】：这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 =&gt; 解析参数，拿到 bridgeName、data 和 callbackId =&gt; 根据 bridgeName 找到功能方法，以 data 为参数执行 =&gt; 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。</p>\n<h1 id=\"JSBridge-如何引用\"><a href=\"#JSBridge-如何引用\" class=\"headerlink\" title=\"JSBridge 如何引用\"></a>JSBridge 如何引用</h1><p>对于 JSBridge 的引用，常用有两种方式，各有利弊。</p>\n<h2 id=\"由-Native-端进行注入\"><a href=\"#由-Native-端进行注入\" class=\"headerlink\" title=\"由 Native 端进行注入\"></a>由 Native 端进行注入</h2><p>注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。</p>\n<p>它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。</p>\n<h2 id=\"由-JavaScript-端引用\"><a href=\"#由-JavaScript-端引用\" class=\"headerlink\" title=\"由 JavaScript 端引用\"></a>由 JavaScript 端引用</h2><p>直接与 JavaScript 一起执行。</p>\n<p>与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这篇文章主要剖析的 JSBridge 的实现及应用，包括 <strong>JavaScript 与 Native 间的通信原理</strong>，<strong>JSBridge 的 JavaScript 端实现</strong> 以及 <strong>引用方式</strong>，并给出了一些示例代码，希望对读者有一定的帮助。</p>"},{"title":"又是一年D2：颇具匠心的中台技术修养","date":"2017-12-31T09:00:00.000Z","thumbnailImage":"https://ws2.sinaimg.cn/large/006tKfTcly1frsd466pgmj30yy1504o8.jpg","thumbnailImagePosition":"left","_content":"\n杭州、西溪、冬、烟雨朦胧，又是一年阿里 D2。同样的会场，同样的人，但却是不一样的感受。<!-- more -->\n\n这届 D2 的主题是“匠心”，令笔者最为触动的词是“中台”，而笔者今年关注了 D2 新加入的主题“前端技术管理”，关注了团队与个人的“技术修养”问题，因此，结合几个关键词，给这篇文章起了一个比较文艺的题目《颇具匠心的中台技术修养》。\n\n\n与以往不同，由于在团队中身份的转变，这次来 D2，对业界方向的关注要远超于对前端技术细节的关心，因此，“技术管理”和“技术方案的整体设计”是这次笔者所重点关注的。\n\n### 第一小节 —— 成长\n\n经过几年的发展，前端的技术成熟度和稳定性已经到了一个很高的水平，虽然各种轮子层出不穷，但是技术体系和架构已经趋于稳定，这个时候，如何管理好团队使用的技术栈，既不“故步自封”，也不“横冲冒进”，是现在前端团队、终端团队管理者需要重点关注的问题。而今年，D2也推出了前端管理的主题，几位有丰富经验的前端团队 Leader 向大家分享了他们的经验。\n\n其中，让笔者感触最深的是 **月影** 带来的 **《自我成长的多元化团队》**。笔者从之前的单打独斗，到现在带领团队一起奋战，团队成员的成长一直是笔者花费很大精力去关注但成效不多的地方，而遇到的问题大部分都在月影的分享中被提到，因此感触颇多。其中 **“多元化”** 和 **“闭环”** 是其中笔者觉得最为核心的两点。\n\n在一个团队内，包含着风格、性格、能力各不同的成员，如何让每个成员都能体现出应有的价值，一直是团队 Leader 所遇到问题中的比较棘手。尤其是向笔者所在团队 [YMFE](https://ymfe.org) 这样的负责公司大前端础架构与中台方案的团队中，每个成员体现的价值与其能力有时候相差甚多。再加上，团队每年都会招入一些没有什么业务经验的应届生，如何让应届生表现出其突出的价值，以致让团队认为其值得培养，并倾斜资源，也是件很闹心的事情。\n\n在这里，月影提出一个观点 —— **“重组织、轻管理”**，对每个人单独的管理不如更宏观地规划处一系列的“大道”，让成员自行选择。当然，这里的一系列“大道”肯定要满足两个条件，就是上文所说的“多元化”和“闭环”（下图是 **奇舞团** 的多元化、多维度的成长空间）。虽然，当前团队也有类似的“大道”，但是维度并不足够；而且，当团队发展到一定的规模后，低维度的成长空间会可能会制约团队成员的行动力，所以，根据公司、团队自身情况建立不同的成长空间、成长路线是很有必要的，或许这将是笔者2018年在团队内主要推动的事情。\n\n![](https://ws2.sinaimg.cn/large/006tKfTcly1fmnhttpnn4j319g0uyju3.jpg)\n\n相比于 “多元化”，笔者感觉 “闭环” 其实更为重要，不论是 “正面反馈” 还是 “负面反馈” 都是很有必要的。在一个纯技术团队中，成员自身的技术肯定在第一位，在技术之外，项目管理、新人导师、对外技术输出和分享等，都是很重要的。而在这些之中，尤其是 “对外技术输出和分享” 最难形成闭环，最难给从事者足够的反馈。有人说，形成闭环很简单，直接和绩效、晋升挂钩。当然只是一种方法，但它只能给成员压力，例如未完成时的“负面反馈”，而并没有带来更多的“正面反馈”。\n\n其实，增加团队影响力，让团队成员都有团队自豪感，是最好的回馈方式。虽然这一年，团队也搞了 Conf 会议，同时也有一些开源项目，但笔者觉得收到的“正面反馈”并没有预想的那么多，尤其对低级别和新加入的成员。这不仅仅要在形式上下功夫，更要加强团队中每个人的团队意识，这应该是下一年需要重点提升的。\n\n### 第二小节 —— 务实\n\n在月影的分享中，有关管理者 **“积极”** 和 **“保守”** 的问题，也令人深省。\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fmnhcizdegj31bg0ton2h.jpg)\n\n不管是积极的管理者还是保守的管理者，都很看重优秀的人才和高效的组织，因为优秀的人才加上高效、稳定的组织，才能形成一个优秀的团队。关于这点，绝大多数人都知道，并且有一定的认识。所以，笔者在这里就不多做赘述了，而谈一下，对前三点的看法和思考。\n\n首先，对于 “保守” 这个偏贬义的词，笔者认为用 **“务实”** 更为贴切。直白点说，工资是公司发的，给公司创造价值才是当务之急，把技术用于业务、用于产品，减少业务的风险，或许是公司管理层更愿意看到的。打个比方，即时写了一个前无古人后无来者的无敌框架，如果不被业务所采用，到头来产出的也就那么几千行代码而已。\n\n这里，可能读者会认为笔者是个偏“保守”的管理者，其实并不是。笔者是个大白羊，一往直前的创新绝对是不可磨灭的欲望，但是笔者更倾向于在“保守”的基础上“积极”，在“务实”的肩膀上“创新”。创新是着眼于未来，但你的创新是否对未来有效，却不能空口无凭。因此，所谓的创新要在务实的场景中提炼，提炼出未来所需要的创新。讲一个很简单的逻辑，在务实业务的过程中，发现了业务的痛点，需要一种新方式来解决，因此去创新。这样能保证你的创新不管结果怎样，出发点是有意义的，是可以被大家认同的。就像 React Native，它解决了业务急需热更新的需求的同时，提升了体验，做出了比 Web 更好的体验效果，因此受到了大家的青睐。而现在，React Native 的劣势也表现出来，例如，因为通信的瓶颈，List 的效率堪忧，再例如，Native 实现的组件不能热更新（至少 iOS 不行），这种情况下，我们又要如何去解决了？是做微创新，直接切入痛点，解决问题；还是做大创新，提出一个比 React Native 更好的架构形式，这才是管理者应该去深入考虑的。\n\n### 第三小节 —— 中台\n\n在上面的叙述中，笔者提到了“中台”这个词，并把团队的部分工作称为“中台方案”。其实，“中台”这个词，笔者是在 D2 上才关注到的，因为很多分享都提到了“中台”这个概念，也可能是因为分享人大多是阿里系的有关。“大中台，小前台”是阿里巴巴在2015年底提出的公司级战略，之后很多公司效仿，让很多之前的“公共支持团队”变成现在的“平台事业部”。公司战略层面的高深意义不是笔者一个小技术人员能理解的，不过，仅限技术而言，这样的战略，会减少多团队干一件事的概率，同时也让想做技术的同学可以一直单纯的做技术，不用去想“30后做管理，40后当经理”的事情。这或许是，单纯喜欢做技术的同学一个福音吧。（下图是2016年初阿里基于“大中台、小前台”战略制定的集团整体组织架构）\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fmzy0kt0i0j30hs0apq3h.jpg)\n\n中台是什么？给前台提供工具、服务、模块等公共、统一化的资源。对于大前端技术来说，构建工具、开发平台、服务平台、公共组件都算作中台的范畴。在大前端基础架构趋于稳定的情况下（前端React、Angular、Vue 三分，客户端原生、Hybrid、React Native（包括类 RN）三分），除了基于现有架构，适配自身公司的基础研发外，更多的是，给业务提供技术方案支持，让业务方更快地进行开发迭代，这或许是当前大前端重点要做的。\n\n当然，唯“中台”论，有时候也比较“可怕”。当前台的技术人员只关心业务，同时中台的技术人员不能提供满足前台的技术需求，这将是很可怕的一件事，因为很难弥补中间的空缺，或者这个问题成为拉锯战。因此，作为“中台”部分的工程师，要承受更大的压力，并拥有更深的技术。\n\n### 第四小节 —— 修养\n\n在“大中台，小前台”的环境中，大前端工程师，要有怎样的 **技术修养** 呢？直接贴 **盒马岑安** 的三张 PPT。\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fn00go6qw3j31kw0vub2c.jpg)\n\n![](https://ws3.sinaimg.cn/large/006tNc79ly1fn00haco76j31kw0w11l1.jpg)\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fn00hnmcdaj31kw0vg1l0.jpg)\n\n**“以史明鉴”** 一直是很好的分析方式。通过回顾前端的发展历程，每个阶段的技术，都是为了解决这个阶段的难题与痛点。虽然说，图中跟多是前端的内容，但是客户端与之是类似的。因此，可以说，大前端已经解决了从内容承载到体验优化，在从副交互到工程化，甚至包括开发模式等各个方面的问题，而解决这些问题的能力是当前大前端工程师的基本要求。\n\n而现在呢？未来呢？笔者谈谈自己的想法。在业务形式不断扩展，“中台”变大的时代，大前端工程师，尤其是做架构的大前端工程师，更多地需要能 **耐得住寂寞**。不同于前几年，一个优秀的架构方案，可以翻江倒海；而现在，包括将来，要做的更多是为业务提供服务的工作，稳定和完善是关键。或者，你可能已经感受不到获得感，但是你做的东西的实际价值或许会更高，因为它会支撑比现在更多的业务。\n\n最后，贴一张“核心竞争力”的 PPT —— 不仅仅要 **拆解** 后 **输出** ，更要 **落地** 于 **业务**。\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fn011cfxwzj31kw0vwx6r.jpg)\n\n### 第五小节 —— 更好\n\n作为中台特征明显的大前端架构，究竟要做什么？或许是，**更完善的生态** 和 **更好的服务**。\n\n很简单的一个道理，当人吃饱了，就会要求吃得好、吃得方便、吃得有营养了。做架构也一样，当架构可以满足业务需求后，业务就会反过来，要求架构更稳定、更易用了。\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fmzyufh1ruj31jg0vugwn.jpg)\n\n上面是 **支付宝加里** 分享了一张PPT，类似的 Q 还包括很多，“为什么代码还是原来的”、“为什么点击没反应”、“iOS 没毛病，Android 挂了”。对于这类繁多的业务人员反馈的问题，是烦人也棘手的；你不能奢求业务人员去自己解决，况且有些问题，业务人员根本解决不了。在这时，你就需要一个完善的工具、服务等等其他的一些东西，来快速定位问题，或者来证明“问题不是框架的，是业务自身的”。因此，在未来一年或者几年，对于中台、对于大前端的架构团队，**更完善的生态** 和 **更好的服务** 应该被首要关注的。\n\n### 总结\n\n2017仍是大前端火热的一年，但发展也已经从“野蛮生长”变为“颇具匠心”，越来越多稳定成熟的架构方法被广泛使用。与此同时，时代的热点已经转到机器学习和加密货币，而主项是 UI 的大前端发展又将何去何从呢。或许历史已经给出答案，传统后端默默地做了许久的模块化、服务化，伴随着云的兴起，又迎来新一春。或许，大前端的“中台化”，是大前端发展接下来最重要的一步。\n\n\n2018，新的一年，你好。\n\nD2 更多视频 和 PPT 信息，请访问官网：[https://d2forum.alibaba-inc.com/](https://d2forum.alibaba-inc.com/)\n","source":"_posts/2017-12-31-D2-2017.md","raw":"title: 又是一年D2：颇具匠心的中台技术修养\ndate: 2017-12-31 17:00:00\ncategory: 随笔\ntags: [D2]\nthumbnailImage: https://ws2.sinaimg.cn/large/006tKfTcly1frsd466pgmj30yy1504o8.jpg\nthumbnailImagePosition: left\n---\n\n杭州、西溪、冬、烟雨朦胧，又是一年阿里 D2。同样的会场，同样的人，但却是不一样的感受。<!-- more -->\n\n这届 D2 的主题是“匠心”，令笔者最为触动的词是“中台”，而笔者今年关注了 D2 新加入的主题“前端技术管理”，关注了团队与个人的“技术修养”问题，因此，结合几个关键词，给这篇文章起了一个比较文艺的题目《颇具匠心的中台技术修养》。\n\n\n与以往不同，由于在团队中身份的转变，这次来 D2，对业界方向的关注要远超于对前端技术细节的关心，因此，“技术管理”和“技术方案的整体设计”是这次笔者所重点关注的。\n\n### 第一小节 —— 成长\n\n经过几年的发展，前端的技术成熟度和稳定性已经到了一个很高的水平，虽然各种轮子层出不穷，但是技术体系和架构已经趋于稳定，这个时候，如何管理好团队使用的技术栈，既不“故步自封”，也不“横冲冒进”，是现在前端团队、终端团队管理者需要重点关注的问题。而今年，D2也推出了前端管理的主题，几位有丰富经验的前端团队 Leader 向大家分享了他们的经验。\n\n其中，让笔者感触最深的是 **月影** 带来的 **《自我成长的多元化团队》**。笔者从之前的单打独斗，到现在带领团队一起奋战，团队成员的成长一直是笔者花费很大精力去关注但成效不多的地方，而遇到的问题大部分都在月影的分享中被提到，因此感触颇多。其中 **“多元化”** 和 **“闭环”** 是其中笔者觉得最为核心的两点。\n\n在一个团队内，包含着风格、性格、能力各不同的成员，如何让每个成员都能体现出应有的价值，一直是团队 Leader 所遇到问题中的比较棘手。尤其是向笔者所在团队 [YMFE](https://ymfe.org) 这样的负责公司大前端础架构与中台方案的团队中，每个成员体现的价值与其能力有时候相差甚多。再加上，团队每年都会招入一些没有什么业务经验的应届生，如何让应届生表现出其突出的价值，以致让团队认为其值得培养，并倾斜资源，也是件很闹心的事情。\n\n在这里，月影提出一个观点 —— **“重组织、轻管理”**，对每个人单独的管理不如更宏观地规划处一系列的“大道”，让成员自行选择。当然，这里的一系列“大道”肯定要满足两个条件，就是上文所说的“多元化”和“闭环”（下图是 **奇舞团** 的多元化、多维度的成长空间）。虽然，当前团队也有类似的“大道”，但是维度并不足够；而且，当团队发展到一定的规模后，低维度的成长空间会可能会制约团队成员的行动力，所以，根据公司、团队自身情况建立不同的成长空间、成长路线是很有必要的，或许这将是笔者2018年在团队内主要推动的事情。\n\n![](https://ws2.sinaimg.cn/large/006tKfTcly1fmnhttpnn4j319g0uyju3.jpg)\n\n相比于 “多元化”，笔者感觉 “闭环” 其实更为重要，不论是 “正面反馈” 还是 “负面反馈” 都是很有必要的。在一个纯技术团队中，成员自身的技术肯定在第一位，在技术之外，项目管理、新人导师、对外技术输出和分享等，都是很重要的。而在这些之中，尤其是 “对外技术输出和分享” 最难形成闭环，最难给从事者足够的反馈。有人说，形成闭环很简单，直接和绩效、晋升挂钩。当然只是一种方法，但它只能给成员压力，例如未完成时的“负面反馈”，而并没有带来更多的“正面反馈”。\n\n其实，增加团队影响力，让团队成员都有团队自豪感，是最好的回馈方式。虽然这一年，团队也搞了 Conf 会议，同时也有一些开源项目，但笔者觉得收到的“正面反馈”并没有预想的那么多，尤其对低级别和新加入的成员。这不仅仅要在形式上下功夫，更要加强团队中每个人的团队意识，这应该是下一年需要重点提升的。\n\n### 第二小节 —— 务实\n\n在月影的分享中，有关管理者 **“积极”** 和 **“保守”** 的问题，也令人深省。\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fmnhcizdegj31bg0ton2h.jpg)\n\n不管是积极的管理者还是保守的管理者，都很看重优秀的人才和高效的组织，因为优秀的人才加上高效、稳定的组织，才能形成一个优秀的团队。关于这点，绝大多数人都知道，并且有一定的认识。所以，笔者在这里就不多做赘述了，而谈一下，对前三点的看法和思考。\n\n首先，对于 “保守” 这个偏贬义的词，笔者认为用 **“务实”** 更为贴切。直白点说，工资是公司发的，给公司创造价值才是当务之急，把技术用于业务、用于产品，减少业务的风险，或许是公司管理层更愿意看到的。打个比方，即时写了一个前无古人后无来者的无敌框架，如果不被业务所采用，到头来产出的也就那么几千行代码而已。\n\n这里，可能读者会认为笔者是个偏“保守”的管理者，其实并不是。笔者是个大白羊，一往直前的创新绝对是不可磨灭的欲望，但是笔者更倾向于在“保守”的基础上“积极”，在“务实”的肩膀上“创新”。创新是着眼于未来，但你的创新是否对未来有效，却不能空口无凭。因此，所谓的创新要在务实的场景中提炼，提炼出未来所需要的创新。讲一个很简单的逻辑，在务实业务的过程中，发现了业务的痛点，需要一种新方式来解决，因此去创新。这样能保证你的创新不管结果怎样，出发点是有意义的，是可以被大家认同的。就像 React Native，它解决了业务急需热更新的需求的同时，提升了体验，做出了比 Web 更好的体验效果，因此受到了大家的青睐。而现在，React Native 的劣势也表现出来，例如，因为通信的瓶颈，List 的效率堪忧，再例如，Native 实现的组件不能热更新（至少 iOS 不行），这种情况下，我们又要如何去解决了？是做微创新，直接切入痛点，解决问题；还是做大创新，提出一个比 React Native 更好的架构形式，这才是管理者应该去深入考虑的。\n\n### 第三小节 —— 中台\n\n在上面的叙述中，笔者提到了“中台”这个词，并把团队的部分工作称为“中台方案”。其实，“中台”这个词，笔者是在 D2 上才关注到的，因为很多分享都提到了“中台”这个概念，也可能是因为分享人大多是阿里系的有关。“大中台，小前台”是阿里巴巴在2015年底提出的公司级战略，之后很多公司效仿，让很多之前的“公共支持团队”变成现在的“平台事业部”。公司战略层面的高深意义不是笔者一个小技术人员能理解的，不过，仅限技术而言，这样的战略，会减少多团队干一件事的概率，同时也让想做技术的同学可以一直单纯的做技术，不用去想“30后做管理，40后当经理”的事情。这或许是，单纯喜欢做技术的同学一个福音吧。（下图是2016年初阿里基于“大中台、小前台”战略制定的集团整体组织架构）\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fmzy0kt0i0j30hs0apq3h.jpg)\n\n中台是什么？给前台提供工具、服务、模块等公共、统一化的资源。对于大前端技术来说，构建工具、开发平台、服务平台、公共组件都算作中台的范畴。在大前端基础架构趋于稳定的情况下（前端React、Angular、Vue 三分，客户端原生、Hybrid、React Native（包括类 RN）三分），除了基于现有架构，适配自身公司的基础研发外，更多的是，给业务提供技术方案支持，让业务方更快地进行开发迭代，这或许是当前大前端重点要做的。\n\n当然，唯“中台”论，有时候也比较“可怕”。当前台的技术人员只关心业务，同时中台的技术人员不能提供满足前台的技术需求，这将是很可怕的一件事，因为很难弥补中间的空缺，或者这个问题成为拉锯战。因此，作为“中台”部分的工程师，要承受更大的压力，并拥有更深的技术。\n\n### 第四小节 —— 修养\n\n在“大中台，小前台”的环境中，大前端工程师，要有怎样的 **技术修养** 呢？直接贴 **盒马岑安** 的三张 PPT。\n\n![](https://ws4.sinaimg.cn/large/006tNc79ly1fn00go6qw3j31kw0vub2c.jpg)\n\n![](https://ws3.sinaimg.cn/large/006tNc79ly1fn00haco76j31kw0w11l1.jpg)\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fn00hnmcdaj31kw0vg1l0.jpg)\n\n**“以史明鉴”** 一直是很好的分析方式。通过回顾前端的发展历程，每个阶段的技术，都是为了解决这个阶段的难题与痛点。虽然说，图中跟多是前端的内容，但是客户端与之是类似的。因此，可以说，大前端已经解决了从内容承载到体验优化，在从副交互到工程化，甚至包括开发模式等各个方面的问题，而解决这些问题的能力是当前大前端工程师的基本要求。\n\n而现在呢？未来呢？笔者谈谈自己的想法。在业务形式不断扩展，“中台”变大的时代，大前端工程师，尤其是做架构的大前端工程师，更多地需要能 **耐得住寂寞**。不同于前几年，一个优秀的架构方案，可以翻江倒海；而现在，包括将来，要做的更多是为业务提供服务的工作，稳定和完善是关键。或者，你可能已经感受不到获得感，但是你做的东西的实际价值或许会更高，因为它会支撑比现在更多的业务。\n\n最后，贴一张“核心竞争力”的 PPT —— 不仅仅要 **拆解** 后 **输出** ，更要 **落地** 于 **业务**。\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fn011cfxwzj31kw0vwx6r.jpg)\n\n### 第五小节 —— 更好\n\n作为中台特征明显的大前端架构，究竟要做什么？或许是，**更完善的生态** 和 **更好的服务**。\n\n很简单的一个道理，当人吃饱了，就会要求吃得好、吃得方便、吃得有营养了。做架构也一样，当架构可以满足业务需求后，业务就会反过来，要求架构更稳定、更易用了。\n\n![](https://ws2.sinaimg.cn/large/006tNc79ly1fmzyufh1ruj31jg0vugwn.jpg)\n\n上面是 **支付宝加里** 分享了一张PPT，类似的 Q 还包括很多，“为什么代码还是原来的”、“为什么点击没反应”、“iOS 没毛病，Android 挂了”。对于这类繁多的业务人员反馈的问题，是烦人也棘手的；你不能奢求业务人员去自己解决，况且有些问题，业务人员根本解决不了。在这时，你就需要一个完善的工具、服务等等其他的一些东西，来快速定位问题，或者来证明“问题不是框架的，是业务自身的”。因此，在未来一年或者几年，对于中台、对于大前端的架构团队，**更完善的生态** 和 **更好的服务** 应该被首要关注的。\n\n### 总结\n\n2017仍是大前端火热的一年，但发展也已经从“野蛮生长”变为“颇具匠心”，越来越多稳定成熟的架构方法被广泛使用。与此同时，时代的热点已经转到机器学习和加密货币，而主项是 UI 的大前端发展又将何去何从呢。或许历史已经给出答案，传统后端默默地做了许久的模块化、服务化，伴随着云的兴起，又迎来新一春。或许，大前端的“中台化”，是大前端发展接下来最重要的一步。\n\n\n2018，新的一年，你好。\n\nD2 更多视频 和 PPT 信息，请访问官网：[https://d2forum.alibaba-inc.com/](https://d2forum.alibaba-inc.com/)\n","slug":"2017-12-31-D2-2017","published":1,"updated":"2018-06-25T03:18:28.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc76000ihxp4yh2ngv78","content":"<p>杭州、西溪、冬、烟雨朦胧，又是一年阿里 D2。同样的会场，同样的人，但却是不一样的感受。<a id=\"more\"></a></p>\n<p>这届 D2 的主题是“匠心”，令笔者最为触动的词是“中台”，而笔者今年关注了 D2 新加入的主题“前端技术管理”，关注了团队与个人的“技术修养”问题，因此，结合几个关键词，给这篇文章起了一个比较文艺的题目《颇具匠心的中台技术修养》。</p>\n<p>与以往不同，由于在团队中身份的转变，这次来 D2，对业界方向的关注要远超于对前端技术细节的关心，因此，“技术管理”和“技术方案的整体设计”是这次笔者所重点关注的。</p>\n<h3 id=\"第一小节-——-成长\"><a href=\"#第一小节-——-成长\" class=\"headerlink\" title=\"第一小节 —— 成长\"></a>第一小节 —— 成长</h3><p>经过几年的发展，前端的技术成熟度和稳定性已经到了一个很高的水平，虽然各种轮子层出不穷，但是技术体系和架构已经趋于稳定，这个时候，如何管理好团队使用的技术栈，既不“故步自封”，也不“横冲冒进”，是现在前端团队、终端团队管理者需要重点关注的问题。而今年，D2也推出了前端管理的主题，几位有丰富经验的前端团队 Leader 向大家分享了他们的经验。</p>\n<p>其中，让笔者感触最深的是 <strong>月影</strong> 带来的 <strong>《自我成长的多元化团队》</strong>。笔者从之前的单打独斗，到现在带领团队一起奋战，团队成员的成长一直是笔者花费很大精力去关注但成效不多的地方，而遇到的问题大部分都在月影的分享中被提到，因此感触颇多。其中 <strong>“多元化”</strong> 和 <strong>“闭环”</strong> 是其中笔者觉得最为核心的两点。</p>\n<p>在一个团队内，包含着风格、性格、能力各不同的成员，如何让每个成员都能体现出应有的价值，一直是团队 Leader 所遇到问题中的比较棘手。尤其是向笔者所在团队 <a href=\"https://ymfe.org\" target=\"_blank\" rel=\"noopener\">YMFE</a> 这样的负责公司大前端础架构与中台方案的团队中，每个成员体现的价值与其能力有时候相差甚多。再加上，团队每年都会招入一些没有什么业务经验的应届生，如何让应届生表现出其突出的价值，以致让团队认为其值得培养，并倾斜资源，也是件很闹心的事情。</p>\n<p>在这里，月影提出一个观点 —— <strong>“重组织、轻管理”</strong>，对每个人单独的管理不如更宏观地规划处一系列的“大道”，让成员自行选择。当然，这里的一系列“大道”肯定要满足两个条件，就是上文所说的“多元化”和“闭环”（下图是 <strong>奇舞团</strong> 的多元化、多维度的成长空间）。虽然，当前团队也有类似的“大道”，但是维度并不足够；而且，当团队发展到一定的规模后，低维度的成长空间会可能会制约团队成员的行动力，所以，根据公司、团队自身情况建立不同的成长空间、成长路线是很有必要的，或许这将是笔者2018年在团队内主要推动的事情。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcly1fmnhttpnn4j319g0uyju3.jpg\" alt=\"\"></p>\n<p>相比于 “多元化”，笔者感觉 “闭环” 其实更为重要，不论是 “正面反馈” 还是 “负面反馈” 都是很有必要的。在一个纯技术团队中，成员自身的技术肯定在第一位，在技术之外，项目管理、新人导师、对外技术输出和分享等，都是很重要的。而在这些之中，尤其是 “对外技术输出和分享” 最难形成闭环，最难给从事者足够的反馈。有人说，形成闭环很简单，直接和绩效、晋升挂钩。当然只是一种方法，但它只能给成员压力，例如未完成时的“负面反馈”，而并没有带来更多的“正面反馈”。</p>\n<p>其实，增加团队影响力，让团队成员都有团队自豪感，是最好的回馈方式。虽然这一年，团队也搞了 Conf 会议，同时也有一些开源项目，但笔者觉得收到的“正面反馈”并没有预想的那么多，尤其对低级别和新加入的成员。这不仅仅要在形式上下功夫，更要加强团队中每个人的团队意识，这应该是下一年需要重点提升的。</p>\n<h3 id=\"第二小节-——-务实\"><a href=\"#第二小节-——-务实\" class=\"headerlink\" title=\"第二小节 —— 务实\"></a>第二小节 —— 务实</h3><p>在月影的分享中，有关管理者 <strong>“积极”</strong> 和 <strong>“保守”</strong> 的问题，也令人深省。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fmnhcizdegj31bg0ton2h.jpg\" alt=\"\"></p>\n<p>不管是积极的管理者还是保守的管理者，都很看重优秀的人才和高效的组织，因为优秀的人才加上高效、稳定的组织，才能形成一个优秀的团队。关于这点，绝大多数人都知道，并且有一定的认识。所以，笔者在这里就不多做赘述了，而谈一下，对前三点的看法和思考。</p>\n<p>首先，对于 “保守” 这个偏贬义的词，笔者认为用 <strong>“务实”</strong> 更为贴切。直白点说，工资是公司发的，给公司创造价值才是当务之急，把技术用于业务、用于产品，减少业务的风险，或许是公司管理层更愿意看到的。打个比方，即时写了一个前无古人后无来者的无敌框架，如果不被业务所采用，到头来产出的也就那么几千行代码而已。</p>\n<p>这里，可能读者会认为笔者是个偏“保守”的管理者，其实并不是。笔者是个大白羊，一往直前的创新绝对是不可磨灭的欲望，但是笔者更倾向于在“保守”的基础上“积极”，在“务实”的肩膀上“创新”。创新是着眼于未来，但你的创新是否对未来有效，却不能空口无凭。因此，所谓的创新要在务实的场景中提炼，提炼出未来所需要的创新。讲一个很简单的逻辑，在务实业务的过程中，发现了业务的痛点，需要一种新方式来解决，因此去创新。这样能保证你的创新不管结果怎样，出发点是有意义的，是可以被大家认同的。就像 React Native，它解决了业务急需热更新的需求的同时，提升了体验，做出了比 Web 更好的体验效果，因此受到了大家的青睐。而现在，React Native 的劣势也表现出来，例如，因为通信的瓶颈，List 的效率堪忧，再例如，Native 实现的组件不能热更新（至少 iOS 不行），这种情况下，我们又要如何去解决了？是做微创新，直接切入痛点，解决问题；还是做大创新，提出一个比 React Native 更好的架构形式，这才是管理者应该去深入考虑的。</p>\n<h3 id=\"第三小节-——-中台\"><a href=\"#第三小节-——-中台\" class=\"headerlink\" title=\"第三小节 —— 中台\"></a>第三小节 —— 中台</h3><p>在上面的叙述中，笔者提到了“中台”这个词，并把团队的部分工作称为“中台方案”。其实，“中台”这个词，笔者是在 D2 上才关注到的，因为很多分享都提到了“中台”这个概念，也可能是因为分享人大多是阿里系的有关。“大中台，小前台”是阿里巴巴在2015年底提出的公司级战略，之后很多公司效仿，让很多之前的“公共支持团队”变成现在的“平台事业部”。公司战略层面的高深意义不是笔者一个小技术人员能理解的，不过，仅限技术而言，这样的战略，会减少多团队干一件事的概率，同时也让想做技术的同学可以一直单纯的做技术，不用去想“30后做管理，40后当经理”的事情。这或许是，单纯喜欢做技术的同学一个福音吧。（下图是2016年初阿里基于“大中台、小前台”战略制定的集团整体组织架构）</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fmzy0kt0i0j30hs0apq3h.jpg\" alt=\"\"></p>\n<p>中台是什么？给前台提供工具、服务、模块等公共、统一化的资源。对于大前端技术来说，构建工具、开发平台、服务平台、公共组件都算作中台的范畴。在大前端基础架构趋于稳定的情况下（前端React、Angular、Vue 三分，客户端原生、Hybrid、React Native（包括类 RN）三分），除了基于现有架构，适配自身公司的基础研发外，更多的是，给业务提供技术方案支持，让业务方更快地进行开发迭代，这或许是当前大前端重点要做的。</p>\n<p>当然，唯“中台”论，有时候也比较“可怕”。当前台的技术人员只关心业务，同时中台的技术人员不能提供满足前台的技术需求，这将是很可怕的一件事，因为很难弥补中间的空缺，或者这个问题成为拉锯战。因此，作为“中台”部分的工程师，要承受更大的压力，并拥有更深的技术。</p>\n<h3 id=\"第四小节-——-修养\"><a href=\"#第四小节-——-修养\" class=\"headerlink\" title=\"第四小节 —— 修养\"></a>第四小节 —— 修养</h3><p>在“大中台，小前台”的环境中，大前端工程师，要有怎样的 <strong>技术修养</strong> 呢？直接贴 <strong>盒马岑安</strong> 的三张 PPT。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fn00go6qw3j31kw0vub2c.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fn00haco76j31kw0w11l1.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fn00hnmcdaj31kw0vg1l0.jpg\" alt=\"\"></p>\n<p><strong>“以史明鉴”</strong> 一直是很好的分析方式。通过回顾前端的发展历程，每个阶段的技术，都是为了解决这个阶段的难题与痛点。虽然说，图中跟多是前端的内容，但是客户端与之是类似的。因此，可以说，大前端已经解决了从内容承载到体验优化，在从副交互到工程化，甚至包括开发模式等各个方面的问题，而解决这些问题的能力是当前大前端工程师的基本要求。</p>\n<p>而现在呢？未来呢？笔者谈谈自己的想法。在业务形式不断扩展，“中台”变大的时代，大前端工程师，尤其是做架构的大前端工程师，更多地需要能 <strong>耐得住寂寞</strong>。不同于前几年，一个优秀的架构方案，可以翻江倒海；而现在，包括将来，要做的更多是为业务提供服务的工作，稳定和完善是关键。或者，你可能已经感受不到获得感，但是你做的东西的实际价值或许会更高，因为它会支撑比现在更多的业务。</p>\n<p>最后，贴一张“核心竞争力”的 PPT —— 不仅仅要 <strong>拆解</strong> 后 <strong>输出</strong> ，更要 <strong>落地</strong> 于 <strong>业务</strong>。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fn011cfxwzj31kw0vwx6r.jpg\" alt=\"\"></p>\n<h3 id=\"第五小节-——-更好\"><a href=\"#第五小节-——-更好\" class=\"headerlink\" title=\"第五小节 —— 更好\"></a>第五小节 —— 更好</h3><p>作为中台特征明显的大前端架构，究竟要做什么？或许是，<strong>更完善的生态</strong> 和 <strong>更好的服务</strong>。</p>\n<p>很简单的一个道理，当人吃饱了，就会要求吃得好、吃得方便、吃得有营养了。做架构也一样，当架构可以满足业务需求后，业务就会反过来，要求架构更稳定、更易用了。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fmzyufh1ruj31jg0vugwn.jpg\" alt=\"\"></p>\n<p>上面是 <strong>支付宝加里</strong> 分享了一张PPT，类似的 Q 还包括很多，“为什么代码还是原来的”、“为什么点击没反应”、“iOS 没毛病，Android 挂了”。对于这类繁多的业务人员反馈的问题，是烦人也棘手的；你不能奢求业务人员去自己解决，况且有些问题，业务人员根本解决不了。在这时，你就需要一个完善的工具、服务等等其他的一些东西，来快速定位问题，或者来证明“问题不是框架的，是业务自身的”。因此，在未来一年或者几年，对于中台、对于大前端的架构团队，<strong>更完善的生态</strong> 和 <strong>更好的服务</strong> 应该被首要关注的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>2017仍是大前端火热的一年，但发展也已经从“野蛮生长”变为“颇具匠心”，越来越多稳定成熟的架构方法被广泛使用。与此同时，时代的热点已经转到机器学习和加密货币，而主项是 UI 的大前端发展又将何去何从呢。或许历史已经给出答案，传统后端默默地做了许久的模块化、服务化，伴随着云的兴起，又迎来新一春。或许，大前端的“中台化”，是大前端发展接下来最重要的一步。</p>\n<p>2018，新的一年，你好。</p>\n<p>D2 更多视频 和 PPT 信息，请访问官网：<a href=\"https://d2forum.alibaba-inc.com/\" target=\"_blank\" rel=\"noopener\">https://d2forum.alibaba-inc.com/</a></p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws2.sinaimg.cn/large/006tKfTcly1frsd466pgmj30yy1504o8.jpg","excerpt":"<p>杭州、西溪、冬、烟雨朦胧，又是一年阿里 D2。同样的会场，同样的人，但却是不一样的感受。","more":"</p>\n<p>这届 D2 的主题是“匠心”，令笔者最为触动的词是“中台”，而笔者今年关注了 D2 新加入的主题“前端技术管理”，关注了团队与个人的“技术修养”问题，因此，结合几个关键词，给这篇文章起了一个比较文艺的题目《颇具匠心的中台技术修养》。</p>\n<p>与以往不同，由于在团队中身份的转变，这次来 D2，对业界方向的关注要远超于对前端技术细节的关心，因此，“技术管理”和“技术方案的整体设计”是这次笔者所重点关注的。</p>\n<h3 id=\"第一小节-——-成长\"><a href=\"#第一小节-——-成长\" class=\"headerlink\" title=\"第一小节 —— 成长\"></a>第一小节 —— 成长</h3><p>经过几年的发展，前端的技术成熟度和稳定性已经到了一个很高的水平，虽然各种轮子层出不穷，但是技术体系和架构已经趋于稳定，这个时候，如何管理好团队使用的技术栈，既不“故步自封”，也不“横冲冒进”，是现在前端团队、终端团队管理者需要重点关注的问题。而今年，D2也推出了前端管理的主题，几位有丰富经验的前端团队 Leader 向大家分享了他们的经验。</p>\n<p>其中，让笔者感触最深的是 <strong>月影</strong> 带来的 <strong>《自我成长的多元化团队》</strong>。笔者从之前的单打独斗，到现在带领团队一起奋战，团队成员的成长一直是笔者花费很大精力去关注但成效不多的地方，而遇到的问题大部分都在月影的分享中被提到，因此感触颇多。其中 <strong>“多元化”</strong> 和 <strong>“闭环”</strong> 是其中笔者觉得最为核心的两点。</p>\n<p>在一个团队内，包含着风格、性格、能力各不同的成员，如何让每个成员都能体现出应有的价值，一直是团队 Leader 所遇到问题中的比较棘手。尤其是向笔者所在团队 <a href=\"https://ymfe.org\" target=\"_blank\" rel=\"noopener\">YMFE</a> 这样的负责公司大前端础架构与中台方案的团队中，每个成员体现的价值与其能力有时候相差甚多。再加上，团队每年都会招入一些没有什么业务经验的应届生，如何让应届生表现出其突出的价值，以致让团队认为其值得培养，并倾斜资源，也是件很闹心的事情。</p>\n<p>在这里，月影提出一个观点 —— <strong>“重组织、轻管理”</strong>，对每个人单独的管理不如更宏观地规划处一系列的“大道”，让成员自行选择。当然，这里的一系列“大道”肯定要满足两个条件，就是上文所说的“多元化”和“闭环”（下图是 <strong>奇舞团</strong> 的多元化、多维度的成长空间）。虽然，当前团队也有类似的“大道”，但是维度并不足够；而且，当团队发展到一定的规模后，低维度的成长空间会可能会制约团队成员的行动力，所以，根据公司、团队自身情况建立不同的成长空间、成长路线是很有必要的，或许这将是笔者2018年在团队内主要推动的事情。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcly1fmnhttpnn4j319g0uyju3.jpg\" alt=\"\"></p>\n<p>相比于 “多元化”，笔者感觉 “闭环” 其实更为重要，不论是 “正面反馈” 还是 “负面反馈” 都是很有必要的。在一个纯技术团队中，成员自身的技术肯定在第一位，在技术之外，项目管理、新人导师、对外技术输出和分享等，都是很重要的。而在这些之中，尤其是 “对外技术输出和分享” 最难形成闭环，最难给从事者足够的反馈。有人说，形成闭环很简单，直接和绩效、晋升挂钩。当然只是一种方法，但它只能给成员压力，例如未完成时的“负面反馈”，而并没有带来更多的“正面反馈”。</p>\n<p>其实，增加团队影响力，让团队成员都有团队自豪感，是最好的回馈方式。虽然这一年，团队也搞了 Conf 会议，同时也有一些开源项目，但笔者觉得收到的“正面反馈”并没有预想的那么多，尤其对低级别和新加入的成员。这不仅仅要在形式上下功夫，更要加强团队中每个人的团队意识，这应该是下一年需要重点提升的。</p>\n<h3 id=\"第二小节-——-务实\"><a href=\"#第二小节-——-务实\" class=\"headerlink\" title=\"第二小节 —— 务实\"></a>第二小节 —— 务实</h3><p>在月影的分享中，有关管理者 <strong>“积极”</strong> 和 <strong>“保守”</strong> 的问题，也令人深省。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fmnhcizdegj31bg0ton2h.jpg\" alt=\"\"></p>\n<p>不管是积极的管理者还是保守的管理者，都很看重优秀的人才和高效的组织，因为优秀的人才加上高效、稳定的组织，才能形成一个优秀的团队。关于这点，绝大多数人都知道，并且有一定的认识。所以，笔者在这里就不多做赘述了，而谈一下，对前三点的看法和思考。</p>\n<p>首先，对于 “保守” 这个偏贬义的词，笔者认为用 <strong>“务实”</strong> 更为贴切。直白点说，工资是公司发的，给公司创造价值才是当务之急，把技术用于业务、用于产品，减少业务的风险，或许是公司管理层更愿意看到的。打个比方，即时写了一个前无古人后无来者的无敌框架，如果不被业务所采用，到头来产出的也就那么几千行代码而已。</p>\n<p>这里，可能读者会认为笔者是个偏“保守”的管理者，其实并不是。笔者是个大白羊，一往直前的创新绝对是不可磨灭的欲望，但是笔者更倾向于在“保守”的基础上“积极”，在“务实”的肩膀上“创新”。创新是着眼于未来，但你的创新是否对未来有效，却不能空口无凭。因此，所谓的创新要在务实的场景中提炼，提炼出未来所需要的创新。讲一个很简单的逻辑，在务实业务的过程中，发现了业务的痛点，需要一种新方式来解决，因此去创新。这样能保证你的创新不管结果怎样，出发点是有意义的，是可以被大家认同的。就像 React Native，它解决了业务急需热更新的需求的同时，提升了体验，做出了比 Web 更好的体验效果，因此受到了大家的青睐。而现在，React Native 的劣势也表现出来，例如，因为通信的瓶颈，List 的效率堪忧，再例如，Native 实现的组件不能热更新（至少 iOS 不行），这种情况下，我们又要如何去解决了？是做微创新，直接切入痛点，解决问题；还是做大创新，提出一个比 React Native 更好的架构形式，这才是管理者应该去深入考虑的。</p>\n<h3 id=\"第三小节-——-中台\"><a href=\"#第三小节-——-中台\" class=\"headerlink\" title=\"第三小节 —— 中台\"></a>第三小节 —— 中台</h3><p>在上面的叙述中，笔者提到了“中台”这个词，并把团队的部分工作称为“中台方案”。其实，“中台”这个词，笔者是在 D2 上才关注到的，因为很多分享都提到了“中台”这个概念，也可能是因为分享人大多是阿里系的有关。“大中台，小前台”是阿里巴巴在2015年底提出的公司级战略，之后很多公司效仿，让很多之前的“公共支持团队”变成现在的“平台事业部”。公司战略层面的高深意义不是笔者一个小技术人员能理解的，不过，仅限技术而言，这样的战略，会减少多团队干一件事的概率，同时也让想做技术的同学可以一直单纯的做技术，不用去想“30后做管理，40后当经理”的事情。这或许是，单纯喜欢做技术的同学一个福音吧。（下图是2016年初阿里基于“大中台、小前台”战略制定的集团整体组织架构）</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fmzy0kt0i0j30hs0apq3h.jpg\" alt=\"\"></p>\n<p>中台是什么？给前台提供工具、服务、模块等公共、统一化的资源。对于大前端技术来说，构建工具、开发平台、服务平台、公共组件都算作中台的范畴。在大前端基础架构趋于稳定的情况下（前端React、Angular、Vue 三分，客户端原生、Hybrid、React Native（包括类 RN）三分），除了基于现有架构，适配自身公司的基础研发外，更多的是，给业务提供技术方案支持，让业务方更快地进行开发迭代，这或许是当前大前端重点要做的。</p>\n<p>当然，唯“中台”论，有时候也比较“可怕”。当前台的技术人员只关心业务，同时中台的技术人员不能提供满足前台的技术需求，这将是很可怕的一件事，因为很难弥补中间的空缺，或者这个问题成为拉锯战。因此，作为“中台”部分的工程师，要承受更大的压力，并拥有更深的技术。</p>\n<h3 id=\"第四小节-——-修养\"><a href=\"#第四小节-——-修养\" class=\"headerlink\" title=\"第四小节 —— 修养\"></a>第四小节 —— 修养</h3><p>在“大中台，小前台”的环境中，大前端工程师，要有怎样的 <strong>技术修养</strong> 呢？直接贴 <strong>盒马岑安</strong> 的三张 PPT。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNc79ly1fn00go6qw3j31kw0vub2c.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNc79ly1fn00haco76j31kw0w11l1.jpg\" alt=\"\"></p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fn00hnmcdaj31kw0vg1l0.jpg\" alt=\"\"></p>\n<p><strong>“以史明鉴”</strong> 一直是很好的分析方式。通过回顾前端的发展历程，每个阶段的技术，都是为了解决这个阶段的难题与痛点。虽然说，图中跟多是前端的内容，但是客户端与之是类似的。因此，可以说，大前端已经解决了从内容承载到体验优化，在从副交互到工程化，甚至包括开发模式等各个方面的问题，而解决这些问题的能力是当前大前端工程师的基本要求。</p>\n<p>而现在呢？未来呢？笔者谈谈自己的想法。在业务形式不断扩展，“中台”变大的时代，大前端工程师，尤其是做架构的大前端工程师，更多地需要能 <strong>耐得住寂寞</strong>。不同于前几年，一个优秀的架构方案，可以翻江倒海；而现在，包括将来，要做的更多是为业务提供服务的工作，稳定和完善是关键。或者，你可能已经感受不到获得感，但是你做的东西的实际价值或许会更高，因为它会支撑比现在更多的业务。</p>\n<p>最后，贴一张“核心竞争力”的 PPT —— 不仅仅要 <strong>拆解</strong> 后 <strong>输出</strong> ，更要 <strong>落地</strong> 于 <strong>业务</strong>。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fn011cfxwzj31kw0vwx6r.jpg\" alt=\"\"></p>\n<h3 id=\"第五小节-——-更好\"><a href=\"#第五小节-——-更好\" class=\"headerlink\" title=\"第五小节 —— 更好\"></a>第五小节 —— 更好</h3><p>作为中台特征明显的大前端架构，究竟要做什么？或许是，<strong>更完善的生态</strong> 和 <strong>更好的服务</strong>。</p>\n<p>很简单的一个道理，当人吃饱了，就会要求吃得好、吃得方便、吃得有营养了。做架构也一样，当架构可以满足业务需求后，业务就会反过来，要求架构更稳定、更易用了。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNc79ly1fmzyufh1ruj31jg0vugwn.jpg\" alt=\"\"></p>\n<p>上面是 <strong>支付宝加里</strong> 分享了一张PPT，类似的 Q 还包括很多，“为什么代码还是原来的”、“为什么点击没反应”、“iOS 没毛病，Android 挂了”。对于这类繁多的业务人员反馈的问题，是烦人也棘手的；你不能奢求业务人员去自己解决，况且有些问题，业务人员根本解决不了。在这时，你就需要一个完善的工具、服务等等其他的一些东西，来快速定位问题，或者来证明“问题不是框架的，是业务自身的”。因此，在未来一年或者几年，对于中台、对于大前端的架构团队，<strong>更完善的生态</strong> 和 <strong>更好的服务</strong> 应该被首要关注的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>2017仍是大前端火热的一年，但发展也已经从“野蛮生长”变为“颇具匠心”，越来越多稳定成熟的架构方法被广泛使用。与此同时，时代的热点已经转到机器学习和加密货币，而主项是 UI 的大前端发展又将何去何从呢。或许历史已经给出答案，传统后端默默地做了许久的模块化、服务化，伴随着云的兴起，又迎来新一春。或许，大前端的“中台化”，是大前端发展接下来最重要的一步。</p>\n<p>2018，新的一年，你好。</p>\n<p>D2 更多视频 和 PPT 信息，请访问官网：<a href=\"https://d2forum.alibaba-inc.com/\" target=\"_blank\" rel=\"noopener\">https://d2forum.alibaba-inc.com/</a></p>"},{"title":"区块链技术与其在旅游行业的应用","date":"2018-01-11T15:00:00.000Z","thumbnailImage":"https://ws2.sinaimg.cn/large/006tKfTcly1frsd3cqxtcj315g0e6b29.jpg","_content":"\n前几日，天使投资人徐小平的内部讲话 **“鼓励创业者拥抱区块链革命”** 刷爆了微博和朋友圈，而同时笔者刚好读完一本有关区块链技术的书 **《人工智能时代，一本书读懂区块链金融》** ，在读的同时也思考了下自己所处的行业，找到了一些相似的场景。因此，借此机会，与大家谈谈自己在学习区块链技术过程中的一些感受，并畅想一下在旅游行业区块链技术的应用。<!-- more -->\n\n\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fnbyj1ruzhj30ku0beh1z.jpg)\n\n先说说这本书，在亚马逊 Kindle Unlimited 榜上排名挺高的，在“IT产业与文化”分类中是最畅销的。个人觉得写得还是很不错的，对区块链技术讲得比较深入，只不过中后部分的内容，大多是把前面所讲过的理论翻来覆去地阐述，感觉越读到后面，营养价值越低。它排名高，可能跟它的书名有关，又是“人工智能”，又是“金融”。总体来讲，值得一读，不过中后半部分不用太详细去读。\n\n## 区块链技术是什么\n\n谈到区块链，就必须说数字货币、比特币。就像人工智能是机器学习、深度学习的表象一样，数字货币其实也是区块链技术的一种表象，一种技术的运用方式。极大可能是由于和“钱”有关，所以让大家的视线更多关注在数字货币或比特币上。这样也好，我们可以先谈谈数字货币中的王者—— **比特币（BitCoin）**。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnbztkt5crj30xc0irak7.jpg)\n\n任何事物，都要辩证地来看。一方面，比特币改变了金融的形态，让交易不通过银行等交易中心就能交易，更方便、更快捷；而另一方面，比特币绝大部分交易是用于洗钱、网络勒索、非法交易、逃避外汇管制等非法行为，很少真正用于我们大家的生活中。从上面这些内容，可以总结出，比特币最重要的几个特点： **去中心化** （不用通过银行）、**安全**（不可靠谁用？）、**可信** （不可信谁用？）、**匿名**（逃避监管）、**交易记录不可修改**（洗完钱，撤销了？）。\n\n而区块链正是用来实现这几种特征的技术：\n\n* 去中心化 —— **分布式数据库**，当然和平常接触的关系型、非关系型数据库不一样，它是 **基于数据区块的数据库**，而且每一个节点，都有查询所有数据的权限。\n* 安全 —— **加密算法**，将交易信息进行 **RSA 非对称加密** 后，再进行传输，所有第三方都能知道交易发生的时间和数量，但谁也不知道，交易双方是谁。\n* 可信 —— **智能合约**，一种共识机制，可以比喻成 **用代码实现的合同**，交易时会严格按照这套代码实现的逻辑来执行，**理论上不会有任何违约行为**。\n* 匿名 —— **完全数字化**，代表一个用户的只是一串秘钥，持有这串秘钥，就认为是这个用户。连转账双方，都不能准确知道对方具体是谁，只知道账户地址。\n* 记录不可修改 —— **已有区块不可修改**。理论上，所有基于区块链的应用都能做到这点，但是现在知名的项目中，好像只有比特币这样做了（这也是比特币价值高的原因之一）。当然，不可修改也不是100%绝对的，在后面讲弊端那一节里，会提到 **51% 算力问题**。\n\n总结来说，区块链就是 **完全数字化的包含共识机制的加密且不可修改的分布式数据区块数据库技术**。这是笔者凭借自己的理解，给出的定义。对于新技术，每个人会由于理解的不同，导致给出的定义也不尽相同，这其实是很正常的，大家都可以有自己心中的定义，各抒己见，多多交流。\n\n区块链技术是什么，大家了解了，那么，区块链技术到底能解决什么问题呢？绝不只是洗钱这么简单。\n\n## 区块链技术能解决什么问题\n\n讨论技术解决的问题，肯定要看技术所具有的特征。区块链技术最重要的三个特征就是 **去中心化**、**智能合约**、**安全**（匿名和不可修改，都可以算作安全的一部分）。很多人看到这三个特点，就会直接想到“金融”。当然，也可能是因为当前区块链技术主要用于金融，所以总结出的特点肯定和金融相关。不过，这些确实是区别于其他技术的特征。\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fncqxxz0hij30rs0fxq5b.jpg)\n\n### 去中心化 —— 信任问题\n\n对于信任问题，基于金融场景讲，可能更容易被理解。虽然说，最近几年，互联网金融的崛起，让传统金融备受打击，但是，互联网金融并没有解决传统金融中的信任问题。传统金融是建立在客户对银行、基金公司等实体金融机构信任的基础上；而互联网金融则是建立在客户对支付宝、P2P 信贷公司等网络交易所（虚拟金融机构）信任的基础上。当然，信任来源于很多方面，例如人际关系、权威性、口碑等等，但这些信任都是针对金融产品发行方、运营方等中心的，而不是对金融产品本身。这就容易让客户产生 **大的金融机构的金融产品一定比小的金融机构的要好、要靠谱** 的主观想法，而不去真正关心金融产品本身的风险程度。\n\n区块链技术带来了去中心化的思路，让每个客户手里都有 **一份完整的账本**，让所有客户都可以随意查看金融产品所有的交易、运作信息，并且，**这份账本的真实性不是由金融机构保障，而是通过区块链技术让所有客户一起保障**。这样就让用户的信任从金融机构转向了金融产品本身。与此同时，金融机构也可以减少为了维护金融产品的正常运作所产生的审计、监管等诸多方面的人力、物力、资源成本。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcly1fncqwpsdk4j30p00dwgoc.jpg)\n\n那么，“让所有客户一起保障”的逻辑是如何实现的呢？通过区块链技术，在产品设计的时候，**编写程序代码来制定这个产品的所有交易（数据交互）规则**，然后任意节点（运营发行方和客户）进行交易（数据交互）时，会通过网络，将这个操作发送给其他节点，**待其他节点确认这个操作符合规则** 时，交易（数据交互）即完成，并将记录写入数据区块中，同步给所有节点（运营发行方和客户），让所有节点（运营发行方和客户）可随时查看。\n\n在整个过程中，**规则制定** 和 **规则确认** 是非常重要的两个关键点。其中 “规则确认”，是去中心化带来的机制，就是让所有节点（主要是客户）参与到规则的确认中（一般都是超过半数确认就认为是符合规则的），避免产品运营发行方进行违规操作。而 “规则制定” 就是下一节要讲的 **智能合约**。\n\n### 智能合约 —— 违约问题\n\n在人类社会人与人的交互中，会出现各种 **合约**，有口头的，有书面的，有电子的，不过这些合约都有一个共同的特点 —— **用文字描述**。这样很容易出现下面几类问题：\n\n* 合约双方，对文字描述的理解不一致，造成违约。\n* 违约后，违约一方容易在文字上做文章，让监管、仲裁甚至法院都难以决断。\n* 签订合约时，在文字上做手脚，故意挖坑。\n\n而且，在合约的执行上，需要第三方进行监管，才能让合约双方完全按照合约执行，因此，会出现一些成本。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcly1fncrbed0gyj30p00dvn0f.jpg)\n\n但是 **智能合约** 不一样，它是 **通过程序代码来描述规则**，可以准确执行，避免造成不同的人有不同理解的问题，从而有效规避违约问题。同时，即使有人利用规则漏洞做出了违约的行为，它的行为也将会永久被记录下来，不可修改，这个记录会为违约处理提供准确依据。\n\n智能合约看上去，就是一段可执行代码，可以准确执行即可。但是为什么，传统技术就很难实现呢？为什么要基于区块链技术才行呢？\n\n* 去中心化，让智能合约不能轻易被一个节点或某几个节点修改。\n* 产生的数据无法删除、修改，只能新增数据，保证了历史的可追溯性。\n* 基于数据无法删除、修改，让违约成本变高，因为违约记录永远被记录，永远不会被删除。\n\n不论是去中心化，还是智能合约，都是通过技术的形式解决现实中的问题，但是不论方案怎么优秀，只要安全上有漏洞，被人攻破，造成信息的错误，那么这个方案就会立刻变得一分不值。所以，下一节我们要谈谈安全。\n\n### 安全 —— 隐私泄露问题\n\n其实安全问题，一直是区块链技术面临的最大问题，这点会在区块链存在的弊端那一节中讲到。而在这一小节，笔者要讲的安全，是区块链技术对隐私方面做的保护。\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fnctitnokrj30k00c0wmg.jpg)\n\n完全匿名化，是当前区块链技术的特征和核心优势，虽然匿名直接导致黑产的不断蔓延，但是它也同时有效保证了交易的私密性。拿比特币为例，第三方只能看到交易的时间、数量等一些信息，但是并不能看到交易的双方的信息，甚至同样交易方的两次交易，都很难被第三方归并为同样交易方的交易。因此，交易双方可以很放心地进行安全的交易，而不暴露自己的任何隐私信息。\n\n### 小结\n\n这里提到的三个特征其实是相辅相成的：没有智能合约，去中心化只能靠人为自觉执行，监管成本反而会增大；没有去中心化，智能合约由中心独占，随意修改，也就不能称作“合约”了；如果不安全，再去中心化，再智能合约化，一旦被黑客攻破，所有都会直接归零；而也正是因为去中心化加上智能合约，才让违反规则的成本大大升高，从而让产品变得更安全了。在这个技术高速发展的时代，很少有一项技术单独靠一项特性就可以“称霸潮流”的，区块链这种融合多种特性，从很多层面解决问题的技术方案，应该是以后技术的发展方向。\n\n这一节讲了很多区块链在实际中解决的问题，但大多数都是基于金融场景的。其实金融本质上更像一个信息行业，据统计 90% 金融利润的来源，来自于信息的收集、分析、处理的过程中，因此信息对金融的重要程度非同一般。而，区块链技术其实就是对信息的 **创建**、**加密**、**验证**、**处理**、**存储**、**分发** 等过程实现了一个 **基于网络**、**安全可靠**、**可编程** 的机制，从而解决了金融场景的问题。因此，也可以看出，任何对信息有高度要求的行业都是适用区块链技术的，例如 **新零售行业**、**通信领域**、**审计行业**、**医疗产业**、**共享经济** 等等。（下面是网络上的一张区块链应用的图）\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fncqyowxsvj30rs0jsmzw.jpg)\n\n当然，旅游行业也是一个基于信息的产业，因此区块链技术应该在旅游产业中也有用武之地。\n\n## 区块链在旅游行业的应用\n\n虽然有很多旅游行业的公司，都声称要搞区块链，但是实际落地并有成效的并不多，更多属于实验阶段：\n\n* Webjet 正在开发一种解决方案，利用以太坊的私有版本追踪世界各地酒店房间的库存情况。希望确保消费者和他们的酒店之间的所有中介都能获得报酬，以帮助预订。这与区块链技术最初的初衷完全相反，即移除中间的人。。。。。\n* TUI Group 正考虑将所有数据转移到一个私有版本的以太坊上，以去除 Expedia 和预订等中间商。\n* S7 公司已经与俄罗斯的 Alfa-Bank 合作，减少了航空公司和代理商之间的结算时间。解决方案建立在以太坊的私有版本上。\n* Innfinity 软件系统将使用区块链技术，让他们的在线预订工具能够提供 NDC 的内容，并以“目前不可能通过其他标准实现的方式”组合内容和服务。他们的解决方案基于以太坊的一个私有项目来实现。\n* 国际贸易协会在2016年的世界金融研讨会上展示了一种基于区块链技术的数字货币—— IATA（国际航协）硬币的概念。虽然还没有给出具体的细节，但看看IATA通常是如何创新的，如果他们决定在公共关系链上推出这个项目，我将会大吃一惊。\n* 等等。。。。。。\n\n（*上面的示例从 36kr 上 [《区块链技术能颠覆旅游行业吗？》](https://36kr.com/p/5090300.html) 文章中摘抄*）\n\n因此，笔者在学习区块链技术的时候，一直在考虑旅游行业的一些突出问题，是否能使用区块链技术去解决，应该用什么方式去解决。在调研了一些方案后，结合自己的想法，给大家介绍一些解决常见问题的例子。\n\n### 机票超售问题\n\n去年，**美联航机票超售** 问题无数次出现在新闻中，让大家对航空公司的好感跌到低谷。造成机票超额预定的原因是航空公司不愿意虚耗座位，所以航空公司会在容易出现空置的座位上进行适当的超售，这是 **航空界的通行做法**。但是这种做法，从乘客的角度来说，肯定算是“**霸王条款**”。但是，在乘客登机出现问题之前，是无法确定是否超售的。只有航空公司销售部门的部分人知道，但他们肯定不会说；航空监管部门获取真实售票数据或许也比较困难。这类问题如何解决呢？\n\n![](https://ws2.sinaimg.cn/large/006tKfTcly1fnd2jc83ezj30rs0lbtcx.jpg)\n\n其实，这个问题和网络支付中的“双花”问题很类似，从理论上区块链技术可以消除航空业和其他交通运输业的双重预定问题。\n\n一旦航空售票记录被验证并加入到区块链中，就会永久的存储起来，除非同时控制超过半数的节点，否则售票记录无法篡改。同时，由于数据是高度透明的，所有乘客都可以看到销售记录，肯定不会发生超售现象。而且，由于区块链的特性，乘客也不会知道其他销售记录是卖给谁的。\n\n区块链技术采用了一种公开透明的去中心化的算法，使消费者对“航空公司”的信任，转变为对“智能合约”的信任，能够塑造更好的形象。当然，这些只是理想状况，除非超售由法律裁定是违法行为，否则很难实施。\n\n不过，区块链可以运用到航空业其他地方，例如机场和飞机的通信、乘客身份验证等。\n\n\n### 网约车高额抽成问题\n\n网约车虽然不完全属于旅游行业，但是它是旅游行业里主要的一环。当网约车过了多家平台的竞争期之后，车费抽成越来越高，大概在 5%~25% 之间，有的甚至更高。排除运营商的盈利策略，本身维护庞大的运营平台就有很高的人力、物力成本。\n\n从理论上，区块链技术可以帮助平台解决这类问题，降低维护平台的成本。网约车业务，其实就是乘客与司机的 P2P 业务，很适用区块链技术，这样可以大幅度降低平台数据存储的成本。同时基于区块链技术，实现价格算法透明化，让所有司机、乘客都可以无障碍地看到每个行程的详情及具体收费情况。\n\n### 酒店预定管理\n\n当前酒店行业存在已久的问题之一就是其供应链各个环节间容易出现信息遗漏、丢失等情况，这不仅会影响酒店的工作效率，还有可能会造成巨大的经济损失。而与网约车相似，酒店预订也可以近似的看为酒店与房客的 P2P 业务，而现在为了保证信息的充分传播（让更多潜在房客知道酒店信息），会加入很多供应商、中间商，最终造成中间环节容易出问题而且由于佣金的存在房价不是很便宜。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnd5dfjg79j30p00dwtad.jpg)\n\n而使用区块链技术，将“链”升级，创建一个比当前所有参与者使用的 **更高效**、**更安全** 以及 **更低成本** 的供应链，让客户预定酒店 **更准确**（不会出错）、**更实时**（不用供应商二次确认）、**更便宜**（避免佣金），让客户从信任供应商、信任酒店，变为信任这个以技术搭建的平台。\n\n### 小结\n\n其实，有一个概念在前文中被弱化了，那就是 **“算力”**。按照去中心化的智能合约，每个节点都有验证行为的能力，验证的速度就是算力。让用户提供算力，在现在来看是很困难的，让用户设备上天天跑个程序提供算力（在一部分数字货币中，被称作矿工），其实是不现实的。但是如果用户不提供算力，那么事实上，都是规则制定方自己提供算力，那么去中心化其实并没有实现，智能合约不如一张废纸。介于这种情况，其实可以将更多方放入链路中来。例如，如果要解决机票超售问题，可以以监管部门、航空公司、机票经销商为节点建立区块链，这样多方制约，来维持去中心化的智能合约。\n\n任何基于信息的，有交易过程的行业，都有金融业相似的问题，而区块链技术可能正是解决这些问题的良药。或许区块链技术的去中心化会触动很多人的利益，但是只有变革才能更好的发展，发展才会有更好的利益。\n\n## 当前区块链技术存在的弊端\n\n在这个区块链技术（主要是数字货币）百花齐放、大红大紫的时代，其实很多技术弊端都被光芒所掩盖，而一些技术弊端可能是致命的。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnd55zpp9bj30rs0gltbq.jpg)\n\n### 安全性\n\n首当其冲是安全性，因为安全性是一切应用的根本，尤其是现在信息时代，一点漏洞，都可能造成大麻烦。\n\n从算法来讲，目前区块链的算法 **相对安全**。为什么说相对？因为随着数学、密码学和计算科学的发展，它的安全性越来越弱。实现上，由于区块链大量应用了各种密码学技术，属于算法高度密集工程，在实现上比较容易出现问题。例如，它使用了 NSA 的 RSA 算法，RSA 算法如果有缺陷（历史上有先例），可被轻易破解，一旦爆发，结局将会是毁灭。再者，即使没被破解，纯暴力破解也是有可能的。据估计，以目前“天河二号”的算力来说，产生比特币 SHA256 哈希算法的一个哈希碰撞大约需要 248 年，而用正在研制中的“天河三号”的话，才需要 10 年。而且随着量子计算机的不断发展，算法层面面临的潜在安全威胁会越来越大。\n\n从协议来讲，基于 PoW 共识过程的区块链主要面临的是 **51% 攻击问题**，即节点通过 **掌握全网超过 51% 的算力就有能力成功篡改和伪造区块链数据**。简单来说，如果你掌握了 51% 的算力，你自己就把你的非法操作反过来确认为符合规则的。虽然，犯罪成本很高，但是不排除有人出于某种目的，进行这种攻击。\n\n从使用来讲，区块链技术一大特点就是不可逆、不可伪造，但 **前提是私钥是安全的**。私钥是用户身份的唯一证明，没有第三方可以知道你的私钥。一旦私钥被盗取，你无法证明，资产是自身的；一旦丢失，你的资产也会凭空消失，无法找回。\n\n从匿名来讲，规避了监管的同时，可能向节点中加入现实中不可信用户，跟这些用户进行交易后，对方直接“跑路”，是无法追踪到的。\n\n### 监管性\n\n区块链的初衷是没有监管，但是在设计区块链产品时，在制定智能合约时，难免有疏漏。这时，不法分子 **利用漏洞** ，不管使用正规手段还是非正规手段，都可以获利。这种情况下，如果没有监管的存在，是非常危险的，而且危险是不可控的。所以，区块链技术最新的发展趋势中，加入监管是一大话题。当然，这里的监管，不是人为的监管，而是用技术，用程序逻辑去监管。\n\n笔者认为，不论是什么技术，都会有其疏漏的地方。使用程序监管，只能尽量规避漏洞，提高犯罪成本。可成本多高，才能算安全呢？\n\n### 易用性\n\n对于一个技术人员，区块链产品，例如数字货币，使用起来还是没有什么障碍的，但是对于普通人来说还是有一定的学习成本的。例如，当决定加入一个基于区块链技术的金融产品时，你要知道合约到底是什么。这样，理论上你需要在通读并理解智能合约的代码后，才能完全清楚合约内容（听销售人员说，其实会出现信任问题）。不仅仅是读代码，怎么安全地保存自己的私钥，也是存在不小技术成本的地方。甚至，现在比特币所有区块的数据量 **将近 150G**，你如何存储？虽然提供精简模式，才 2~3 G，不过在精简模式下重新扫描、导入钱包、导入地址、导入私钥这些功能都不能用，而且一旦数据出错，必须同步所有数据。同步这么大量的数据，是非常麻烦的。（这里，笔者其实自己有个疑问，如果每个节点都采用精简模式，之前的历史数据会不会都丢了？）\n\n### 网络性\n\n区块链项目的运行依赖于网咯，不管是人为还是非人为造成 **世界级网络的瘫痪**，例如战争、自然灾害，区块链项目将会如何运行？\n\n### 承载性\n\n区块链因为其独特去中心化的验证机制，才保证信息的安全性。不过，也正因为这样，每次交易，所消耗的时间成本也会比一般网络交易要高。仍旧用比特币做例子，以现在的算力和平均的网络传输速度，比特币 **一天** 最多只能支持 **65 万笔** 左右的交易。相比 2017 年支付宝双十一 **25.6 万笔/秒** 的速度，简直是天差地别。\n\n![支付宝2017年双十一支付数据](https://ws1.sinaimg.cn/large/006tKfTcly1fnd595pz5lj30nm0d7dlv.jpg)\n\n### 春哥性\n\n**信春哥，无 Bug**。但是谁能真的保证用区块链技术实现的产品里，没有 Bug。即使是比特币，也出过 Bug。在 2013 年，比特币客户端被升级到 v0.8 版本，允许单个区块能容纳更多的交易频次。不久以后，某个区块的交易次数过多，直接导致该区块一分为二。开发者社区只能对软件进行降级，同时撤销了数小时之内的交易（有些人的币回来了，钱却不退回去）。而且，中本聪在程序中是否留有后门，也是不可知的。\n\n### 小结\n\n区块链作为一个新兴技术，所存在的弊端还是很多的。但是，其中很多缺陷，可以通过技术升级的形式修复或者规避。最主要的，区块链技术不仅仅解决了当前遇到的问题，而且，它更多的初衷是 **面向自由、面向理想进行编程**，这也是区块链技术受大家追捧的原因之一。\n\n有弊端不怕，用技术的方式来解决。这是一个技术从业者应该做的，也愿意做的。\n\n## 总结\n\n任何一个区块链技术文章的作者，几乎都会被问一个问题：“你是否看好比特币？”。笔者的答案是“看戏”，原因是 **当前比特币的优点被放大了，缺点并不被大家所认知，有泡沫**；而同时 **几乎所有缺点都可以通过技术升级的方式修复，在缺点所带来的问题变大之前，通过技术手段修复，也是可以的**。\n\n这里会有人说：“ *世界知名传统银行都在区块链技术上大力布局，投入要超过绝大部分互联网公司，就连传统行业都认可数字货币，数字货币肯定会成为潮流* ”。其实看事情要辩证来看，笔者觉得传统银行更多是因为被互联网金融伤了，这次不想重蹈覆辙，抢先布局而已。而且，笔者想说的是，区块链技术不等于数字货币，更不等于比特币。而且基于信息产业的经济学，更多是一门社会科学，既然是社会科学，就不能排除人、团队、组织、政府的影响。传统银行重视区块链，不一定要做数字货币，很大可能用区块链技术去解决其他的金融问题。\n\n与对数字货币、比特币持保留态度相反，笔者对区块链技术是非常看好的，它不仅仅能解决金融问题，它更能在各个行业发挥作用，解决棘手问题。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnd5cf8olrj30rs0gojvn.jpg)\n\n对于新技术，每个人都会有自己不同的理解和认知，如果有理解错误的地方，欢迎指正，非常感谢。\n\n在最后，发自肺腑说一句 —— **欢迎拥抱区块链技术！**\n","source":"_posts/2018-01-11-the-use-of-block-chain-technology-in-tourism-industry.md","raw":"title: 区块链技术与其在旅游行业的应用\ndate: 2018-01-11 23:00:00\ncategory: 潮流技术\ntags: [区块链]\nthumbnailImage: https://ws2.sinaimg.cn/large/006tKfTcly1frsd3cqxtcj315g0e6b29.jpg\n---\n\n前几日，天使投资人徐小平的内部讲话 **“鼓励创业者拥抱区块链革命”** 刷爆了微博和朋友圈，而同时笔者刚好读完一本有关区块链技术的书 **《人工智能时代，一本书读懂区块链金融》** ，在读的同时也思考了下自己所处的行业，找到了一些相似的场景。因此，借此机会，与大家谈谈自己在学习区块链技术过程中的一些感受，并畅想一下在旅游行业区块链技术的应用。<!-- more -->\n\n\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fnbyj1ruzhj30ku0beh1z.jpg)\n\n先说说这本书，在亚马逊 Kindle Unlimited 榜上排名挺高的，在“IT产业与文化”分类中是最畅销的。个人觉得写得还是很不错的，对区块链技术讲得比较深入，只不过中后部分的内容，大多是把前面所讲过的理论翻来覆去地阐述，感觉越读到后面，营养价值越低。它排名高，可能跟它的书名有关，又是“人工智能”，又是“金融”。总体来讲，值得一读，不过中后半部分不用太详细去读。\n\n## 区块链技术是什么\n\n谈到区块链，就必须说数字货币、比特币。就像人工智能是机器学习、深度学习的表象一样，数字货币其实也是区块链技术的一种表象，一种技术的运用方式。极大可能是由于和“钱”有关，所以让大家的视线更多关注在数字货币或比特币上。这样也好，我们可以先谈谈数字货币中的王者—— **比特币（BitCoin）**。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnbztkt5crj30xc0irak7.jpg)\n\n任何事物，都要辩证地来看。一方面，比特币改变了金融的形态，让交易不通过银行等交易中心就能交易，更方便、更快捷；而另一方面，比特币绝大部分交易是用于洗钱、网络勒索、非法交易、逃避外汇管制等非法行为，很少真正用于我们大家的生活中。从上面这些内容，可以总结出，比特币最重要的几个特点： **去中心化** （不用通过银行）、**安全**（不可靠谁用？）、**可信** （不可信谁用？）、**匿名**（逃避监管）、**交易记录不可修改**（洗完钱，撤销了？）。\n\n而区块链正是用来实现这几种特征的技术：\n\n* 去中心化 —— **分布式数据库**，当然和平常接触的关系型、非关系型数据库不一样，它是 **基于数据区块的数据库**，而且每一个节点，都有查询所有数据的权限。\n* 安全 —— **加密算法**，将交易信息进行 **RSA 非对称加密** 后，再进行传输，所有第三方都能知道交易发生的时间和数量，但谁也不知道，交易双方是谁。\n* 可信 —— **智能合约**，一种共识机制，可以比喻成 **用代码实现的合同**，交易时会严格按照这套代码实现的逻辑来执行，**理论上不会有任何违约行为**。\n* 匿名 —— **完全数字化**，代表一个用户的只是一串秘钥，持有这串秘钥，就认为是这个用户。连转账双方，都不能准确知道对方具体是谁，只知道账户地址。\n* 记录不可修改 —— **已有区块不可修改**。理论上，所有基于区块链的应用都能做到这点，但是现在知名的项目中，好像只有比特币这样做了（这也是比特币价值高的原因之一）。当然，不可修改也不是100%绝对的，在后面讲弊端那一节里，会提到 **51% 算力问题**。\n\n总结来说，区块链就是 **完全数字化的包含共识机制的加密且不可修改的分布式数据区块数据库技术**。这是笔者凭借自己的理解，给出的定义。对于新技术，每个人会由于理解的不同，导致给出的定义也不尽相同，这其实是很正常的，大家都可以有自己心中的定义，各抒己见，多多交流。\n\n区块链技术是什么，大家了解了，那么，区块链技术到底能解决什么问题呢？绝不只是洗钱这么简单。\n\n## 区块链技术能解决什么问题\n\n讨论技术解决的问题，肯定要看技术所具有的特征。区块链技术最重要的三个特征就是 **去中心化**、**智能合约**、**安全**（匿名和不可修改，都可以算作安全的一部分）。很多人看到这三个特点，就会直接想到“金融”。当然，也可能是因为当前区块链技术主要用于金融，所以总结出的特点肯定和金融相关。不过，这些确实是区别于其他技术的特征。\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fncqxxz0hij30rs0fxq5b.jpg)\n\n### 去中心化 —— 信任问题\n\n对于信任问题，基于金融场景讲，可能更容易被理解。虽然说，最近几年，互联网金融的崛起，让传统金融备受打击，但是，互联网金融并没有解决传统金融中的信任问题。传统金融是建立在客户对银行、基金公司等实体金融机构信任的基础上；而互联网金融则是建立在客户对支付宝、P2P 信贷公司等网络交易所（虚拟金融机构）信任的基础上。当然，信任来源于很多方面，例如人际关系、权威性、口碑等等，但这些信任都是针对金融产品发行方、运营方等中心的，而不是对金融产品本身。这就容易让客户产生 **大的金融机构的金融产品一定比小的金融机构的要好、要靠谱** 的主观想法，而不去真正关心金融产品本身的风险程度。\n\n区块链技术带来了去中心化的思路，让每个客户手里都有 **一份完整的账本**，让所有客户都可以随意查看金融产品所有的交易、运作信息，并且，**这份账本的真实性不是由金融机构保障，而是通过区块链技术让所有客户一起保障**。这样就让用户的信任从金融机构转向了金融产品本身。与此同时，金融机构也可以减少为了维护金融产品的正常运作所产生的审计、监管等诸多方面的人力、物力、资源成本。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcly1fncqwpsdk4j30p00dwgoc.jpg)\n\n那么，“让所有客户一起保障”的逻辑是如何实现的呢？通过区块链技术，在产品设计的时候，**编写程序代码来制定这个产品的所有交易（数据交互）规则**，然后任意节点（运营发行方和客户）进行交易（数据交互）时，会通过网络，将这个操作发送给其他节点，**待其他节点确认这个操作符合规则** 时，交易（数据交互）即完成，并将记录写入数据区块中，同步给所有节点（运营发行方和客户），让所有节点（运营发行方和客户）可随时查看。\n\n在整个过程中，**规则制定** 和 **规则确认** 是非常重要的两个关键点。其中 “规则确认”，是去中心化带来的机制，就是让所有节点（主要是客户）参与到规则的确认中（一般都是超过半数确认就认为是符合规则的），避免产品运营发行方进行违规操作。而 “规则制定” 就是下一节要讲的 **智能合约**。\n\n### 智能合约 —— 违约问题\n\n在人类社会人与人的交互中，会出现各种 **合约**，有口头的，有书面的，有电子的，不过这些合约都有一个共同的特点 —— **用文字描述**。这样很容易出现下面几类问题：\n\n* 合约双方，对文字描述的理解不一致，造成违约。\n* 违约后，违约一方容易在文字上做文章，让监管、仲裁甚至法院都难以决断。\n* 签订合约时，在文字上做手脚，故意挖坑。\n\n而且，在合约的执行上，需要第三方进行监管，才能让合约双方完全按照合约执行，因此，会出现一些成本。\n\n![](https://ws3.sinaimg.cn/large/006tKfTcly1fncrbed0gyj30p00dvn0f.jpg)\n\n但是 **智能合约** 不一样，它是 **通过程序代码来描述规则**，可以准确执行，避免造成不同的人有不同理解的问题，从而有效规避违约问题。同时，即使有人利用规则漏洞做出了违约的行为，它的行为也将会永久被记录下来，不可修改，这个记录会为违约处理提供准确依据。\n\n智能合约看上去，就是一段可执行代码，可以准确执行即可。但是为什么，传统技术就很难实现呢？为什么要基于区块链技术才行呢？\n\n* 去中心化，让智能合约不能轻易被一个节点或某几个节点修改。\n* 产生的数据无法删除、修改，只能新增数据，保证了历史的可追溯性。\n* 基于数据无法删除、修改，让违约成本变高，因为违约记录永远被记录，永远不会被删除。\n\n不论是去中心化，还是智能合约，都是通过技术的形式解决现实中的问题，但是不论方案怎么优秀，只要安全上有漏洞，被人攻破，造成信息的错误，那么这个方案就会立刻变得一分不值。所以，下一节我们要谈谈安全。\n\n### 安全 —— 隐私泄露问题\n\n其实安全问题，一直是区块链技术面临的最大问题，这点会在区块链存在的弊端那一节中讲到。而在这一小节，笔者要讲的安全，是区块链技术对隐私方面做的保护。\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fnctitnokrj30k00c0wmg.jpg)\n\n完全匿名化，是当前区块链技术的特征和核心优势，虽然匿名直接导致黑产的不断蔓延，但是它也同时有效保证了交易的私密性。拿比特币为例，第三方只能看到交易的时间、数量等一些信息，但是并不能看到交易的双方的信息，甚至同样交易方的两次交易，都很难被第三方归并为同样交易方的交易。因此，交易双方可以很放心地进行安全的交易，而不暴露自己的任何隐私信息。\n\n### 小结\n\n这里提到的三个特征其实是相辅相成的：没有智能合约，去中心化只能靠人为自觉执行，监管成本反而会增大；没有去中心化，智能合约由中心独占，随意修改，也就不能称作“合约”了；如果不安全，再去中心化，再智能合约化，一旦被黑客攻破，所有都会直接归零；而也正是因为去中心化加上智能合约，才让违反规则的成本大大升高，从而让产品变得更安全了。在这个技术高速发展的时代，很少有一项技术单独靠一项特性就可以“称霸潮流”的，区块链这种融合多种特性，从很多层面解决问题的技术方案，应该是以后技术的发展方向。\n\n这一节讲了很多区块链在实际中解决的问题，但大多数都是基于金融场景的。其实金融本质上更像一个信息行业，据统计 90% 金融利润的来源，来自于信息的收集、分析、处理的过程中，因此信息对金融的重要程度非同一般。而，区块链技术其实就是对信息的 **创建**、**加密**、**验证**、**处理**、**存储**、**分发** 等过程实现了一个 **基于网络**、**安全可靠**、**可编程** 的机制，从而解决了金融场景的问题。因此，也可以看出，任何对信息有高度要求的行业都是适用区块链技术的，例如 **新零售行业**、**通信领域**、**审计行业**、**医疗产业**、**共享经济** 等等。（下面是网络上的一张区块链应用的图）\n\n![](https://ws1.sinaimg.cn/large/006tKfTcly1fncqyowxsvj30rs0jsmzw.jpg)\n\n当然，旅游行业也是一个基于信息的产业，因此区块链技术应该在旅游产业中也有用武之地。\n\n## 区块链在旅游行业的应用\n\n虽然有很多旅游行业的公司，都声称要搞区块链，但是实际落地并有成效的并不多，更多属于实验阶段：\n\n* Webjet 正在开发一种解决方案，利用以太坊的私有版本追踪世界各地酒店房间的库存情况。希望确保消费者和他们的酒店之间的所有中介都能获得报酬，以帮助预订。这与区块链技术最初的初衷完全相反，即移除中间的人。。。。。\n* TUI Group 正考虑将所有数据转移到一个私有版本的以太坊上，以去除 Expedia 和预订等中间商。\n* S7 公司已经与俄罗斯的 Alfa-Bank 合作，减少了航空公司和代理商之间的结算时间。解决方案建立在以太坊的私有版本上。\n* Innfinity 软件系统将使用区块链技术，让他们的在线预订工具能够提供 NDC 的内容，并以“目前不可能通过其他标准实现的方式”组合内容和服务。他们的解决方案基于以太坊的一个私有项目来实现。\n* 国际贸易协会在2016年的世界金融研讨会上展示了一种基于区块链技术的数字货币—— IATA（国际航协）硬币的概念。虽然还没有给出具体的细节，但看看IATA通常是如何创新的，如果他们决定在公共关系链上推出这个项目，我将会大吃一惊。\n* 等等。。。。。。\n\n（*上面的示例从 36kr 上 [《区块链技术能颠覆旅游行业吗？》](https://36kr.com/p/5090300.html) 文章中摘抄*）\n\n因此，笔者在学习区块链技术的时候，一直在考虑旅游行业的一些突出问题，是否能使用区块链技术去解决，应该用什么方式去解决。在调研了一些方案后，结合自己的想法，给大家介绍一些解决常见问题的例子。\n\n### 机票超售问题\n\n去年，**美联航机票超售** 问题无数次出现在新闻中，让大家对航空公司的好感跌到低谷。造成机票超额预定的原因是航空公司不愿意虚耗座位，所以航空公司会在容易出现空置的座位上进行适当的超售，这是 **航空界的通行做法**。但是这种做法，从乘客的角度来说，肯定算是“**霸王条款**”。但是，在乘客登机出现问题之前，是无法确定是否超售的。只有航空公司销售部门的部分人知道，但他们肯定不会说；航空监管部门获取真实售票数据或许也比较困难。这类问题如何解决呢？\n\n![](https://ws2.sinaimg.cn/large/006tKfTcly1fnd2jc83ezj30rs0lbtcx.jpg)\n\n其实，这个问题和网络支付中的“双花”问题很类似，从理论上区块链技术可以消除航空业和其他交通运输业的双重预定问题。\n\n一旦航空售票记录被验证并加入到区块链中，就会永久的存储起来，除非同时控制超过半数的节点，否则售票记录无法篡改。同时，由于数据是高度透明的，所有乘客都可以看到销售记录，肯定不会发生超售现象。而且，由于区块链的特性，乘客也不会知道其他销售记录是卖给谁的。\n\n区块链技术采用了一种公开透明的去中心化的算法，使消费者对“航空公司”的信任，转变为对“智能合约”的信任，能够塑造更好的形象。当然，这些只是理想状况，除非超售由法律裁定是违法行为，否则很难实施。\n\n不过，区块链可以运用到航空业其他地方，例如机场和飞机的通信、乘客身份验证等。\n\n\n### 网约车高额抽成问题\n\n网约车虽然不完全属于旅游行业，但是它是旅游行业里主要的一环。当网约车过了多家平台的竞争期之后，车费抽成越来越高，大概在 5%~25% 之间，有的甚至更高。排除运营商的盈利策略，本身维护庞大的运营平台就有很高的人力、物力成本。\n\n从理论上，区块链技术可以帮助平台解决这类问题，降低维护平台的成本。网约车业务，其实就是乘客与司机的 P2P 业务，很适用区块链技术，这样可以大幅度降低平台数据存储的成本。同时基于区块链技术，实现价格算法透明化，让所有司机、乘客都可以无障碍地看到每个行程的详情及具体收费情况。\n\n### 酒店预定管理\n\n当前酒店行业存在已久的问题之一就是其供应链各个环节间容易出现信息遗漏、丢失等情况，这不仅会影响酒店的工作效率，还有可能会造成巨大的经济损失。而与网约车相似，酒店预订也可以近似的看为酒店与房客的 P2P 业务，而现在为了保证信息的充分传播（让更多潜在房客知道酒店信息），会加入很多供应商、中间商，最终造成中间环节容易出问题而且由于佣金的存在房价不是很便宜。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnd5dfjg79j30p00dwtad.jpg)\n\n而使用区块链技术，将“链”升级，创建一个比当前所有参与者使用的 **更高效**、**更安全** 以及 **更低成本** 的供应链，让客户预定酒店 **更准确**（不会出错）、**更实时**（不用供应商二次确认）、**更便宜**（避免佣金），让客户从信任供应商、信任酒店，变为信任这个以技术搭建的平台。\n\n### 小结\n\n其实，有一个概念在前文中被弱化了，那就是 **“算力”**。按照去中心化的智能合约，每个节点都有验证行为的能力，验证的速度就是算力。让用户提供算力，在现在来看是很困难的，让用户设备上天天跑个程序提供算力（在一部分数字货币中，被称作矿工），其实是不现实的。但是如果用户不提供算力，那么事实上，都是规则制定方自己提供算力，那么去中心化其实并没有实现，智能合约不如一张废纸。介于这种情况，其实可以将更多方放入链路中来。例如，如果要解决机票超售问题，可以以监管部门、航空公司、机票经销商为节点建立区块链，这样多方制约，来维持去中心化的智能合约。\n\n任何基于信息的，有交易过程的行业，都有金融业相似的问题，而区块链技术可能正是解决这些问题的良药。或许区块链技术的去中心化会触动很多人的利益，但是只有变革才能更好的发展，发展才会有更好的利益。\n\n## 当前区块链技术存在的弊端\n\n在这个区块链技术（主要是数字货币）百花齐放、大红大紫的时代，其实很多技术弊端都被光芒所掩盖，而一些技术弊端可能是致命的。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnd55zpp9bj30rs0gltbq.jpg)\n\n### 安全性\n\n首当其冲是安全性，因为安全性是一切应用的根本，尤其是现在信息时代，一点漏洞，都可能造成大麻烦。\n\n从算法来讲，目前区块链的算法 **相对安全**。为什么说相对？因为随着数学、密码学和计算科学的发展，它的安全性越来越弱。实现上，由于区块链大量应用了各种密码学技术，属于算法高度密集工程，在实现上比较容易出现问题。例如，它使用了 NSA 的 RSA 算法，RSA 算法如果有缺陷（历史上有先例），可被轻易破解，一旦爆发，结局将会是毁灭。再者，即使没被破解，纯暴力破解也是有可能的。据估计，以目前“天河二号”的算力来说，产生比特币 SHA256 哈希算法的一个哈希碰撞大约需要 248 年，而用正在研制中的“天河三号”的话，才需要 10 年。而且随着量子计算机的不断发展，算法层面面临的潜在安全威胁会越来越大。\n\n从协议来讲，基于 PoW 共识过程的区块链主要面临的是 **51% 攻击问题**，即节点通过 **掌握全网超过 51% 的算力就有能力成功篡改和伪造区块链数据**。简单来说，如果你掌握了 51% 的算力，你自己就把你的非法操作反过来确认为符合规则的。虽然，犯罪成本很高，但是不排除有人出于某种目的，进行这种攻击。\n\n从使用来讲，区块链技术一大特点就是不可逆、不可伪造，但 **前提是私钥是安全的**。私钥是用户身份的唯一证明，没有第三方可以知道你的私钥。一旦私钥被盗取，你无法证明，资产是自身的；一旦丢失，你的资产也会凭空消失，无法找回。\n\n从匿名来讲，规避了监管的同时，可能向节点中加入现实中不可信用户，跟这些用户进行交易后，对方直接“跑路”，是无法追踪到的。\n\n### 监管性\n\n区块链的初衷是没有监管，但是在设计区块链产品时，在制定智能合约时，难免有疏漏。这时，不法分子 **利用漏洞** ，不管使用正规手段还是非正规手段，都可以获利。这种情况下，如果没有监管的存在，是非常危险的，而且危险是不可控的。所以，区块链技术最新的发展趋势中，加入监管是一大话题。当然，这里的监管，不是人为的监管，而是用技术，用程序逻辑去监管。\n\n笔者认为，不论是什么技术，都会有其疏漏的地方。使用程序监管，只能尽量规避漏洞，提高犯罪成本。可成本多高，才能算安全呢？\n\n### 易用性\n\n对于一个技术人员，区块链产品，例如数字货币，使用起来还是没有什么障碍的，但是对于普通人来说还是有一定的学习成本的。例如，当决定加入一个基于区块链技术的金融产品时，你要知道合约到底是什么。这样，理论上你需要在通读并理解智能合约的代码后，才能完全清楚合约内容（听销售人员说，其实会出现信任问题）。不仅仅是读代码，怎么安全地保存自己的私钥，也是存在不小技术成本的地方。甚至，现在比特币所有区块的数据量 **将近 150G**，你如何存储？虽然提供精简模式，才 2~3 G，不过在精简模式下重新扫描、导入钱包、导入地址、导入私钥这些功能都不能用，而且一旦数据出错，必须同步所有数据。同步这么大量的数据，是非常麻烦的。（这里，笔者其实自己有个疑问，如果每个节点都采用精简模式，之前的历史数据会不会都丢了？）\n\n### 网络性\n\n区块链项目的运行依赖于网咯，不管是人为还是非人为造成 **世界级网络的瘫痪**，例如战争、自然灾害，区块链项目将会如何运行？\n\n### 承载性\n\n区块链因为其独特去中心化的验证机制，才保证信息的安全性。不过，也正因为这样，每次交易，所消耗的时间成本也会比一般网络交易要高。仍旧用比特币做例子，以现在的算力和平均的网络传输速度，比特币 **一天** 最多只能支持 **65 万笔** 左右的交易。相比 2017 年支付宝双十一 **25.6 万笔/秒** 的速度，简直是天差地别。\n\n![支付宝2017年双十一支付数据](https://ws1.sinaimg.cn/large/006tKfTcly1fnd595pz5lj30nm0d7dlv.jpg)\n\n### 春哥性\n\n**信春哥，无 Bug**。但是谁能真的保证用区块链技术实现的产品里，没有 Bug。即使是比特币，也出过 Bug。在 2013 年，比特币客户端被升级到 v0.8 版本，允许单个区块能容纳更多的交易频次。不久以后，某个区块的交易次数过多，直接导致该区块一分为二。开发者社区只能对软件进行降级，同时撤销了数小时之内的交易（有些人的币回来了，钱却不退回去）。而且，中本聪在程序中是否留有后门，也是不可知的。\n\n### 小结\n\n区块链作为一个新兴技术，所存在的弊端还是很多的。但是，其中很多缺陷，可以通过技术升级的形式修复或者规避。最主要的，区块链技术不仅仅解决了当前遇到的问题，而且，它更多的初衷是 **面向自由、面向理想进行编程**，这也是区块链技术受大家追捧的原因之一。\n\n有弊端不怕，用技术的方式来解决。这是一个技术从业者应该做的，也愿意做的。\n\n## 总结\n\n任何一个区块链技术文章的作者，几乎都会被问一个问题：“你是否看好比特币？”。笔者的答案是“看戏”，原因是 **当前比特币的优点被放大了，缺点并不被大家所认知，有泡沫**；而同时 **几乎所有缺点都可以通过技术升级的方式修复，在缺点所带来的问题变大之前，通过技术手段修复，也是可以的**。\n\n这里会有人说：“ *世界知名传统银行都在区块链技术上大力布局，投入要超过绝大部分互联网公司，就连传统行业都认可数字货币，数字货币肯定会成为潮流* ”。其实看事情要辩证来看，笔者觉得传统银行更多是因为被互联网金融伤了，这次不想重蹈覆辙，抢先布局而已。而且，笔者想说的是，区块链技术不等于数字货币，更不等于比特币。而且基于信息产业的经济学，更多是一门社会科学，既然是社会科学，就不能排除人、团队、组织、政府的影响。传统银行重视区块链，不一定要做数字货币，很大可能用区块链技术去解决其他的金融问题。\n\n与对数字货币、比特币持保留态度相反，笔者对区块链技术是非常看好的，它不仅仅能解决金融问题，它更能在各个行业发挥作用，解决棘手问题。\n\n![](https://ws4.sinaimg.cn/large/006tKfTcly1fnd5cf8olrj30rs0gojvn.jpg)\n\n对于新技术，每个人都会有自己不同的理解和认知，如果有理解错误的地方，欢迎指正，非常感谢。\n\n在最后，发自肺腑说一句 —— **欢迎拥抱区块链技术！**\n","slug":"2018-01-11-the-use-of-block-chain-technology-in-tourism-industry","published":1,"updated":"2018-06-25T03:18:28.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc77000lhxp4ey5j0d9y","content":"<p>前几日，天使投资人徐小平的内部讲话 <strong>“鼓励创业者拥抱区块链革命”</strong> 刷爆了微博和朋友圈，而同时笔者刚好读完一本有关区块链技术的书 <strong>《人工智能时代，一本书读懂区块链金融》</strong> ，在读的同时也思考了下自己所处的行业，找到了一些相似的场景。因此，借此机会，与大家谈谈自己在学习区块链技术过程中的一些感受，并畅想一下在旅游行业区块链技术的应用。<a id=\"more\"></a></p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fnbyj1ruzhj30ku0beh1z.jpg\" alt=\"\"></p>\n<p>先说说这本书，在亚马逊 Kindle Unlimited 榜上排名挺高的，在“IT产业与文化”分类中是最畅销的。个人觉得写得还是很不错的，对区块链技术讲得比较深入，只不过中后部分的内容，大多是把前面所讲过的理论翻来覆去地阐述，感觉越读到后面，营养价值越低。它排名高，可能跟它的书名有关，又是“人工智能”，又是“金融”。总体来讲，值得一读，不过中后半部分不用太详细去读。</p>\n<h2 id=\"区块链技术是什么\"><a href=\"#区块链技术是什么\" class=\"headerlink\" title=\"区块链技术是什么\"></a>区块链技术是什么</h2><p>谈到区块链，就必须说数字货币、比特币。就像人工智能是机器学习、深度学习的表象一样，数字货币其实也是区块链技术的一种表象，一种技术的运用方式。极大可能是由于和“钱”有关，所以让大家的视线更多关注在数字货币或比特币上。这样也好，我们可以先谈谈数字货币中的王者—— <strong>比特币（BitCoin）</strong>。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnbztkt5crj30xc0irak7.jpg\" alt=\"\"></p>\n<p>任何事物，都要辩证地来看。一方面，比特币改变了金融的形态，让交易不通过银行等交易中心就能交易，更方便、更快捷；而另一方面，比特币绝大部分交易是用于洗钱、网络勒索、非法交易、逃避外汇管制等非法行为，很少真正用于我们大家的生活中。从上面这些内容，可以总结出，比特币最重要的几个特点： <strong>去中心化</strong> （不用通过银行）、<strong>安全</strong>（不可靠谁用？）、<strong>可信</strong> （不可信谁用？）、<strong>匿名</strong>（逃避监管）、<strong>交易记录不可修改</strong>（洗完钱，撤销了？）。</p>\n<p>而区块链正是用来实现这几种特征的技术：</p>\n<ul>\n<li>去中心化 —— <strong>分布式数据库</strong>，当然和平常接触的关系型、非关系型数据库不一样，它是 <strong>基于数据区块的数据库</strong>，而且每一个节点，都有查询所有数据的权限。</li>\n<li>安全 —— <strong>加密算法</strong>，将交易信息进行 <strong>RSA 非对称加密</strong> 后，再进行传输，所有第三方都能知道交易发生的时间和数量，但谁也不知道，交易双方是谁。</li>\n<li>可信 —— <strong>智能合约</strong>，一种共识机制，可以比喻成 <strong>用代码实现的合同</strong>，交易时会严格按照这套代码实现的逻辑来执行，<strong>理论上不会有任何违约行为</strong>。</li>\n<li>匿名 —— <strong>完全数字化</strong>，代表一个用户的只是一串秘钥，持有这串秘钥，就认为是这个用户。连转账双方，都不能准确知道对方具体是谁，只知道账户地址。</li>\n<li>记录不可修改 —— <strong>已有区块不可修改</strong>。理论上，所有基于区块链的应用都能做到这点，但是现在知名的项目中，好像只有比特币这样做了（这也是比特币价值高的原因之一）。当然，不可修改也不是100%绝对的，在后面讲弊端那一节里，会提到 <strong>51% 算力问题</strong>。</li>\n</ul>\n<p>总结来说，区块链就是 <strong>完全数字化的包含共识机制的加密且不可修改的分布式数据区块数据库技术</strong>。这是笔者凭借自己的理解，给出的定义。对于新技术，每个人会由于理解的不同，导致给出的定义也不尽相同，这其实是很正常的，大家都可以有自己心中的定义，各抒己见，多多交流。</p>\n<p>区块链技术是什么，大家了解了，那么，区块链技术到底能解决什么问题呢？绝不只是洗钱这么简单。</p>\n<h2 id=\"区块链技术能解决什么问题\"><a href=\"#区块链技术能解决什么问题\" class=\"headerlink\" title=\"区块链技术能解决什么问题\"></a>区块链技术能解决什么问题</h2><p>讨论技术解决的问题，肯定要看技术所具有的特征。区块链技术最重要的三个特征就是 <strong>去中心化</strong>、<strong>智能合约</strong>、<strong>安全</strong>（匿名和不可修改，都可以算作安全的一部分）。很多人看到这三个特点，就会直接想到“金融”。当然，也可能是因为当前区块链技术主要用于金融，所以总结出的特点肯定和金融相关。不过，这些确实是区别于其他技术的特征。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fncqxxz0hij30rs0fxq5b.jpg\" alt=\"\"></p>\n<h3 id=\"去中心化-——-信任问题\"><a href=\"#去中心化-——-信任问题\" class=\"headerlink\" title=\"去中心化 —— 信任问题\"></a>去中心化 —— 信任问题</h3><p>对于信任问题，基于金融场景讲，可能更容易被理解。虽然说，最近几年，互联网金融的崛起，让传统金融备受打击，但是，互联网金融并没有解决传统金融中的信任问题。传统金融是建立在客户对银行、基金公司等实体金融机构信任的基础上；而互联网金融则是建立在客户对支付宝、P2P 信贷公司等网络交易所（虚拟金融机构）信任的基础上。当然，信任来源于很多方面，例如人际关系、权威性、口碑等等，但这些信任都是针对金融产品发行方、运营方等中心的，而不是对金融产品本身。这就容易让客户产生 <strong>大的金融机构的金融产品一定比小的金融机构的要好、要靠谱</strong> 的主观想法，而不去真正关心金融产品本身的风险程度。</p>\n<p>区块链技术带来了去中心化的思路，让每个客户手里都有 <strong>一份完整的账本</strong>，让所有客户都可以随意查看金融产品所有的交易、运作信息，并且，<strong>这份账本的真实性不是由金融机构保障，而是通过区块链技术让所有客户一起保障</strong>。这样就让用户的信任从金融机构转向了金融产品本身。与此同时，金融机构也可以减少为了维护金融产品的正常运作所产生的审计、监管等诸多方面的人力、物力、资源成本。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcly1fncqwpsdk4j30p00dwgoc.jpg\" alt=\"\"></p>\n<p>那么，“让所有客户一起保障”的逻辑是如何实现的呢？通过区块链技术，在产品设计的时候，<strong>编写程序代码来制定这个产品的所有交易（数据交互）规则</strong>，然后任意节点（运营发行方和客户）进行交易（数据交互）时，会通过网络，将这个操作发送给其他节点，<strong>待其他节点确认这个操作符合规则</strong> 时，交易（数据交互）即完成，并将记录写入数据区块中，同步给所有节点（运营发行方和客户），让所有节点（运营发行方和客户）可随时查看。</p>\n<p>在整个过程中，<strong>规则制定</strong> 和 <strong>规则确认</strong> 是非常重要的两个关键点。其中 “规则确认”，是去中心化带来的机制，就是让所有节点（主要是客户）参与到规则的确认中（一般都是超过半数确认就认为是符合规则的），避免产品运营发行方进行违规操作。而 “规则制定” 就是下一节要讲的 <strong>智能合约</strong>。</p>\n<h3 id=\"智能合约-——-违约问题\"><a href=\"#智能合约-——-违约问题\" class=\"headerlink\" title=\"智能合约 —— 违约问题\"></a>智能合约 —— 违约问题</h3><p>在人类社会人与人的交互中，会出现各种 <strong>合约</strong>，有口头的，有书面的，有电子的，不过这些合约都有一个共同的特点 —— <strong>用文字描述</strong>。这样很容易出现下面几类问题：</p>\n<ul>\n<li>合约双方，对文字描述的理解不一致，造成违约。</li>\n<li>违约后，违约一方容易在文字上做文章，让监管、仲裁甚至法院都难以决断。</li>\n<li>签订合约时，在文字上做手脚，故意挖坑。</li>\n</ul>\n<p>而且，在合约的执行上，需要第三方进行监管，才能让合约双方完全按照合约执行，因此，会出现一些成本。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcly1fncrbed0gyj30p00dvn0f.jpg\" alt=\"\"></p>\n<p>但是 <strong>智能合约</strong> 不一样，它是 <strong>通过程序代码来描述规则</strong>，可以准确执行，避免造成不同的人有不同理解的问题，从而有效规避违约问题。同时，即使有人利用规则漏洞做出了违约的行为，它的行为也将会永久被记录下来，不可修改，这个记录会为违约处理提供准确依据。</p>\n<p>智能合约看上去，就是一段可执行代码，可以准确执行即可。但是为什么，传统技术就很难实现呢？为什么要基于区块链技术才行呢？</p>\n<ul>\n<li>去中心化，让智能合约不能轻易被一个节点或某几个节点修改。</li>\n<li>产生的数据无法删除、修改，只能新增数据，保证了历史的可追溯性。</li>\n<li>基于数据无法删除、修改，让违约成本变高，因为违约记录永远被记录，永远不会被删除。</li>\n</ul>\n<p>不论是去中心化，还是智能合约，都是通过技术的形式解决现实中的问题，但是不论方案怎么优秀，只要安全上有漏洞，被人攻破，造成信息的错误，那么这个方案就会立刻变得一分不值。所以，下一节我们要谈谈安全。</p>\n<h3 id=\"安全-——-隐私泄露问题\"><a href=\"#安全-——-隐私泄露问题\" class=\"headerlink\" title=\"安全 —— 隐私泄露问题\"></a>安全 —— 隐私泄露问题</h3><p>其实安全问题，一直是区块链技术面临的最大问题，这点会在区块链存在的弊端那一节中讲到。而在这一小节，笔者要讲的安全，是区块链技术对隐私方面做的保护。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fnctitnokrj30k00c0wmg.jpg\" alt=\"\"></p>\n<p>完全匿名化，是当前区块链技术的特征和核心优势，虽然匿名直接导致黑产的不断蔓延，但是它也同时有效保证了交易的私密性。拿比特币为例，第三方只能看到交易的时间、数量等一些信息，但是并不能看到交易的双方的信息，甚至同样交易方的两次交易，都很难被第三方归并为同样交易方的交易。因此，交易双方可以很放心地进行安全的交易，而不暴露自己的任何隐私信息。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>这里提到的三个特征其实是相辅相成的：没有智能合约，去中心化只能靠人为自觉执行，监管成本反而会增大；没有去中心化，智能合约由中心独占，随意修改，也就不能称作“合约”了；如果不安全，再去中心化，再智能合约化，一旦被黑客攻破，所有都会直接归零；而也正是因为去中心化加上智能合约，才让违反规则的成本大大升高，从而让产品变得更安全了。在这个技术高速发展的时代，很少有一项技术单独靠一项特性就可以“称霸潮流”的，区块链这种融合多种特性，从很多层面解决问题的技术方案，应该是以后技术的发展方向。</p>\n<p>这一节讲了很多区块链在实际中解决的问题，但大多数都是基于金融场景的。其实金融本质上更像一个信息行业，据统计 90% 金融利润的来源，来自于信息的收集、分析、处理的过程中，因此信息对金融的重要程度非同一般。而，区块链技术其实就是对信息的 <strong>创建</strong>、<strong>加密</strong>、<strong>验证</strong>、<strong>处理</strong>、<strong>存储</strong>、<strong>分发</strong> 等过程实现了一个 <strong>基于网络</strong>、<strong>安全可靠</strong>、<strong>可编程</strong> 的机制，从而解决了金融场景的问题。因此，也可以看出，任何对信息有高度要求的行业都是适用区块链技术的，例如 <strong>新零售行业</strong>、<strong>通信领域</strong>、<strong>审计行业</strong>、<strong>医疗产业</strong>、<strong>共享经济</strong> 等等。（下面是网络上的一张区块链应用的图）</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fncqyowxsvj30rs0jsmzw.jpg\" alt=\"\"></p>\n<p>当然，旅游行业也是一个基于信息的产业，因此区块链技术应该在旅游产业中也有用武之地。</p>\n<h2 id=\"区块链在旅游行业的应用\"><a href=\"#区块链在旅游行业的应用\" class=\"headerlink\" title=\"区块链在旅游行业的应用\"></a>区块链在旅游行业的应用</h2><p>虽然有很多旅游行业的公司，都声称要搞区块链，但是实际落地并有成效的并不多，更多属于实验阶段：</p>\n<ul>\n<li>Webjet 正在开发一种解决方案，利用以太坊的私有版本追踪世界各地酒店房间的库存情况。希望确保消费者和他们的酒店之间的所有中介都能获得报酬，以帮助预订。这与区块链技术最初的初衷完全相反，即移除中间的人。。。。。</li>\n<li>TUI Group 正考虑将所有数据转移到一个私有版本的以太坊上，以去除 Expedia 和预订等中间商。</li>\n<li>S7 公司已经与俄罗斯的 Alfa-Bank 合作，减少了航空公司和代理商之间的结算时间。解决方案建立在以太坊的私有版本上。</li>\n<li>Innfinity 软件系统将使用区块链技术，让他们的在线预订工具能够提供 NDC 的内容，并以“目前不可能通过其他标准实现的方式”组合内容和服务。他们的解决方案基于以太坊的一个私有项目来实现。</li>\n<li>国际贸易协会在2016年的世界金融研讨会上展示了一种基于区块链技术的数字货币—— IATA（国际航协）硬币的概念。虽然还没有给出具体的细节，但看看IATA通常是如何创新的，如果他们决定在公共关系链上推出这个项目，我将会大吃一惊。</li>\n<li>等等。。。。。。</li>\n</ul>\n<p>（<em>上面的示例从 36kr 上 <a href=\"https://36kr.com/p/5090300.html\" target=\"_blank\" rel=\"noopener\">《区块链技术能颠覆旅游行业吗？》</a> 文章中摘抄</em>）</p>\n<p>因此，笔者在学习区块链技术的时候，一直在考虑旅游行业的一些突出问题，是否能使用区块链技术去解决，应该用什么方式去解决。在调研了一些方案后，结合自己的想法，给大家介绍一些解决常见问题的例子。</p>\n<h3 id=\"机票超售问题\"><a href=\"#机票超售问题\" class=\"headerlink\" title=\"机票超售问题\"></a>机票超售问题</h3><p>去年，<strong>美联航机票超售</strong> 问题无数次出现在新闻中，让大家对航空公司的好感跌到低谷。造成机票超额预定的原因是航空公司不愿意虚耗座位，所以航空公司会在容易出现空置的座位上进行适当的超售，这是 <strong>航空界的通行做法</strong>。但是这种做法，从乘客的角度来说，肯定算是“<strong>霸王条款</strong>”。但是，在乘客登机出现问题之前，是无法确定是否超售的。只有航空公司销售部门的部分人知道，但他们肯定不会说；航空监管部门获取真实售票数据或许也比较困难。这类问题如何解决呢？</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcly1fnd2jc83ezj30rs0lbtcx.jpg\" alt=\"\"></p>\n<p>其实，这个问题和网络支付中的“双花”问题很类似，从理论上区块链技术可以消除航空业和其他交通运输业的双重预定问题。</p>\n<p>一旦航空售票记录被验证并加入到区块链中，就会永久的存储起来，除非同时控制超过半数的节点，否则售票记录无法篡改。同时，由于数据是高度透明的，所有乘客都可以看到销售记录，肯定不会发生超售现象。而且，由于区块链的特性，乘客也不会知道其他销售记录是卖给谁的。</p>\n<p>区块链技术采用了一种公开透明的去中心化的算法，使消费者对“航空公司”的信任，转变为对“智能合约”的信任，能够塑造更好的形象。当然，这些只是理想状况，除非超售由法律裁定是违法行为，否则很难实施。</p>\n<p>不过，区块链可以运用到航空业其他地方，例如机场和飞机的通信、乘客身份验证等。</p>\n<h3 id=\"网约车高额抽成问题\"><a href=\"#网约车高额抽成问题\" class=\"headerlink\" title=\"网约车高额抽成问题\"></a>网约车高额抽成问题</h3><p>网约车虽然不完全属于旅游行业，但是它是旅游行业里主要的一环。当网约车过了多家平台的竞争期之后，车费抽成越来越高，大概在 5%~25% 之间，有的甚至更高。排除运营商的盈利策略，本身维护庞大的运营平台就有很高的人力、物力成本。</p>\n<p>从理论上，区块链技术可以帮助平台解决这类问题，降低维护平台的成本。网约车业务，其实就是乘客与司机的 P2P 业务，很适用区块链技术，这样可以大幅度降低平台数据存储的成本。同时基于区块链技术，实现价格算法透明化，让所有司机、乘客都可以无障碍地看到每个行程的详情及具体收费情况。</p>\n<h3 id=\"酒店预定管理\"><a href=\"#酒店预定管理\" class=\"headerlink\" title=\"酒店预定管理\"></a>酒店预定管理</h3><p>当前酒店行业存在已久的问题之一就是其供应链各个环节间容易出现信息遗漏、丢失等情况，这不仅会影响酒店的工作效率，还有可能会造成巨大的经济损失。而与网约车相似，酒店预订也可以近似的看为酒店与房客的 P2P 业务，而现在为了保证信息的充分传播（让更多潜在房客知道酒店信息），会加入很多供应商、中间商，最终造成中间环节容易出问题而且由于佣金的存在房价不是很便宜。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnd5dfjg79j30p00dwtad.jpg\" alt=\"\"></p>\n<p>而使用区块链技术，将“链”升级，创建一个比当前所有参与者使用的 <strong>更高效</strong>、<strong>更安全</strong> 以及 <strong>更低成本</strong> 的供应链，让客户预定酒店 <strong>更准确</strong>（不会出错）、<strong>更实时</strong>（不用供应商二次确认）、<strong>更便宜</strong>（避免佣金），让客户从信任供应商、信任酒店，变为信任这个以技术搭建的平台。</p>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>其实，有一个概念在前文中被弱化了，那就是 <strong>“算力”</strong>。按照去中心化的智能合约，每个节点都有验证行为的能力，验证的速度就是算力。让用户提供算力，在现在来看是很困难的，让用户设备上天天跑个程序提供算力（在一部分数字货币中，被称作矿工），其实是不现实的。但是如果用户不提供算力，那么事实上，都是规则制定方自己提供算力，那么去中心化其实并没有实现，智能合约不如一张废纸。介于这种情况，其实可以将更多方放入链路中来。例如，如果要解决机票超售问题，可以以监管部门、航空公司、机票经销商为节点建立区块链，这样多方制约，来维持去中心化的智能合约。</p>\n<p>任何基于信息的，有交易过程的行业，都有金融业相似的问题，而区块链技术可能正是解决这些问题的良药。或许区块链技术的去中心化会触动很多人的利益，但是只有变革才能更好的发展，发展才会有更好的利益。</p>\n<h2 id=\"当前区块链技术存在的弊端\"><a href=\"#当前区块链技术存在的弊端\" class=\"headerlink\" title=\"当前区块链技术存在的弊端\"></a>当前区块链技术存在的弊端</h2><p>在这个区块链技术（主要是数字货币）百花齐放、大红大紫的时代，其实很多技术弊端都被光芒所掩盖，而一些技术弊端可能是致命的。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnd55zpp9bj30rs0gltbq.jpg\" alt=\"\"></p>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>首当其冲是安全性，因为安全性是一切应用的根本，尤其是现在信息时代，一点漏洞，都可能造成大麻烦。</p>\n<p>从算法来讲，目前区块链的算法 <strong>相对安全</strong>。为什么说相对？因为随着数学、密码学和计算科学的发展，它的安全性越来越弱。实现上，由于区块链大量应用了各种密码学技术，属于算法高度密集工程，在实现上比较容易出现问题。例如，它使用了 NSA 的 RSA 算法，RSA 算法如果有缺陷（历史上有先例），可被轻易破解，一旦爆发，结局将会是毁灭。再者，即使没被破解，纯暴力破解也是有可能的。据估计，以目前“天河二号”的算力来说，产生比特币 SHA256 哈希算法的一个哈希碰撞大约需要 248 年，而用正在研制中的“天河三号”的话，才需要 10 年。而且随着量子计算机的不断发展，算法层面面临的潜在安全威胁会越来越大。</p>\n<p>从协议来讲，基于 PoW 共识过程的区块链主要面临的是 <strong>51% 攻击问题</strong>，即节点通过 <strong>掌握全网超过 51% 的算力就有能力成功篡改和伪造区块链数据</strong>。简单来说，如果你掌握了 51% 的算力，你自己就把你的非法操作反过来确认为符合规则的。虽然，犯罪成本很高，但是不排除有人出于某种目的，进行这种攻击。</p>\n<p>从使用来讲，区块链技术一大特点就是不可逆、不可伪造，但 <strong>前提是私钥是安全的</strong>。私钥是用户身份的唯一证明，没有第三方可以知道你的私钥。一旦私钥被盗取，你无法证明，资产是自身的；一旦丢失，你的资产也会凭空消失，无法找回。</p>\n<p>从匿名来讲，规避了监管的同时，可能向节点中加入现实中不可信用户，跟这些用户进行交易后，对方直接“跑路”，是无法追踪到的。</p>\n<h3 id=\"监管性\"><a href=\"#监管性\" class=\"headerlink\" title=\"监管性\"></a>监管性</h3><p>区块链的初衷是没有监管，但是在设计区块链产品时，在制定智能合约时，难免有疏漏。这时，不法分子 <strong>利用漏洞</strong> ，不管使用正规手段还是非正规手段，都可以获利。这种情况下，如果没有监管的存在，是非常危险的，而且危险是不可控的。所以，区块链技术最新的发展趋势中，加入监管是一大话题。当然，这里的监管，不是人为的监管，而是用技术，用程序逻辑去监管。</p>\n<p>笔者认为，不论是什么技术，都会有其疏漏的地方。使用程序监管，只能尽量规避漏洞，提高犯罪成本。可成本多高，才能算安全呢？</p>\n<h3 id=\"易用性\"><a href=\"#易用性\" class=\"headerlink\" title=\"易用性\"></a>易用性</h3><p>对于一个技术人员，区块链产品，例如数字货币，使用起来还是没有什么障碍的，但是对于普通人来说还是有一定的学习成本的。例如，当决定加入一个基于区块链技术的金融产品时，你要知道合约到底是什么。这样，理论上你需要在通读并理解智能合约的代码后，才能完全清楚合约内容（听销售人员说，其实会出现信任问题）。不仅仅是读代码，怎么安全地保存自己的私钥，也是存在不小技术成本的地方。甚至，现在比特币所有区块的数据量 <strong>将近 150G</strong>，你如何存储？虽然提供精简模式，才 2~3 G，不过在精简模式下重新扫描、导入钱包、导入地址、导入私钥这些功能都不能用，而且一旦数据出错，必须同步所有数据。同步这么大量的数据，是非常麻烦的。（这里，笔者其实自己有个疑问，如果每个节点都采用精简模式，之前的历史数据会不会都丢了？）</p>\n<h3 id=\"网络性\"><a href=\"#网络性\" class=\"headerlink\" title=\"网络性\"></a>网络性</h3><p>区块链项目的运行依赖于网咯，不管是人为还是非人为造成 <strong>世界级网络的瘫痪</strong>，例如战争、自然灾害，区块链项目将会如何运行？</p>\n<h3 id=\"承载性\"><a href=\"#承载性\" class=\"headerlink\" title=\"承载性\"></a>承载性</h3><p>区块链因为其独特去中心化的验证机制，才保证信息的安全性。不过，也正因为这样，每次交易，所消耗的时间成本也会比一般网络交易要高。仍旧用比特币做例子，以现在的算力和平均的网络传输速度，比特币 <strong>一天</strong> 最多只能支持 <strong>65 万笔</strong> 左右的交易。相比 2017 年支付宝双十一 <strong>25.6 万笔/秒</strong> 的速度，简直是天差地别。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fnd595pz5lj30nm0d7dlv.jpg\" alt=\"支付宝2017年双十一支付数据\"></p>\n<h3 id=\"春哥性\"><a href=\"#春哥性\" class=\"headerlink\" title=\"春哥性\"></a>春哥性</h3><p><strong>信春哥，无 Bug</strong>。但是谁能真的保证用区块链技术实现的产品里，没有 Bug。即使是比特币，也出过 Bug。在 2013 年，比特币客户端被升级到 v0.8 版本，允许单个区块能容纳更多的交易频次。不久以后，某个区块的交易次数过多，直接导致该区块一分为二。开发者社区只能对软件进行降级，同时撤销了数小时之内的交易（有些人的币回来了，钱却不退回去）。而且，中本聪在程序中是否留有后门，也是不可知的。</p>\n<h3 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>区块链作为一个新兴技术，所存在的弊端还是很多的。但是，其中很多缺陷，可以通过技术升级的形式修复或者规避。最主要的，区块链技术不仅仅解决了当前遇到的问题，而且，它更多的初衷是 <strong>面向自由、面向理想进行编程</strong>，这也是区块链技术受大家追捧的原因之一。</p>\n<p>有弊端不怕，用技术的方式来解决。这是一个技术从业者应该做的，也愿意做的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>任何一个区块链技术文章的作者，几乎都会被问一个问题：“你是否看好比特币？”。笔者的答案是“看戏”，原因是 <strong>当前比特币的优点被放大了，缺点并不被大家所认知，有泡沫</strong>；而同时 <strong>几乎所有缺点都可以通过技术升级的方式修复，在缺点所带来的问题变大之前，通过技术手段修复，也是可以的</strong>。</p>\n<p>这里会有人说：“ <em>世界知名传统银行都在区块链技术上大力布局，投入要超过绝大部分互联网公司，就连传统行业都认可数字货币，数字货币肯定会成为潮流</em> ”。其实看事情要辩证来看，笔者觉得传统银行更多是因为被互联网金融伤了，这次不想重蹈覆辙，抢先布局而已。而且，笔者想说的是，区块链技术不等于数字货币，更不等于比特币。而且基于信息产业的经济学，更多是一门社会科学，既然是社会科学，就不能排除人、团队、组织、政府的影响。传统银行重视区块链，不一定要做数字货币，很大可能用区块链技术去解决其他的金融问题。</p>\n<p>与对数字货币、比特币持保留态度相反，笔者对区块链技术是非常看好的，它不仅仅能解决金融问题，它更能在各个行业发挥作用，解决棘手问题。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnd5cf8olrj30rs0gojvn.jpg\" alt=\"\"></p>\n<p>对于新技术，每个人都会有自己不同的理解和认知，如果有理解错误的地方，欢迎指正，非常感谢。</p>\n<p>在最后，发自肺腑说一句 —— <strong>欢迎拥抱区块链技术！</strong></p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws2.sinaimg.cn/large/006tKfTcly1frsd3cqxtcj315g0e6b29.jpg","excerpt":"<p>前几日，天使投资人徐小平的内部讲话 <strong>“鼓励创业者拥抱区块链革命”</strong> 刷爆了微博和朋友圈，而同时笔者刚好读完一本有关区块链技术的书 <strong>《人工智能时代，一本书读懂区块链金融》</strong> ，在读的同时也思考了下自己所处的行业，找到了一些相似的场景。因此，借此机会，与大家谈谈自己在学习区块链技术过程中的一些感受，并畅想一下在旅游行业区块链技术的应用。","more":"</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fnbyj1ruzhj30ku0beh1z.jpg\" alt=\"\"></p>\n<p>先说说这本书，在亚马逊 Kindle Unlimited 榜上排名挺高的，在“IT产业与文化”分类中是最畅销的。个人觉得写得还是很不错的，对区块链技术讲得比较深入，只不过中后部分的内容，大多是把前面所讲过的理论翻来覆去地阐述，感觉越读到后面，营养价值越低。它排名高，可能跟它的书名有关，又是“人工智能”，又是“金融”。总体来讲，值得一读，不过中后半部分不用太详细去读。</p>\n<h2 id=\"区块链技术是什么\"><a href=\"#区块链技术是什么\" class=\"headerlink\" title=\"区块链技术是什么\"></a>区块链技术是什么</h2><p>谈到区块链，就必须说数字货币、比特币。就像人工智能是机器学习、深度学习的表象一样，数字货币其实也是区块链技术的一种表象，一种技术的运用方式。极大可能是由于和“钱”有关，所以让大家的视线更多关注在数字货币或比特币上。这样也好，我们可以先谈谈数字货币中的王者—— <strong>比特币（BitCoin）</strong>。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnbztkt5crj30xc0irak7.jpg\" alt=\"\"></p>\n<p>任何事物，都要辩证地来看。一方面，比特币改变了金融的形态，让交易不通过银行等交易中心就能交易，更方便、更快捷；而另一方面，比特币绝大部分交易是用于洗钱、网络勒索、非法交易、逃避外汇管制等非法行为，很少真正用于我们大家的生活中。从上面这些内容，可以总结出，比特币最重要的几个特点： <strong>去中心化</strong> （不用通过银行）、<strong>安全</strong>（不可靠谁用？）、<strong>可信</strong> （不可信谁用？）、<strong>匿名</strong>（逃避监管）、<strong>交易记录不可修改</strong>（洗完钱，撤销了？）。</p>\n<p>而区块链正是用来实现这几种特征的技术：</p>\n<ul>\n<li>去中心化 —— <strong>分布式数据库</strong>，当然和平常接触的关系型、非关系型数据库不一样，它是 <strong>基于数据区块的数据库</strong>，而且每一个节点，都有查询所有数据的权限。</li>\n<li>安全 —— <strong>加密算法</strong>，将交易信息进行 <strong>RSA 非对称加密</strong> 后，再进行传输，所有第三方都能知道交易发生的时间和数量，但谁也不知道，交易双方是谁。</li>\n<li>可信 —— <strong>智能合约</strong>，一种共识机制，可以比喻成 <strong>用代码实现的合同</strong>，交易时会严格按照这套代码实现的逻辑来执行，<strong>理论上不会有任何违约行为</strong>。</li>\n<li>匿名 —— <strong>完全数字化</strong>，代表一个用户的只是一串秘钥，持有这串秘钥，就认为是这个用户。连转账双方，都不能准确知道对方具体是谁，只知道账户地址。</li>\n<li>记录不可修改 —— <strong>已有区块不可修改</strong>。理论上，所有基于区块链的应用都能做到这点，但是现在知名的项目中，好像只有比特币这样做了（这也是比特币价值高的原因之一）。当然，不可修改也不是100%绝对的，在后面讲弊端那一节里，会提到 <strong>51% 算力问题</strong>。</li>\n</ul>\n<p>总结来说，区块链就是 <strong>完全数字化的包含共识机制的加密且不可修改的分布式数据区块数据库技术</strong>。这是笔者凭借自己的理解，给出的定义。对于新技术，每个人会由于理解的不同，导致给出的定义也不尽相同，这其实是很正常的，大家都可以有自己心中的定义，各抒己见，多多交流。</p>\n<p>区块链技术是什么，大家了解了，那么，区块链技术到底能解决什么问题呢？绝不只是洗钱这么简单。</p>\n<h2 id=\"区块链技术能解决什么问题\"><a href=\"#区块链技术能解决什么问题\" class=\"headerlink\" title=\"区块链技术能解决什么问题\"></a>区块链技术能解决什么问题</h2><p>讨论技术解决的问题，肯定要看技术所具有的特征。区块链技术最重要的三个特征就是 <strong>去中心化</strong>、<strong>智能合约</strong>、<strong>安全</strong>（匿名和不可修改，都可以算作安全的一部分）。很多人看到这三个特点，就会直接想到“金融”。当然，也可能是因为当前区块链技术主要用于金融，所以总结出的特点肯定和金融相关。不过，这些确实是区别于其他技术的特征。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fncqxxz0hij30rs0fxq5b.jpg\" alt=\"\"></p>\n<h3 id=\"去中心化-——-信任问题\"><a href=\"#去中心化-——-信任问题\" class=\"headerlink\" title=\"去中心化 —— 信任问题\"></a>去中心化 —— 信任问题</h3><p>对于信任问题，基于金融场景讲，可能更容易被理解。虽然说，最近几年，互联网金融的崛起，让传统金融备受打击，但是，互联网金融并没有解决传统金融中的信任问题。传统金融是建立在客户对银行、基金公司等实体金融机构信任的基础上；而互联网金融则是建立在客户对支付宝、P2P 信贷公司等网络交易所（虚拟金融机构）信任的基础上。当然，信任来源于很多方面，例如人际关系、权威性、口碑等等，但这些信任都是针对金融产品发行方、运营方等中心的，而不是对金融产品本身。这就容易让客户产生 <strong>大的金融机构的金融产品一定比小的金融机构的要好、要靠谱</strong> 的主观想法，而不去真正关心金融产品本身的风险程度。</p>\n<p>区块链技术带来了去中心化的思路，让每个客户手里都有 <strong>一份完整的账本</strong>，让所有客户都可以随意查看金融产品所有的交易、运作信息，并且，<strong>这份账本的真实性不是由金融机构保障，而是通过区块链技术让所有客户一起保障</strong>。这样就让用户的信任从金融机构转向了金融产品本身。与此同时，金融机构也可以减少为了维护金融产品的正常运作所产生的审计、监管等诸多方面的人力、物力、资源成本。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcly1fncqwpsdk4j30p00dwgoc.jpg\" alt=\"\"></p>\n<p>那么，“让所有客户一起保障”的逻辑是如何实现的呢？通过区块链技术，在产品设计的时候，<strong>编写程序代码来制定这个产品的所有交易（数据交互）规则</strong>，然后任意节点（运营发行方和客户）进行交易（数据交互）时，会通过网络，将这个操作发送给其他节点，<strong>待其他节点确认这个操作符合规则</strong> 时，交易（数据交互）即完成，并将记录写入数据区块中，同步给所有节点（运营发行方和客户），让所有节点（运营发行方和客户）可随时查看。</p>\n<p>在整个过程中，<strong>规则制定</strong> 和 <strong>规则确认</strong> 是非常重要的两个关键点。其中 “规则确认”，是去中心化带来的机制，就是让所有节点（主要是客户）参与到规则的确认中（一般都是超过半数确认就认为是符合规则的），避免产品运营发行方进行违规操作。而 “规则制定” 就是下一节要讲的 <strong>智能合约</strong>。</p>\n<h3 id=\"智能合约-——-违约问题\"><a href=\"#智能合约-——-违约问题\" class=\"headerlink\" title=\"智能合约 —— 违约问题\"></a>智能合约 —— 违约问题</h3><p>在人类社会人与人的交互中，会出现各种 <strong>合约</strong>，有口头的，有书面的，有电子的，不过这些合约都有一个共同的特点 —— <strong>用文字描述</strong>。这样很容易出现下面几类问题：</p>\n<ul>\n<li>合约双方，对文字描述的理解不一致，造成违约。</li>\n<li>违约后，违约一方容易在文字上做文章，让监管、仲裁甚至法院都难以决断。</li>\n<li>签订合约时，在文字上做手脚，故意挖坑。</li>\n</ul>\n<p>而且，在合约的执行上，需要第三方进行监管，才能让合约双方完全按照合约执行，因此，会出现一些成本。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcly1fncrbed0gyj30p00dvn0f.jpg\" alt=\"\"></p>\n<p>但是 <strong>智能合约</strong> 不一样，它是 <strong>通过程序代码来描述规则</strong>，可以准确执行，避免造成不同的人有不同理解的问题，从而有效规避违约问题。同时，即使有人利用规则漏洞做出了违约的行为，它的行为也将会永久被记录下来，不可修改，这个记录会为违约处理提供准确依据。</p>\n<p>智能合约看上去，就是一段可执行代码，可以准确执行即可。但是为什么，传统技术就很难实现呢？为什么要基于区块链技术才行呢？</p>\n<ul>\n<li>去中心化，让智能合约不能轻易被一个节点或某几个节点修改。</li>\n<li>产生的数据无法删除、修改，只能新增数据，保证了历史的可追溯性。</li>\n<li>基于数据无法删除、修改，让违约成本变高，因为违约记录永远被记录，永远不会被删除。</li>\n</ul>\n<p>不论是去中心化，还是智能合约，都是通过技术的形式解决现实中的问题，但是不论方案怎么优秀，只要安全上有漏洞，被人攻破，造成信息的错误，那么这个方案就会立刻变得一分不值。所以，下一节我们要谈谈安全。</p>\n<h3 id=\"安全-——-隐私泄露问题\"><a href=\"#安全-——-隐私泄露问题\" class=\"headerlink\" title=\"安全 —— 隐私泄露问题\"></a>安全 —— 隐私泄露问题</h3><p>其实安全问题，一直是区块链技术面临的最大问题，这点会在区块链存在的弊端那一节中讲到。而在这一小节，笔者要讲的安全，是区块链技术对隐私方面做的保护。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fnctitnokrj30k00c0wmg.jpg\" alt=\"\"></p>\n<p>完全匿名化，是当前区块链技术的特征和核心优势，虽然匿名直接导致黑产的不断蔓延，但是它也同时有效保证了交易的私密性。拿比特币为例，第三方只能看到交易的时间、数量等一些信息，但是并不能看到交易的双方的信息，甚至同样交易方的两次交易，都很难被第三方归并为同样交易方的交易。因此，交易双方可以很放心地进行安全的交易，而不暴露自己的任何隐私信息。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>这里提到的三个特征其实是相辅相成的：没有智能合约，去中心化只能靠人为自觉执行，监管成本反而会增大；没有去中心化，智能合约由中心独占，随意修改，也就不能称作“合约”了；如果不安全，再去中心化，再智能合约化，一旦被黑客攻破，所有都会直接归零；而也正是因为去中心化加上智能合约，才让违反规则的成本大大升高，从而让产品变得更安全了。在这个技术高速发展的时代，很少有一项技术单独靠一项特性就可以“称霸潮流”的，区块链这种融合多种特性，从很多层面解决问题的技术方案，应该是以后技术的发展方向。</p>\n<p>这一节讲了很多区块链在实际中解决的问题，但大多数都是基于金融场景的。其实金融本质上更像一个信息行业，据统计 90% 金融利润的来源，来自于信息的收集、分析、处理的过程中，因此信息对金融的重要程度非同一般。而，区块链技术其实就是对信息的 <strong>创建</strong>、<strong>加密</strong>、<strong>验证</strong>、<strong>处理</strong>、<strong>存储</strong>、<strong>分发</strong> 等过程实现了一个 <strong>基于网络</strong>、<strong>安全可靠</strong>、<strong>可编程</strong> 的机制，从而解决了金融场景的问题。因此，也可以看出，任何对信息有高度要求的行业都是适用区块链技术的，例如 <strong>新零售行业</strong>、<strong>通信领域</strong>、<strong>审计行业</strong>、<strong>医疗产业</strong>、<strong>共享经济</strong> 等等。（下面是网络上的一张区块链应用的图）</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fncqyowxsvj30rs0jsmzw.jpg\" alt=\"\"></p>\n<p>当然，旅游行业也是一个基于信息的产业，因此区块链技术应该在旅游产业中也有用武之地。</p>\n<h2 id=\"区块链在旅游行业的应用\"><a href=\"#区块链在旅游行业的应用\" class=\"headerlink\" title=\"区块链在旅游行业的应用\"></a>区块链在旅游行业的应用</h2><p>虽然有很多旅游行业的公司，都声称要搞区块链，但是实际落地并有成效的并不多，更多属于实验阶段：</p>\n<ul>\n<li>Webjet 正在开发一种解决方案，利用以太坊的私有版本追踪世界各地酒店房间的库存情况。希望确保消费者和他们的酒店之间的所有中介都能获得报酬，以帮助预订。这与区块链技术最初的初衷完全相反，即移除中间的人。。。。。</li>\n<li>TUI Group 正考虑将所有数据转移到一个私有版本的以太坊上，以去除 Expedia 和预订等中间商。</li>\n<li>S7 公司已经与俄罗斯的 Alfa-Bank 合作，减少了航空公司和代理商之间的结算时间。解决方案建立在以太坊的私有版本上。</li>\n<li>Innfinity 软件系统将使用区块链技术，让他们的在线预订工具能够提供 NDC 的内容，并以“目前不可能通过其他标准实现的方式”组合内容和服务。他们的解决方案基于以太坊的一个私有项目来实现。</li>\n<li>国际贸易协会在2016年的世界金融研讨会上展示了一种基于区块链技术的数字货币—— IATA（国际航协）硬币的概念。虽然还没有给出具体的细节，但看看IATA通常是如何创新的，如果他们决定在公共关系链上推出这个项目，我将会大吃一惊。</li>\n<li>等等。。。。。。</li>\n</ul>\n<p>（<em>上面的示例从 36kr 上 <a href=\"https://36kr.com/p/5090300.html\" target=\"_blank\" rel=\"noopener\">《区块链技术能颠覆旅游行业吗？》</a> 文章中摘抄</em>）</p>\n<p>因此，笔者在学习区块链技术的时候，一直在考虑旅游行业的一些突出问题，是否能使用区块链技术去解决，应该用什么方式去解决。在调研了一些方案后，结合自己的想法，给大家介绍一些解决常见问题的例子。</p>\n<h3 id=\"机票超售问题\"><a href=\"#机票超售问题\" class=\"headerlink\" title=\"机票超售问题\"></a>机票超售问题</h3><p>去年，<strong>美联航机票超售</strong> 问题无数次出现在新闻中，让大家对航空公司的好感跌到低谷。造成机票超额预定的原因是航空公司不愿意虚耗座位，所以航空公司会在容易出现空置的座位上进行适当的超售，这是 <strong>航空界的通行做法</strong>。但是这种做法，从乘客的角度来说，肯定算是“<strong>霸王条款</strong>”。但是，在乘客登机出现问题之前，是无法确定是否超售的。只有航空公司销售部门的部分人知道，但他们肯定不会说；航空监管部门获取真实售票数据或许也比较困难。这类问题如何解决呢？</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tKfTcly1fnd2jc83ezj30rs0lbtcx.jpg\" alt=\"\"></p>\n<p>其实，这个问题和网络支付中的“双花”问题很类似，从理论上区块链技术可以消除航空业和其他交通运输业的双重预定问题。</p>\n<p>一旦航空售票记录被验证并加入到区块链中，就会永久的存储起来，除非同时控制超过半数的节点，否则售票记录无法篡改。同时，由于数据是高度透明的，所有乘客都可以看到销售记录，肯定不会发生超售现象。而且，由于区块链的特性，乘客也不会知道其他销售记录是卖给谁的。</p>\n<p>区块链技术采用了一种公开透明的去中心化的算法，使消费者对“航空公司”的信任，转变为对“智能合约”的信任，能够塑造更好的形象。当然，这些只是理想状况，除非超售由法律裁定是违法行为，否则很难实施。</p>\n<p>不过，区块链可以运用到航空业其他地方，例如机场和飞机的通信、乘客身份验证等。</p>\n<h3 id=\"网约车高额抽成问题\"><a href=\"#网约车高额抽成问题\" class=\"headerlink\" title=\"网约车高额抽成问题\"></a>网约车高额抽成问题</h3><p>网约车虽然不完全属于旅游行业，但是它是旅游行业里主要的一环。当网约车过了多家平台的竞争期之后，车费抽成越来越高，大概在 5%~25% 之间，有的甚至更高。排除运营商的盈利策略，本身维护庞大的运营平台就有很高的人力、物力成本。</p>\n<p>从理论上，区块链技术可以帮助平台解决这类问题，降低维护平台的成本。网约车业务，其实就是乘客与司机的 P2P 业务，很适用区块链技术，这样可以大幅度降低平台数据存储的成本。同时基于区块链技术，实现价格算法透明化，让所有司机、乘客都可以无障碍地看到每个行程的详情及具体收费情况。</p>\n<h3 id=\"酒店预定管理\"><a href=\"#酒店预定管理\" class=\"headerlink\" title=\"酒店预定管理\"></a>酒店预定管理</h3><p>当前酒店行业存在已久的问题之一就是其供应链各个环节间容易出现信息遗漏、丢失等情况，这不仅会影响酒店的工作效率，还有可能会造成巨大的经济损失。而与网约车相似，酒店预订也可以近似的看为酒店与房客的 P2P 业务，而现在为了保证信息的充分传播（让更多潜在房客知道酒店信息），会加入很多供应商、中间商，最终造成中间环节容易出问题而且由于佣金的存在房价不是很便宜。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnd5dfjg79j30p00dwtad.jpg\" alt=\"\"></p>\n<p>而使用区块链技术，将“链”升级，创建一个比当前所有参与者使用的 <strong>更高效</strong>、<strong>更安全</strong> 以及 <strong>更低成本</strong> 的供应链，让客户预定酒店 <strong>更准确</strong>（不会出错）、<strong>更实时</strong>（不用供应商二次确认）、<strong>更便宜</strong>（避免佣金），让客户从信任供应商、信任酒店，变为信任这个以技术搭建的平台。</p>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>其实，有一个概念在前文中被弱化了，那就是 <strong>“算力”</strong>。按照去中心化的智能合约，每个节点都有验证行为的能力，验证的速度就是算力。让用户提供算力，在现在来看是很困难的，让用户设备上天天跑个程序提供算力（在一部分数字货币中，被称作矿工），其实是不现实的。但是如果用户不提供算力，那么事实上，都是规则制定方自己提供算力，那么去中心化其实并没有实现，智能合约不如一张废纸。介于这种情况，其实可以将更多方放入链路中来。例如，如果要解决机票超售问题，可以以监管部门、航空公司、机票经销商为节点建立区块链，这样多方制约，来维持去中心化的智能合约。</p>\n<p>任何基于信息的，有交易过程的行业，都有金融业相似的问题，而区块链技术可能正是解决这些问题的良药。或许区块链技术的去中心化会触动很多人的利益，但是只有变革才能更好的发展，发展才会有更好的利益。</p>\n<h2 id=\"当前区块链技术存在的弊端\"><a href=\"#当前区块链技术存在的弊端\" class=\"headerlink\" title=\"当前区块链技术存在的弊端\"></a>当前区块链技术存在的弊端</h2><p>在这个区块链技术（主要是数字货币）百花齐放、大红大紫的时代，其实很多技术弊端都被光芒所掩盖，而一些技术弊端可能是致命的。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnd55zpp9bj30rs0gltbq.jpg\" alt=\"\"></p>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>首当其冲是安全性，因为安全性是一切应用的根本，尤其是现在信息时代，一点漏洞，都可能造成大麻烦。</p>\n<p>从算法来讲，目前区块链的算法 <strong>相对安全</strong>。为什么说相对？因为随着数学、密码学和计算科学的发展，它的安全性越来越弱。实现上，由于区块链大量应用了各种密码学技术，属于算法高度密集工程，在实现上比较容易出现问题。例如，它使用了 NSA 的 RSA 算法，RSA 算法如果有缺陷（历史上有先例），可被轻易破解，一旦爆发，结局将会是毁灭。再者，即使没被破解，纯暴力破解也是有可能的。据估计，以目前“天河二号”的算力来说，产生比特币 SHA256 哈希算法的一个哈希碰撞大约需要 248 年，而用正在研制中的“天河三号”的话，才需要 10 年。而且随着量子计算机的不断发展，算法层面面临的潜在安全威胁会越来越大。</p>\n<p>从协议来讲，基于 PoW 共识过程的区块链主要面临的是 <strong>51% 攻击问题</strong>，即节点通过 <strong>掌握全网超过 51% 的算力就有能力成功篡改和伪造区块链数据</strong>。简单来说，如果你掌握了 51% 的算力，你自己就把你的非法操作反过来确认为符合规则的。虽然，犯罪成本很高，但是不排除有人出于某种目的，进行这种攻击。</p>\n<p>从使用来讲，区块链技术一大特点就是不可逆、不可伪造，但 <strong>前提是私钥是安全的</strong>。私钥是用户身份的唯一证明，没有第三方可以知道你的私钥。一旦私钥被盗取，你无法证明，资产是自身的；一旦丢失，你的资产也会凭空消失，无法找回。</p>\n<p>从匿名来讲，规避了监管的同时，可能向节点中加入现实中不可信用户，跟这些用户进行交易后，对方直接“跑路”，是无法追踪到的。</p>\n<h3 id=\"监管性\"><a href=\"#监管性\" class=\"headerlink\" title=\"监管性\"></a>监管性</h3><p>区块链的初衷是没有监管，但是在设计区块链产品时，在制定智能合约时，难免有疏漏。这时，不法分子 <strong>利用漏洞</strong> ，不管使用正规手段还是非正规手段，都可以获利。这种情况下，如果没有监管的存在，是非常危险的，而且危险是不可控的。所以，区块链技术最新的发展趋势中，加入监管是一大话题。当然，这里的监管，不是人为的监管，而是用技术，用程序逻辑去监管。</p>\n<p>笔者认为，不论是什么技术，都会有其疏漏的地方。使用程序监管，只能尽量规避漏洞，提高犯罪成本。可成本多高，才能算安全呢？</p>\n<h3 id=\"易用性\"><a href=\"#易用性\" class=\"headerlink\" title=\"易用性\"></a>易用性</h3><p>对于一个技术人员，区块链产品，例如数字货币，使用起来还是没有什么障碍的，但是对于普通人来说还是有一定的学习成本的。例如，当决定加入一个基于区块链技术的金融产品时，你要知道合约到底是什么。这样，理论上你需要在通读并理解智能合约的代码后，才能完全清楚合约内容（听销售人员说，其实会出现信任问题）。不仅仅是读代码，怎么安全地保存自己的私钥，也是存在不小技术成本的地方。甚至，现在比特币所有区块的数据量 <strong>将近 150G</strong>，你如何存储？虽然提供精简模式，才 2~3 G，不过在精简模式下重新扫描、导入钱包、导入地址、导入私钥这些功能都不能用，而且一旦数据出错，必须同步所有数据。同步这么大量的数据，是非常麻烦的。（这里，笔者其实自己有个疑问，如果每个节点都采用精简模式，之前的历史数据会不会都丢了？）</p>\n<h3 id=\"网络性\"><a href=\"#网络性\" class=\"headerlink\" title=\"网络性\"></a>网络性</h3><p>区块链项目的运行依赖于网咯，不管是人为还是非人为造成 <strong>世界级网络的瘫痪</strong>，例如战争、自然灾害，区块链项目将会如何运行？</p>\n<h3 id=\"承载性\"><a href=\"#承载性\" class=\"headerlink\" title=\"承载性\"></a>承载性</h3><p>区块链因为其独特去中心化的验证机制，才保证信息的安全性。不过，也正因为这样，每次交易，所消耗的时间成本也会比一般网络交易要高。仍旧用比特币做例子，以现在的算力和平均的网络传输速度，比特币 <strong>一天</strong> 最多只能支持 <strong>65 万笔</strong> 左右的交易。相比 2017 年支付宝双十一 <strong>25.6 万笔/秒</strong> 的速度，简直是天差地别。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tKfTcly1fnd595pz5lj30nm0d7dlv.jpg\" alt=\"支付宝2017年双十一支付数据\"></p>\n<h3 id=\"春哥性\"><a href=\"#春哥性\" class=\"headerlink\" title=\"春哥性\"></a>春哥性</h3><p><strong>信春哥，无 Bug</strong>。但是谁能真的保证用区块链技术实现的产品里，没有 Bug。即使是比特币，也出过 Bug。在 2013 年，比特币客户端被升级到 v0.8 版本，允许单个区块能容纳更多的交易频次。不久以后，某个区块的交易次数过多，直接导致该区块一分为二。开发者社区只能对软件进行降级，同时撤销了数小时之内的交易（有些人的币回来了，钱却不退回去）。而且，中本聪在程序中是否留有后门，也是不可知的。</p>\n<h3 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>区块链作为一个新兴技术，所存在的弊端还是很多的。但是，其中很多缺陷，可以通过技术升级的形式修复或者规避。最主要的，区块链技术不仅仅解决了当前遇到的问题，而且，它更多的初衷是 <strong>面向自由、面向理想进行编程</strong>，这也是区块链技术受大家追捧的原因之一。</p>\n<p>有弊端不怕，用技术的方式来解决。这是一个技术从业者应该做的，也愿意做的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>任何一个区块链技术文章的作者，几乎都会被问一个问题：“你是否看好比特币？”。笔者的答案是“看戏”，原因是 <strong>当前比特币的优点被放大了，缺点并不被大家所认知，有泡沫</strong>；而同时 <strong>几乎所有缺点都可以通过技术升级的方式修复，在缺点所带来的问题变大之前，通过技术手段修复，也是可以的</strong>。</p>\n<p>这里会有人说：“ <em>世界知名传统银行都在区块链技术上大力布局，投入要超过绝大部分互联网公司，就连传统行业都认可数字货币，数字货币肯定会成为潮流</em> ”。其实看事情要辩证来看，笔者觉得传统银行更多是因为被互联网金融伤了，这次不想重蹈覆辙，抢先布局而已。而且，笔者想说的是，区块链技术不等于数字货币，更不等于比特币。而且基于信息产业的经济学，更多是一门社会科学，既然是社会科学，就不能排除人、团队、组织、政府的影响。传统银行重视区块链，不一定要做数字货币，很大可能用区块链技术去解决其他的金融问题。</p>\n<p>与对数字货币、比特币持保留态度相反，笔者对区块链技术是非常看好的，它不仅仅能解决金融问题，它更能在各个行业发挥作用，解决棘手问题。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tKfTcly1fnd5cf8olrj30rs0gojvn.jpg\" alt=\"\"></p>\n<p>对于新技术，每个人都会有自己不同的理解和认知，如果有理解错误的地方，欢迎指正，非常感谢。</p>\n<p>在最后，发自肺腑说一句 —— <strong>欢迎拥抱区块链技术！</strong></p>"},{"title":"写给前端应届生的职业规划建议","date":"2017-09-19T16:00:00.000Z","thumbnailImage":"https://ws2.sinaimg.cn/large/006tKfTcly1frsc0k8tt4j314w0cs7a1.jpg","_content":"\n**【前言】** 近一年多的时间，笔者在公司中担任过应届生导师、实习生导师、应届生项目导师等一系列导师角色。期间，笔者发现一些即将和准备成为前端攻城狮的同学其实并没有明确前端真正的核心和定位，也没有给自己制定一个学习和发展的方向。<!-- more -->当初选择前端这个职业，也仅仅只是为了找一份工作而已。笔者很想以自己的多年工作经验，为前端应届生们分享一下我心中适合前端工程师的职业规划，让大家对自己有一个比较清醒的认知，避免在以后的成长过程中产生迷茫情绪。当然，笔者其实也才工作五年，能达到现在的技术水平和职级，应该算是发展上升比较快的，一些经验具备一定的借鉴价值。\n\n\n\n![](https://wx2.sinaimg.cn/mw1024/71c50075gy1fjk4xumc50j20kk0bf3yh.jpg)\n\n## 前端的兴起\n\n前端真正兴起和开始频繁出现在大家的视线里，大概是在十年前。彼时的 Web 开发基本是由后端主导，前端能做的只是校验一下数据、操作一下 DOM。（其中数据检验是 JS 产生的根本原因：当时网络太慢，在服务端检验数据并反馈给用户，让用户知晓输入错误，这个流程太长、反应太慢，因此通过脚本在用户端完成第一步校验，既方便了用户，又减轻了带宽的压力。）即使 06 年 jQuery 发布并风靡全球，以及 XMLHttpRequest 被纳入 W3C 标准，也没有改变这种状况。制约它进度的原因很简单，因为很多事情前端 做不了 或者 做不好。随着时间的推移，近几年，Angular、Backbone、React、Vue 等框架陆续发布，让前端越来越正规化、体系化。此时虽然仍有很多事，前端 做不了 或者 做不好，但前端这个岗位却已变得热辣空前。那么，是什么推动着前端发展到如此大的规模和火热的程度？\n\n![](https://wx1.sinaimg.cn/mw1024/71c50075ly1fjp9sunt8qj20go08cgml.jpg)\n\n也许，你可以列举出很多各种各样的原因，但是综其一点，就是 **『用户体验』** ，是由于所有人对用户体验的重视，才让前端发展得这么迅猛，这么快地兴起。这里，可能要感谢 Apple，感谢 iPhone，感谢 Jobs，07 年第一代 iPhone 发布，正式引发了几乎所有人对用户体验的重视，从『只要能用就好』，变成『要好用我才买单』的心理。而，前端的先驱者们、浏览器的开发者们，也顺应了这个潮流，将一系列重要的能力加入了浏览器，加入了前端。\n\n其中最重要的一项是 XMLHttpRequest，也就是 Ajax，它是富 Web 应用的基础，它让前端可以脱离后端的掌控，不用通过跳转的方式就能实现数据交互。感谢微软，感谢 IE，虽然被 IE 6~8 虐了无数遍，但是是它引入了 XMLHttpRequest ，引入了 Ajax，开启了富 Web 应用的时代，让用户体验大幅提升。\n\n而近几年，随着移动互联网的发展，多端多平台的需求越来越多，产品形态和数据分离，是形势所趋。而与此同时，移动时代对产品形态跨端、跨平台、多元化的用户体验要求，让本身就有跨平台特性的前端技术着实又火了一把，它让开发者有更多的时间和精力关注用户体验，并很容易保持多平台用户体验的统一（不同平台用不同技术实现，虽然可以，但成本太高）；除去上面的原因之外，前端技术自带的热发布、热更新特性，能在及时更新业务需求的同时快速修复用户所遇到的问题，也是大家选择它的一种原因。虽然另外还有很多零零总总、各种各样的原因，再促使着前端成为当前最火爆的几个职位之一，但是最根本的原因仍旧是大家对用户体验的要求。\n\n从上面可以看出，前端的兴起源于所有人对 **用户体验** 的重视，而火爆更是由于所有人对 **多元化的用户体验** 的关注。当然，用户体验不只只是 UI 漂亮、好看，它是多方面的，例如视图的加载速度和流畅程度，这些取决于你选择技术的编码体积、运行效率等多种因素。说白了，前端的目的就是 **让用户用得爽**，那么 **用户体验** 必须是重中之重。\n\n![](https://ww4.sinaimg.cn/large/71c50075jw1fbb967wpzlj20gp0c0mzy.jpg)\n\n说了这么多，其实有一个很重要的点没有提到，那就是 CSS。注重用户体验，首先你要用界面要有 UI，HTML + CSS 作为最简单的 UI 构建方式，让前端的 UI 开发成本低到无与伦比，而开发成本低才会有更多的时间和精力去注重用户体验。同时，现在 CSS 也有相应的框架，像 PostCss、Sass 等，更进一步降低了开发成本，释放了开发者的时间和精力。\n\n前端兴起这十年，也是用户体验飞速增长的十年。不管是技术完善度还是从业人数，前端这个方向受到了足够多技术人员的关注，同时也受到了足够多企业的重视。经过前端人不断的努力，现在的情况又如何呢？\n\n## 前端的现状\n\n提到现状，必须先提到一个概念 **大前端**。由于近几年互联网的发展，尤其是移动互联网的发展，有的大前端概念将 Native 归入前端的范畴，有的大前端概念将 Node 甚至只渲染页面的 PHP 归入前端范畴，但不管怎么说，笔者认为 **大前端** 是未来的一个趋势，将最终目标（提升用户体验）一致的技术归类到一起，让开发者清楚自己的最终目标是什么，要怎么做。当然，也正因为这点，作为一个前端工程师，如果你想更好的发展，你应该有更广的知识面，包括移动端知识、服务端知识。这些知识结合你的前端技术，才能更好地实现优秀的用户体验。\n\n抛开大前端，单谈前端，从前端架构层面谈，最近比较流行的有四个：老牌劲旅 jQuery、最近火得不能再火的 React、Google 精品 Angular 以及 MVVM 框架 Vue。现在几乎所有的项目都会在这四种架构方案中选择其一作为基础，进行业务开发。四种框架，四种不同的思想，简单来说：jQuery Dom 驱动的思想深入人心；React 则推崇组件化，万物皆组件；Angular 则把 MVC 在前端领域发扬光大；而 Vue 则是以数据驱动为核心的 MVVM 架构。作为一个前端新人，不可能很快就理解所有知识和思想，只能一步一步来，先把你在工作中所使用的框架理解透彻，再去思考和学习别的。说实话，会用和理解的差距很大。\n\n在这里，可能会有个疑问，上述四个架构，都很火，但是哪里涉及到用户体验了？是的，这些架构都没有直接涉及到 UI。但是就像足球，没有勤奋的训练和优秀的战术，再好的11人也踢不出好的比赛一样，这些架构从开发成本和开发体验上，降低了开发者编码和维护的难度，让其在 UI 的用户体验上的付出，事半功倍。当然，框架在编码体积、运行效率等多个方面影响了最终的用户体验。\n\n![](https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqdd2torj20hs0afwer.jpg)\n\n上面所说的是，当前前端的一大现状 —— **框架横行**，现在很少有公司、有工程师用纯原始的方式撸代码了。而前端另一大现状就是 —— **移动为先**。原因很简单，随着移动互联网用户的暴涨，各个公司的产品都是移动为先，技术跟随着产品的步伐，也必须移动为先。这时，为了解决多平台的问题，Hybrid 方案脱颖而出，包括传统的基于 WebView 的 Hybrid 方案（例如 Cordova）和 React-Native 等一系列技术方案。在这里我就不多说了，关于移动前端的内容最近充斥着各种技术论坛、交流群、公共号，具体的，大家可以自己亲身去了解。\n\n最后，对于现状，我想大家可能最关心的其实是职业形势。由于前端的兴起，前端人才市场相当活跃，平均薪金水平也是名列前茅。与此同时，前端的技术入门比较容易，造成另一个极端情况：人员泛滥、人才稀缺。这种情况，一方面由于前端发展太快，很难短时间掌握全部知识；另一方面，高等院校并没有开设专门的前端专业，大家更多是自学，野路子很多。所谓乱世出英雄，这样的前端大环境或许对一个新入行的同学更有利。当然，在如此『乱世』中，一个好的职业规划，才能避免『误入歧途』，保证自身顺利地成长。\n\n## 如何做一个职业规划\n\n上面讲述了前端如何兴起和前端的现状，下面将基于上述两点，分几个方面为大家提供一些有关职业规划的观点，希望对大家有帮助。\n\n### 确定方向\n\n做职业规划的目的是避免迷茫，而避免迷茫最有效的方式就是确定明确的方向和目标。\n\n![](https://wx2.sinaimg.cn/mw1024/71c50075ly1fjpqg4xgwsj20sg0i2gmq.jpg)\n\n对于任何一个技术岗位，都有固定的两个方向：**技术专家**（架构师）和 **开发经理**。前者偏重技术，需要你在当前领域钻研得很深；后者偏向管理，需要你在对技术有很深掌握的同时，可以带领团队完成项目的开发。当然，两者并不是鱼与熊掌的关系，你可以同时成为技术专家和开发经理。\n\n对于技术专家和开发经理两个方向的选择，更多取决于你自身在工作中多巴胺的分泌情况。当你专研技术时，多巴胺分泌得更多，感到更兴奋，或许你会很容易成为技术专家；反之，当你跟团队一起做业务时，多巴胺分泌得更多，更有获得感，那么你可以尝试向开发经理方向发展。当然，你也可能做什么都没有分泌\u0001太多的多巴胺，那么，你可以在尝试一段时间后，转型其他职业，例如产品经理。前端作为核心是用户体验，与用户最近的工程师，转型产品经理，阻碍会小一些。况且，文艺型前端布道人豆瓣前端负责人张克军认为，**前端工程师正慢慢演变为产品工程师**，前端和产品离得确实很近。\n\n当你选择好一个方向后，你就要朝着这个方向一步一步进发。丹尼尔在《一万小时天才理论》提出一万小时定律，即要成为某个领域的专家，需要积累一万小时。当然这只是个概数，不过每天花更多的时间去学习和实践，肯定是最有效的。这里，成为技术专家和开发经理过程中，关注的点略有差别。成长为技术专家，要更多关注技术本身的实现，包括逻辑、架构、设计模式、方法论等；而成长为技术经理，则要更多关注技术开发的过程，考虑如何提高开发效率、降低开发成本、优化开发质量等等。不同的人，精力是有限的，选择性关注一些必要的方面，对自身快速的成长是很有必要的。\n\n### 做业务还是做架构\n\n做业务，时间要求比较紧，代码质量要求高，可参考的代码比较多，业务知识需要学习。做架构，时间稍微自由，对经验要求比较高，无可参考代码，专业基础知识需要深刻理解；最主要的，做架构的你既是开发，又是用户，还是 PM ，只有 80% - 90% 的明确目标，并在开发过程中不断微调最终的目标。\n\n对于一个新人，其实不用纠结，**做业务才是好的选择**，而且做 **技术含量高**、**使用流行技术** 的业务才是最好的。原因很简单，架构的最终的目的是解决业务当中的问题，你没做过业务，哪能知道业务的问题在哪，你都不知道要解决什么问题，如何做好架构。所以，从业务做起，是新人最好的选择，也是唯一可行的选择。而选择有技术含量、使用流行技术的业务的原因更多在于成长，这样你的成长可能会更快、成长道路可能会更直。当然，这只是『可能』，不同的人适合不同的业务，所以不要强求一定『技术含量高、使用流行技术』的业务，更多的而是改变自己，去 **适应团队**、**适应业务**，这样才能 **更快地成长**。\n\n事实上，很多时候，你会遇到很业务工作很繁重没有额外时间学习的情况。而如何在这样环境中更快地成长呢？说白了就是『抄』，不不，是 **参考**。将学习融入到工作中，是最好的方法。做新项目，参考老项目代码；做新需求，参考老需求的代码；没有同类型的代码，参考别的业务的代码。参考前人的经验，在巨人的肩膀上，成长才会变得更快。同时，你的导师和你的伙伴，也会在业务中给你指点，帮你快速解决成长路上的问题。\n\n![](https://wx1.sinaimg.cn/mw1024/71c50075ly1fjpqppgz3kj20ro0lc76e.jpg)\n\n在这里，总结一下，在繁重的业务环境下快速成长，你需要 **很优秀的学习能力**、**很持久的耐心** 以及 **很好的导师和伙伴**，这样才能在技术成长的路上事半功倍。\n\n### 技术的学习\n\n说了半天，到了最核心的问题了，对于一个新人如何学习技术？笔者给的建议是：千万不要囫囵吞枣，**先把当前使用的技术学透用熟，才是最重要的**；千万不要在还没把当前使用的技术吃透之前，去学新的东西，不管新的东西有多火。就像上文所说，不同的框架，有不同的核心，有不同的思想。两个框架代码相似之处的思想不一定相似，例如 Angular 和 Vue 都有双向绑定，虽然效果相似，但是实现思想和内部实现方式是截然不同的。还在入门阶段的你，会被各种思想充斥头脑，反而会更不清楚。\n\n一定的时间后，当你理解透一个架构体系后，你可以 **类比地去看** 更多的架构体系。这时候，你会发现不同\u0001架构很多东西都是殊途同归，理解得很快。\n\n![](https://wx1.sinaimg.cn/mw1024/71c50075ly1fjpqhikta8j207x07xq3b.jpg)\n\n当然，理解透一个架构体系，有人需要一年，有人需要三年，还有人可能需要更长时间。为什么有这么大的区别呢？因为有些人在开发中，并不认为完成就可以了，会在开发中，追求代码的优美，会不断优化自己的代码，让自己的代码性能更好、可读性更高，并通过长时间的积累，达到 **量变导致质变** 的程度。即使一个特别聪明的人，没有『量』也不可能『质变』的，只不过他的量可能比其他人少而已。\n\n要提醒的一点是，学技术，一定要结合你所在公司、团队的技术栈。例如，去哪儿前端应届生会在进入业务线前，进行3个月的脱产培训，2017年的前端培训课程内容中涉及的技术主要是 React 和 React Native，而去哪儿业务的技术栈也大多是 React，那么作为去哪儿的前端应届生，你优先学习 React 的技术体系是事半功倍的，既有前人可以问，又有项目可以实践。\n\n当然，在学习架构的同时，不要忽略两样最基本的东西，一个是 **技术基础**，一个是 **开发规范**。\n\n技术基础是一切开发、架构的前提，没有一个好的基础，是无法让你自身的技术水平达到足够高的维度。例如你对于继承理解的并不透彻，你很难理解清晰 React 的内部实现。\n\n对于开发规范，笔者在带应届生时特别注意让他们遵守。代码规范比比皆是，但是很少有人严格遵守。究其原因，多是在代码规范制定之前，已经有自己的一套代码习惯，很难短时间改变自己的习惯。而应届生，一般来说代码并不多，还没有形成自己的编码习惯。这时候，开始遵守一定的规范，会促使他们养成一个较好的编码习惯，为后续的成长打好基础。下面，列举一下开发规范的几点好处，让大家明白代码规范的重要性：\n\n* 规范的代码可以促进团队合作。\n* 规范的代码可以减少 Bug 处理。\n* 规范的代码可以降低维护成本。\n* 规范的代码有助于代码审查。\n* 养成代码规范的习惯，有助于程序员自身的成长。\n\n![](https://wx2.sinaimg.cn/mw1024/71c50075ly1fjpqisken8j20j007r0tg.jpg)\n\n这部分最后，推荐一些学习技术的好地方，例如情封大大三年不停更的《前端早读课》、阿里大漠（不是大漠穷秋）的 w3cplus.com、微信公众号《前端圈》、《前端之巅》、《Node 全栈》，当然还有公司内的 《Qunar 技术沙龙》微信公众号，笔者所在团队 YMFE 的博客 blog.ymfe.org 等，都是学习技术的好地方。\n\n### 主战场 —— 移动混合开发\n\n随着移动浪潮的兴起，业务在移动端App 的需求量迅速扩大，应用迭代更新的频率也随之极速攀升，但与此同时纯 Native 的开发和更新成本成为了业务增长难以逾越的瓶颈。因此，引入一种开发更高效、成本更低的解决方案势在必行。\n\n![](https://wx2.sinaimg.cn/mw690/71c50075ly1feyt6lzpb5j208c03mq4d.jpg)\n\n在当前的移动互联网环境下，iOS 和 Android 上的 App 已经成了每个互联网产品的标配。如果一个用户端产品并不提供相应 App 版本，几乎会直接定义成一个不完整的产品。而被互联网人尊为铁律的『唯快不破』—— 快速开发、高速迭代、低成本上线，同时也是移动时代每个开发团队所追求的目标。综合以上两点原因，『Native 搭台，Web 唱戏』的 Hybrid 开发模式，以『快』的特点赢得了大家的青睐，并纷纷投入大量开发力量，使这种开发模式迅速走红。当前最常见的技术架构方案有以下三种：\n\n* 基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案\n* 非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native\n* 基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离的解决方案：微信小程序\n\n对于一个前端，笔者感觉每个人必须了解这三种常见方案的实现方式和优缺点，这样才能在开发移动端业务的时候，更为清楚自己所要注意、所要学习的地方。当然，仅仅了解实现方式是不够的，你要有环境去实践你学习的东西。再拿去哪儿为例，去哪儿现在大多数业务都是移动端的，Hybrid 和 RN 方案都在被使用。所以，作为一个应届生，你很有可能去做一些 Hybrid 或者 RN 的项目。做 Hybrid 项目时，你更多要考虑的是『如何高效地操作 Dom』；反之，做 RN 项目，你更多要考虑的则是『如何减少和 Native 的通信』。这两点，最终都会反应在项目的用户体验上。\n\n### 前端中的『另类』—— Node\n\n对于 Node，作为一个前端，应该并不陌生。Node 最大的卖点在于完全异步的 I/O 模型，相比于阻塞 I/O ，异步 I/O 模型极大提高 Web 服务的并发性。因此，前端都可以自己开发服务端了？\n\n这样认为的同学，笔者只能说，你想多了。Node 是可以开发服务端，但是不代表所有前端都可以使用 Node 去开发一个庞大业务的服务端。你去知乎搜索使用 Node 开发服务端的相关问题，一部分人会说 Node 不能替代之前的服务端语言，另一部分人会说什么也阻挡不了 Node 在服务端的脚步；同时有很多诸如 Paypal、阿里这样大公司大规模使用 Node，也很多公司在落入 Node 深坑而不起。不论争论如何，笔者认为，Node 是否能写服务端，主要在于使用 Node 的人是否有服务端的思想。开发服务端和开发前端是完全不同的思想，服务端更注重效率、更注重稳定、更注重高并发情况下数据的处理，用前端的思想去开发服务端显然是不行的。当然，成功的案例中，Node 也更多运用在页面渲染这一层，配合前端更快的渲染页面，提高用户体验；而复杂的数据逻辑，还是用传统的服务端语言进行开发，毕竟技术成熟、运维成本低。\n\n![](https://wx4.sinaimg.cn/mw1024/71c50075gy1fjqcesr5j5j20et08c0sq.jpg)\n\n这里，会出现一个问题，我只是前端，需不需要去学习 Node？笔者的答案是 **需要**。前端兴起已经很多年，已经从游击队乱枪打鸟的阶段逐渐变为规模化、工程化的时代。在这个时代中，尤其是在工具和流程方面，Node 起到了很大的作用，扮演很重要的角色。诸如 Webpack、Gulp、NPM 这些工具，他们被运用在各个公司的各类前端项目中。学习 Node 其实就是去学习前端的工具，去学习前端的工程化。\n\n\u0001当然，如果你立志是全栈，或者想做服务端的一些工作，再或者想通过 Node 学习服务端的技术和原理，都可以去学习 Node。请相信笔者，你不会失望的。\n\n### 前端一直在『造轮子』中不断前进\n\n**造轮子** 的意义是重新实现已有的功能，以达到更好的效果。这个词语，常见于技术圈，尤其是前端圈，逐渐被人贬义地用来『嘲讽』一个重新实现已有功能的工具、框架以及方案。那么，造轮子究竟是怎样一种行为？\n\n首先，笔者并不排斥造轮子，至少有一位大神造轮子造得很成功，那就是 Linus Torvalds。Minix 不好用，就造了一个 Linux；Bitkeeper 停止授权，就造了一个 Git。并且两个新『轮子』已经成为世界上最好的轮子之二。这种创造性的造轮子，是令人赞赏的。\n\n其次，不同的技术体系，互相学习，参考对方的思想，造自己的轮子，也是一个非常好的想法。尤其是前端，它通过学习其他语言、体系的架构方案，丰富自身，短短几年就上升到很高的高度。可以举得列子很多：例如 Angular 的 MVC + DI + IoC 的模式，很多人会直接想到 Java 的 Spring，甚至 Angular 也包含 AOP 的编程思想；再例如 MVVM 双向数据流的模式，本身就是微软的 WPF 首先提出的。轮子可以造，对开发有意义即可。\n\n![](https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqbn6abaj20gm04r3yo.jpg)\n\n最后，大家 **反感造轮子**，其实更多在于反感造一个没有任何创新的轮子，还天天到处宣扬自己的产物。你可以自己造一个没有任何创新的轮子，用来学习造轮子的过程，同时这也是深入轮子最好的方式，没有之一。当你了解当前轮子的根本构造之后，你就能在这个基础上进行更多的创新。\n\n### 其他方面的学习\n\n作为一个前端，\u0001最该学习的两个方面是 **产品** 和 **设计** 。学习产品思维，会帮助你从用户的角度审查你开发的产品，找出用户体验不优、交互不好的地方；而学习设计，则帮助你分析不优的地方的原因，并找出解决方案。当然，每个人的精力有限，不可能把这两个方面学得特别深，但最好都要有接触，有一定深度的学习。\n\n![](https://wx3.sinaimg.cn/mw1024/71c50075ly1fjpqn9oytbj20rs0k9gnb.jpg)\n\n### 小总结\n\n前文并没有直接跟大家说明怎么做职业规划，而是从发展方向、技术学习、主要业务场景、NodeJS、造轮子问题等多个方面，来给大家分析：作为前端，哪些需要做、哪些不需要做、哪些必须做、哪些可以做。大家可以根据自己的兴趣、能力等特性，并且和自己在公司所做的项目结合，决定做哪些、不做哪些、强制自己做哪些、有空余时间做哪些等等类似的决定。这里可以举个例子，例如：我的目标是成为一个技术专家，因此，我要深植业务一到两年，严格控制自己的代码规范，深入了解 React 体系，在移动端主攻 React Native，而且有时间看 Node  及 Babel 相关工具，目标是彻底理解 React 的技术实现和 Web Component 的开发思想。当你有这样一个目标时，你可以清楚知道自己做事的目的，可以清晰看到自己的成长。\n\n要注意的是，如果你已经有工作的话，**你的职业规划绝对不能脱离你现在的工作**。实践出真知，工作带给你的实践环境，才是你成长的营养来源。\n\n## 前端的未来\n\n对于前端的未来，或者说是互联网技术的未来，我比较认同阮一峰老师的一个观点：将来程序员只分为两类，**端工程师** 和 **云工程师**。端工程师，直面用户，为了用户能更好使用产品而殚精竭虑，包括传统的前端、Native、AR/VR、TV 端开发等；而云工程师，直面数据，将冰冷冷的数据转化为与用户息息相关的产品，包括分布式、大数据、机器学习等等。\n\n![](https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqlocoeij20fp09wwf2.jpg)\n\n前端不管演变成什么，它所关注的永远是 **用户体验**，只不过端增加了，开发的方式也增多了而已。作为一个前端工程师，要时时关注业界动态，更多地学习新技术，提升自己的实力，来适应更大的挑战。\n\n## 写在最后\n\n作为一个初入前端圈的新人，你或许对上面描述的东西并不完全理解，这没有任何问题。做一个适合自己的职业规划，并不急于一时，其实最好是在工作一段时间后，和你的 leader 或者伙伴们一起对自己做一个评估，并根据前面所讲，给自己制定一个适合自身情况、符合自身兴趣的职业规划，并按照规划一步步不断提高自己，向前方的成功迈进。\n\n笔者真心希望这篇文章可以给正在迷茫的你些许帮助。年轻且精力旺盛的前端领域，还没有形成像后端那样多的实施标准和最佳实践，每个人都可能有不同的思维、不同的思路。本文仅是笔者个人观点和看法，有错误或者疏漏之处，敬请谅解。同时也欢迎私下和笔者进行更深层次的探讨。\n\n最后，送给大家 PHP核心开发者『鸟哥』惠新宸 在近日微博上更新的一句话：\n\n![](https://wx1.sinaimg.cn/mw1024/71c50075gy1fjvv777fw0j20wy07qwkm.jpg)\n","source":"_posts/2017-09-20-写给前端应届生的职业规划建议.md","raw":"title: 写给前端应届生的职业规划建议\ndate: 2017-09-20\ncategory: 随笔\ntags: [职业规划]\nthumbnailImage: https://ws2.sinaimg.cn/large/006tKfTcly1frsc0k8tt4j314w0cs7a1.jpg\n---\n\n**【前言】** 近一年多的时间，笔者在公司中担任过应届生导师、实习生导师、应届生项目导师等一系列导师角色。期间，笔者发现一些即将和准备成为前端攻城狮的同学其实并没有明确前端真正的核心和定位，也没有给自己制定一个学习和发展的方向。<!-- more -->当初选择前端这个职业，也仅仅只是为了找一份工作而已。笔者很想以自己的多年工作经验，为前端应届生们分享一下我心中适合前端工程师的职业规划，让大家对自己有一个比较清醒的认知，避免在以后的成长过程中产生迷茫情绪。当然，笔者其实也才工作五年，能达到现在的技术水平和职级，应该算是发展上升比较快的，一些经验具备一定的借鉴价值。\n\n\n\n![](https://wx2.sinaimg.cn/mw1024/71c50075gy1fjk4xumc50j20kk0bf3yh.jpg)\n\n## 前端的兴起\n\n前端真正兴起和开始频繁出现在大家的视线里，大概是在十年前。彼时的 Web 开发基本是由后端主导，前端能做的只是校验一下数据、操作一下 DOM。（其中数据检验是 JS 产生的根本原因：当时网络太慢，在服务端检验数据并反馈给用户，让用户知晓输入错误，这个流程太长、反应太慢，因此通过脚本在用户端完成第一步校验，既方便了用户，又减轻了带宽的压力。）即使 06 年 jQuery 发布并风靡全球，以及 XMLHttpRequest 被纳入 W3C 标准，也没有改变这种状况。制约它进度的原因很简单，因为很多事情前端 做不了 或者 做不好。随着时间的推移，近几年，Angular、Backbone、React、Vue 等框架陆续发布，让前端越来越正规化、体系化。此时虽然仍有很多事，前端 做不了 或者 做不好，但前端这个岗位却已变得热辣空前。那么，是什么推动着前端发展到如此大的规模和火热的程度？\n\n![](https://wx1.sinaimg.cn/mw1024/71c50075ly1fjp9sunt8qj20go08cgml.jpg)\n\n也许，你可以列举出很多各种各样的原因，但是综其一点，就是 **『用户体验』** ，是由于所有人对用户体验的重视，才让前端发展得这么迅猛，这么快地兴起。这里，可能要感谢 Apple，感谢 iPhone，感谢 Jobs，07 年第一代 iPhone 发布，正式引发了几乎所有人对用户体验的重视，从『只要能用就好』，变成『要好用我才买单』的心理。而，前端的先驱者们、浏览器的开发者们，也顺应了这个潮流，将一系列重要的能力加入了浏览器，加入了前端。\n\n其中最重要的一项是 XMLHttpRequest，也就是 Ajax，它是富 Web 应用的基础，它让前端可以脱离后端的掌控，不用通过跳转的方式就能实现数据交互。感谢微软，感谢 IE，虽然被 IE 6~8 虐了无数遍，但是是它引入了 XMLHttpRequest ，引入了 Ajax，开启了富 Web 应用的时代，让用户体验大幅提升。\n\n而近几年，随着移动互联网的发展，多端多平台的需求越来越多，产品形态和数据分离，是形势所趋。而与此同时，移动时代对产品形态跨端、跨平台、多元化的用户体验要求，让本身就有跨平台特性的前端技术着实又火了一把，它让开发者有更多的时间和精力关注用户体验，并很容易保持多平台用户体验的统一（不同平台用不同技术实现，虽然可以，但成本太高）；除去上面的原因之外，前端技术自带的热发布、热更新特性，能在及时更新业务需求的同时快速修复用户所遇到的问题，也是大家选择它的一种原因。虽然另外还有很多零零总总、各种各样的原因，再促使着前端成为当前最火爆的几个职位之一，但是最根本的原因仍旧是大家对用户体验的要求。\n\n从上面可以看出，前端的兴起源于所有人对 **用户体验** 的重视，而火爆更是由于所有人对 **多元化的用户体验** 的关注。当然，用户体验不只只是 UI 漂亮、好看，它是多方面的，例如视图的加载速度和流畅程度，这些取决于你选择技术的编码体积、运行效率等多种因素。说白了，前端的目的就是 **让用户用得爽**，那么 **用户体验** 必须是重中之重。\n\n![](https://ww4.sinaimg.cn/large/71c50075jw1fbb967wpzlj20gp0c0mzy.jpg)\n\n说了这么多，其实有一个很重要的点没有提到，那就是 CSS。注重用户体验，首先你要用界面要有 UI，HTML + CSS 作为最简单的 UI 构建方式，让前端的 UI 开发成本低到无与伦比，而开发成本低才会有更多的时间和精力去注重用户体验。同时，现在 CSS 也有相应的框架，像 PostCss、Sass 等，更进一步降低了开发成本，释放了开发者的时间和精力。\n\n前端兴起这十年，也是用户体验飞速增长的十年。不管是技术完善度还是从业人数，前端这个方向受到了足够多技术人员的关注，同时也受到了足够多企业的重视。经过前端人不断的努力，现在的情况又如何呢？\n\n## 前端的现状\n\n提到现状，必须先提到一个概念 **大前端**。由于近几年互联网的发展，尤其是移动互联网的发展，有的大前端概念将 Native 归入前端的范畴，有的大前端概念将 Node 甚至只渲染页面的 PHP 归入前端范畴，但不管怎么说，笔者认为 **大前端** 是未来的一个趋势，将最终目标（提升用户体验）一致的技术归类到一起，让开发者清楚自己的最终目标是什么，要怎么做。当然，也正因为这点，作为一个前端工程师，如果你想更好的发展，你应该有更广的知识面，包括移动端知识、服务端知识。这些知识结合你的前端技术，才能更好地实现优秀的用户体验。\n\n抛开大前端，单谈前端，从前端架构层面谈，最近比较流行的有四个：老牌劲旅 jQuery、最近火得不能再火的 React、Google 精品 Angular 以及 MVVM 框架 Vue。现在几乎所有的项目都会在这四种架构方案中选择其一作为基础，进行业务开发。四种框架，四种不同的思想，简单来说：jQuery Dom 驱动的思想深入人心；React 则推崇组件化，万物皆组件；Angular 则把 MVC 在前端领域发扬光大；而 Vue 则是以数据驱动为核心的 MVVM 架构。作为一个前端新人，不可能很快就理解所有知识和思想，只能一步一步来，先把你在工作中所使用的框架理解透彻，再去思考和学习别的。说实话，会用和理解的差距很大。\n\n在这里，可能会有个疑问，上述四个架构，都很火，但是哪里涉及到用户体验了？是的，这些架构都没有直接涉及到 UI。但是就像足球，没有勤奋的训练和优秀的战术，再好的11人也踢不出好的比赛一样，这些架构从开发成本和开发体验上，降低了开发者编码和维护的难度，让其在 UI 的用户体验上的付出，事半功倍。当然，框架在编码体积、运行效率等多个方面影响了最终的用户体验。\n\n![](https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqdd2torj20hs0afwer.jpg)\n\n上面所说的是，当前前端的一大现状 —— **框架横行**，现在很少有公司、有工程师用纯原始的方式撸代码了。而前端另一大现状就是 —— **移动为先**。原因很简单，随着移动互联网用户的暴涨，各个公司的产品都是移动为先，技术跟随着产品的步伐，也必须移动为先。这时，为了解决多平台的问题，Hybrid 方案脱颖而出，包括传统的基于 WebView 的 Hybrid 方案（例如 Cordova）和 React-Native 等一系列技术方案。在这里我就不多说了，关于移动前端的内容最近充斥着各种技术论坛、交流群、公共号，具体的，大家可以自己亲身去了解。\n\n最后，对于现状，我想大家可能最关心的其实是职业形势。由于前端的兴起，前端人才市场相当活跃，平均薪金水平也是名列前茅。与此同时，前端的技术入门比较容易，造成另一个极端情况：人员泛滥、人才稀缺。这种情况，一方面由于前端发展太快，很难短时间掌握全部知识；另一方面，高等院校并没有开设专门的前端专业，大家更多是自学，野路子很多。所谓乱世出英雄，这样的前端大环境或许对一个新入行的同学更有利。当然，在如此『乱世』中，一个好的职业规划，才能避免『误入歧途』，保证自身顺利地成长。\n\n## 如何做一个职业规划\n\n上面讲述了前端如何兴起和前端的现状，下面将基于上述两点，分几个方面为大家提供一些有关职业规划的观点，希望对大家有帮助。\n\n### 确定方向\n\n做职业规划的目的是避免迷茫，而避免迷茫最有效的方式就是确定明确的方向和目标。\n\n![](https://wx2.sinaimg.cn/mw1024/71c50075ly1fjpqg4xgwsj20sg0i2gmq.jpg)\n\n对于任何一个技术岗位，都有固定的两个方向：**技术专家**（架构师）和 **开发经理**。前者偏重技术，需要你在当前领域钻研得很深；后者偏向管理，需要你在对技术有很深掌握的同时，可以带领团队完成项目的开发。当然，两者并不是鱼与熊掌的关系，你可以同时成为技术专家和开发经理。\n\n对于技术专家和开发经理两个方向的选择，更多取决于你自身在工作中多巴胺的分泌情况。当你专研技术时，多巴胺分泌得更多，感到更兴奋，或许你会很容易成为技术专家；反之，当你跟团队一起做业务时，多巴胺分泌得更多，更有获得感，那么你可以尝试向开发经理方向发展。当然，你也可能做什么都没有分泌\u0001太多的多巴胺，那么，你可以在尝试一段时间后，转型其他职业，例如产品经理。前端作为核心是用户体验，与用户最近的工程师，转型产品经理，阻碍会小一些。况且，文艺型前端布道人豆瓣前端负责人张克军认为，**前端工程师正慢慢演变为产品工程师**，前端和产品离得确实很近。\n\n当你选择好一个方向后，你就要朝着这个方向一步一步进发。丹尼尔在《一万小时天才理论》提出一万小时定律，即要成为某个领域的专家，需要积累一万小时。当然这只是个概数，不过每天花更多的时间去学习和实践，肯定是最有效的。这里，成为技术专家和开发经理过程中，关注的点略有差别。成长为技术专家，要更多关注技术本身的实现，包括逻辑、架构、设计模式、方法论等；而成长为技术经理，则要更多关注技术开发的过程，考虑如何提高开发效率、降低开发成本、优化开发质量等等。不同的人，精力是有限的，选择性关注一些必要的方面，对自身快速的成长是很有必要的。\n\n### 做业务还是做架构\n\n做业务，时间要求比较紧，代码质量要求高，可参考的代码比较多，业务知识需要学习。做架构，时间稍微自由，对经验要求比较高，无可参考代码，专业基础知识需要深刻理解；最主要的，做架构的你既是开发，又是用户，还是 PM ，只有 80% - 90% 的明确目标，并在开发过程中不断微调最终的目标。\n\n对于一个新人，其实不用纠结，**做业务才是好的选择**，而且做 **技术含量高**、**使用流行技术** 的业务才是最好的。原因很简单，架构的最终的目的是解决业务当中的问题，你没做过业务，哪能知道业务的问题在哪，你都不知道要解决什么问题，如何做好架构。所以，从业务做起，是新人最好的选择，也是唯一可行的选择。而选择有技术含量、使用流行技术的业务的原因更多在于成长，这样你的成长可能会更快、成长道路可能会更直。当然，这只是『可能』，不同的人适合不同的业务，所以不要强求一定『技术含量高、使用流行技术』的业务，更多的而是改变自己，去 **适应团队**、**适应业务**，这样才能 **更快地成长**。\n\n事实上，很多时候，你会遇到很业务工作很繁重没有额外时间学习的情况。而如何在这样环境中更快地成长呢？说白了就是『抄』，不不，是 **参考**。将学习融入到工作中，是最好的方法。做新项目，参考老项目代码；做新需求，参考老需求的代码；没有同类型的代码，参考别的业务的代码。参考前人的经验，在巨人的肩膀上，成长才会变得更快。同时，你的导师和你的伙伴，也会在业务中给你指点，帮你快速解决成长路上的问题。\n\n![](https://wx1.sinaimg.cn/mw1024/71c50075ly1fjpqppgz3kj20ro0lc76e.jpg)\n\n在这里，总结一下，在繁重的业务环境下快速成长，你需要 **很优秀的学习能力**、**很持久的耐心** 以及 **很好的导师和伙伴**，这样才能在技术成长的路上事半功倍。\n\n### 技术的学习\n\n说了半天，到了最核心的问题了，对于一个新人如何学习技术？笔者给的建议是：千万不要囫囵吞枣，**先把当前使用的技术学透用熟，才是最重要的**；千万不要在还没把当前使用的技术吃透之前，去学新的东西，不管新的东西有多火。就像上文所说，不同的框架，有不同的核心，有不同的思想。两个框架代码相似之处的思想不一定相似，例如 Angular 和 Vue 都有双向绑定，虽然效果相似，但是实现思想和内部实现方式是截然不同的。还在入门阶段的你，会被各种思想充斥头脑，反而会更不清楚。\n\n一定的时间后，当你理解透一个架构体系后，你可以 **类比地去看** 更多的架构体系。这时候，你会发现不同\u0001架构很多东西都是殊途同归，理解得很快。\n\n![](https://wx1.sinaimg.cn/mw1024/71c50075ly1fjpqhikta8j207x07xq3b.jpg)\n\n当然，理解透一个架构体系，有人需要一年，有人需要三年，还有人可能需要更长时间。为什么有这么大的区别呢？因为有些人在开发中，并不认为完成就可以了，会在开发中，追求代码的优美，会不断优化自己的代码，让自己的代码性能更好、可读性更高，并通过长时间的积累，达到 **量变导致质变** 的程度。即使一个特别聪明的人，没有『量』也不可能『质变』的，只不过他的量可能比其他人少而已。\n\n要提醒的一点是，学技术，一定要结合你所在公司、团队的技术栈。例如，去哪儿前端应届生会在进入业务线前，进行3个月的脱产培训，2017年的前端培训课程内容中涉及的技术主要是 React 和 React Native，而去哪儿业务的技术栈也大多是 React，那么作为去哪儿的前端应届生，你优先学习 React 的技术体系是事半功倍的，既有前人可以问，又有项目可以实践。\n\n当然，在学习架构的同时，不要忽略两样最基本的东西，一个是 **技术基础**，一个是 **开发规范**。\n\n技术基础是一切开发、架构的前提，没有一个好的基础，是无法让你自身的技术水平达到足够高的维度。例如你对于继承理解的并不透彻，你很难理解清晰 React 的内部实现。\n\n对于开发规范，笔者在带应届生时特别注意让他们遵守。代码规范比比皆是，但是很少有人严格遵守。究其原因，多是在代码规范制定之前，已经有自己的一套代码习惯，很难短时间改变自己的习惯。而应届生，一般来说代码并不多，还没有形成自己的编码习惯。这时候，开始遵守一定的规范，会促使他们养成一个较好的编码习惯，为后续的成长打好基础。下面，列举一下开发规范的几点好处，让大家明白代码规范的重要性：\n\n* 规范的代码可以促进团队合作。\n* 规范的代码可以减少 Bug 处理。\n* 规范的代码可以降低维护成本。\n* 规范的代码有助于代码审查。\n* 养成代码规范的习惯，有助于程序员自身的成长。\n\n![](https://wx2.sinaimg.cn/mw1024/71c50075ly1fjpqisken8j20j007r0tg.jpg)\n\n这部分最后，推荐一些学习技术的好地方，例如情封大大三年不停更的《前端早读课》、阿里大漠（不是大漠穷秋）的 w3cplus.com、微信公众号《前端圈》、《前端之巅》、《Node 全栈》，当然还有公司内的 《Qunar 技术沙龙》微信公众号，笔者所在团队 YMFE 的博客 blog.ymfe.org 等，都是学习技术的好地方。\n\n### 主战场 —— 移动混合开发\n\n随着移动浪潮的兴起，业务在移动端App 的需求量迅速扩大，应用迭代更新的频率也随之极速攀升，但与此同时纯 Native 的开发和更新成本成为了业务增长难以逾越的瓶颈。因此，引入一种开发更高效、成本更低的解决方案势在必行。\n\n![](https://wx2.sinaimg.cn/mw690/71c50075ly1feyt6lzpb5j208c03mq4d.jpg)\n\n在当前的移动互联网环境下，iOS 和 Android 上的 App 已经成了每个互联网产品的标配。如果一个用户端产品并不提供相应 App 版本，几乎会直接定义成一个不完整的产品。而被互联网人尊为铁律的『唯快不破』—— 快速开发、高速迭代、低成本上线，同时也是移动时代每个开发团队所追求的目标。综合以上两点原因，『Native 搭台，Web 唱戏』的 Hybrid 开发模式，以『快』的特点赢得了大家的青睐，并纷纷投入大量开发力量，使这种开发模式迅速走红。当前最常见的技术架构方案有以下三种：\n\n* 基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案\n* 非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native\n* 基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离的解决方案：微信小程序\n\n对于一个前端，笔者感觉每个人必须了解这三种常见方案的实现方式和优缺点，这样才能在开发移动端业务的时候，更为清楚自己所要注意、所要学习的地方。当然，仅仅了解实现方式是不够的，你要有环境去实践你学习的东西。再拿去哪儿为例，去哪儿现在大多数业务都是移动端的，Hybrid 和 RN 方案都在被使用。所以，作为一个应届生，你很有可能去做一些 Hybrid 或者 RN 的项目。做 Hybrid 项目时，你更多要考虑的是『如何高效地操作 Dom』；反之，做 RN 项目，你更多要考虑的则是『如何减少和 Native 的通信』。这两点，最终都会反应在项目的用户体验上。\n\n### 前端中的『另类』—— Node\n\n对于 Node，作为一个前端，应该并不陌生。Node 最大的卖点在于完全异步的 I/O 模型，相比于阻塞 I/O ，异步 I/O 模型极大提高 Web 服务的并发性。因此，前端都可以自己开发服务端了？\n\n这样认为的同学，笔者只能说，你想多了。Node 是可以开发服务端，但是不代表所有前端都可以使用 Node 去开发一个庞大业务的服务端。你去知乎搜索使用 Node 开发服务端的相关问题，一部分人会说 Node 不能替代之前的服务端语言，另一部分人会说什么也阻挡不了 Node 在服务端的脚步；同时有很多诸如 Paypal、阿里这样大公司大规模使用 Node，也很多公司在落入 Node 深坑而不起。不论争论如何，笔者认为，Node 是否能写服务端，主要在于使用 Node 的人是否有服务端的思想。开发服务端和开发前端是完全不同的思想，服务端更注重效率、更注重稳定、更注重高并发情况下数据的处理，用前端的思想去开发服务端显然是不行的。当然，成功的案例中，Node 也更多运用在页面渲染这一层，配合前端更快的渲染页面，提高用户体验；而复杂的数据逻辑，还是用传统的服务端语言进行开发，毕竟技术成熟、运维成本低。\n\n![](https://wx4.sinaimg.cn/mw1024/71c50075gy1fjqcesr5j5j20et08c0sq.jpg)\n\n这里，会出现一个问题，我只是前端，需不需要去学习 Node？笔者的答案是 **需要**。前端兴起已经很多年，已经从游击队乱枪打鸟的阶段逐渐变为规模化、工程化的时代。在这个时代中，尤其是在工具和流程方面，Node 起到了很大的作用，扮演很重要的角色。诸如 Webpack、Gulp、NPM 这些工具，他们被运用在各个公司的各类前端项目中。学习 Node 其实就是去学习前端的工具，去学习前端的工程化。\n\n\u0001当然，如果你立志是全栈，或者想做服务端的一些工作，再或者想通过 Node 学习服务端的技术和原理，都可以去学习 Node。请相信笔者，你不会失望的。\n\n### 前端一直在『造轮子』中不断前进\n\n**造轮子** 的意义是重新实现已有的功能，以达到更好的效果。这个词语，常见于技术圈，尤其是前端圈，逐渐被人贬义地用来『嘲讽』一个重新实现已有功能的工具、框架以及方案。那么，造轮子究竟是怎样一种行为？\n\n首先，笔者并不排斥造轮子，至少有一位大神造轮子造得很成功，那就是 Linus Torvalds。Minix 不好用，就造了一个 Linux；Bitkeeper 停止授权，就造了一个 Git。并且两个新『轮子』已经成为世界上最好的轮子之二。这种创造性的造轮子，是令人赞赏的。\n\n其次，不同的技术体系，互相学习，参考对方的思想，造自己的轮子，也是一个非常好的想法。尤其是前端，它通过学习其他语言、体系的架构方案，丰富自身，短短几年就上升到很高的高度。可以举得列子很多：例如 Angular 的 MVC + DI + IoC 的模式，很多人会直接想到 Java 的 Spring，甚至 Angular 也包含 AOP 的编程思想；再例如 MVVM 双向数据流的模式，本身就是微软的 WPF 首先提出的。轮子可以造，对开发有意义即可。\n\n![](https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqbn6abaj20gm04r3yo.jpg)\n\n最后，大家 **反感造轮子**，其实更多在于反感造一个没有任何创新的轮子，还天天到处宣扬自己的产物。你可以自己造一个没有任何创新的轮子，用来学习造轮子的过程，同时这也是深入轮子最好的方式，没有之一。当你了解当前轮子的根本构造之后，你就能在这个基础上进行更多的创新。\n\n### 其他方面的学习\n\n作为一个前端，\u0001最该学习的两个方面是 **产品** 和 **设计** 。学习产品思维，会帮助你从用户的角度审查你开发的产品，找出用户体验不优、交互不好的地方；而学习设计，则帮助你分析不优的地方的原因，并找出解决方案。当然，每个人的精力有限，不可能把这两个方面学得特别深，但最好都要有接触，有一定深度的学习。\n\n![](https://wx3.sinaimg.cn/mw1024/71c50075ly1fjpqn9oytbj20rs0k9gnb.jpg)\n\n### 小总结\n\n前文并没有直接跟大家说明怎么做职业规划，而是从发展方向、技术学习、主要业务场景、NodeJS、造轮子问题等多个方面，来给大家分析：作为前端，哪些需要做、哪些不需要做、哪些必须做、哪些可以做。大家可以根据自己的兴趣、能力等特性，并且和自己在公司所做的项目结合，决定做哪些、不做哪些、强制自己做哪些、有空余时间做哪些等等类似的决定。这里可以举个例子，例如：我的目标是成为一个技术专家，因此，我要深植业务一到两年，严格控制自己的代码规范，深入了解 React 体系，在移动端主攻 React Native，而且有时间看 Node  及 Babel 相关工具，目标是彻底理解 React 的技术实现和 Web Component 的开发思想。当你有这样一个目标时，你可以清楚知道自己做事的目的，可以清晰看到自己的成长。\n\n要注意的是，如果你已经有工作的话，**你的职业规划绝对不能脱离你现在的工作**。实践出真知，工作带给你的实践环境，才是你成长的营养来源。\n\n## 前端的未来\n\n对于前端的未来，或者说是互联网技术的未来，我比较认同阮一峰老师的一个观点：将来程序员只分为两类，**端工程师** 和 **云工程师**。端工程师，直面用户，为了用户能更好使用产品而殚精竭虑，包括传统的前端、Native、AR/VR、TV 端开发等；而云工程师，直面数据，将冰冷冷的数据转化为与用户息息相关的产品，包括分布式、大数据、机器学习等等。\n\n![](https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqlocoeij20fp09wwf2.jpg)\n\n前端不管演变成什么，它所关注的永远是 **用户体验**，只不过端增加了，开发的方式也增多了而已。作为一个前端工程师，要时时关注业界动态，更多地学习新技术，提升自己的实力，来适应更大的挑战。\n\n## 写在最后\n\n作为一个初入前端圈的新人，你或许对上面描述的东西并不完全理解，这没有任何问题。做一个适合自己的职业规划，并不急于一时，其实最好是在工作一段时间后，和你的 leader 或者伙伴们一起对自己做一个评估，并根据前面所讲，给自己制定一个适合自身情况、符合自身兴趣的职业规划，并按照规划一步步不断提高自己，向前方的成功迈进。\n\n笔者真心希望这篇文章可以给正在迷茫的你些许帮助。年轻且精力旺盛的前端领域，还没有形成像后端那样多的实施标准和最佳实践，每个人都可能有不同的思维、不同的思路。本文仅是笔者个人观点和看法，有错误或者疏漏之处，敬请谅解。同时也欢迎私下和笔者进行更深层次的探讨。\n\n最后，送给大家 PHP核心开发者『鸟哥』惠新宸 在近日微博上更新的一句话：\n\n![](https://wx1.sinaimg.cn/mw1024/71c50075gy1fjvv777fw0j20wy07qwkm.jpg)\n","slug":"2017-09-20-写给前端应届生的职业规划建议","published":1,"updated":"2018-06-25T03:18:28.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc78000qhxp4hfczmlli","content":"<p><strong>【前言】</strong> 近一年多的时间，笔者在公司中担任过应届生导师、实习生导师、应届生项目导师等一系列导师角色。期间，笔者发现一些即将和准备成为前端攻城狮的同学其实并没有明确前端真正的核心和定位，也没有给自己制定一个学习和发展的方向。<a id=\"more\"></a>当初选择前端这个职业，也仅仅只是为了找一份工作而已。笔者很想以自己的多年工作经验，为前端应届生们分享一下我心中适合前端工程师的职业规划，让大家对自己有一个比较清醒的认知，避免在以后的成长过程中产生迷茫情绪。当然，笔者其实也才工作五年，能达到现在的技术水平和职级，应该算是发展上升比较快的，一些经验具备一定的借鉴价值。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw1024/71c50075gy1fjk4xumc50j20kk0bf3yh.jpg\" alt=\"\"></p>\n<h2 id=\"前端的兴起\"><a href=\"#前端的兴起\" class=\"headerlink\" title=\"前端的兴起\"></a>前端的兴起</h2><p>前端真正兴起和开始频繁出现在大家的视线里，大概是在十年前。彼时的 Web 开发基本是由后端主导，前端能做的只是校验一下数据、操作一下 DOM。（其中数据检验是 JS 产生的根本原因：当时网络太慢，在服务端检验数据并反馈给用户，让用户知晓输入错误，这个流程太长、反应太慢，因此通过脚本在用户端完成第一步校验，既方便了用户，又减轻了带宽的压力。）即使 06 年 jQuery 发布并风靡全球，以及 XMLHttpRequest 被纳入 W3C 标准，也没有改变这种状况。制约它进度的原因很简单，因为很多事情前端 做不了 或者 做不好。随着时间的推移，近几年，Angular、Backbone、React、Vue 等框架陆续发布，让前端越来越正规化、体系化。此时虽然仍有很多事，前端 做不了 或者 做不好，但前端这个岗位却已变得热辣空前。那么，是什么推动着前端发展到如此大的规模和火热的程度？</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw1024/71c50075ly1fjp9sunt8qj20go08cgml.jpg\" alt=\"\"></p>\n<p>也许，你可以列举出很多各种各样的原因，但是综其一点，就是 <strong>『用户体验』</strong> ，是由于所有人对用户体验的重视，才让前端发展得这么迅猛，这么快地兴起。这里，可能要感谢 Apple，感谢 iPhone，感谢 Jobs，07 年第一代 iPhone 发布，正式引发了几乎所有人对用户体验的重视，从『只要能用就好』，变成『要好用我才买单』的心理。而，前端的先驱者们、浏览器的开发者们，也顺应了这个潮流，将一系列重要的能力加入了浏览器，加入了前端。</p>\n<p>其中最重要的一项是 XMLHttpRequest，也就是 Ajax，它是富 Web 应用的基础，它让前端可以脱离后端的掌控，不用通过跳转的方式就能实现数据交互。感谢微软，感谢 IE，虽然被 IE 6~8 虐了无数遍，但是是它引入了 XMLHttpRequest ，引入了 Ajax，开启了富 Web 应用的时代，让用户体验大幅提升。</p>\n<p>而近几年，随着移动互联网的发展，多端多平台的需求越来越多，产品形态和数据分离，是形势所趋。而与此同时，移动时代对产品形态跨端、跨平台、多元化的用户体验要求，让本身就有跨平台特性的前端技术着实又火了一把，它让开发者有更多的时间和精力关注用户体验，并很容易保持多平台用户体验的统一（不同平台用不同技术实现，虽然可以，但成本太高）；除去上面的原因之外，前端技术自带的热发布、热更新特性，能在及时更新业务需求的同时快速修复用户所遇到的问题，也是大家选择它的一种原因。虽然另外还有很多零零总总、各种各样的原因，再促使着前端成为当前最火爆的几个职位之一，但是最根本的原因仍旧是大家对用户体验的要求。</p>\n<p>从上面可以看出，前端的兴起源于所有人对 <strong>用户体验</strong> 的重视，而火爆更是由于所有人对 <strong>多元化的用户体验</strong> 的关注。当然，用户体验不只只是 UI 漂亮、好看，它是多方面的，例如视图的加载速度和流畅程度，这些取决于你选择技术的编码体积、运行效率等多种因素。说白了，前端的目的就是 <strong>让用户用得爽</strong>，那么 <strong>用户体验</strong> 必须是重中之重。</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/71c50075jw1fbb967wpzlj20gp0c0mzy.jpg\" alt=\"\"></p>\n<p>说了这么多，其实有一个很重要的点没有提到，那就是 CSS。注重用户体验，首先你要用界面要有 UI，HTML + CSS 作为最简单的 UI 构建方式，让前端的 UI 开发成本低到无与伦比，而开发成本低才会有更多的时间和精力去注重用户体验。同时，现在 CSS 也有相应的框架，像 PostCss、Sass 等，更进一步降低了开发成本，释放了开发者的时间和精力。</p>\n<p>前端兴起这十年，也是用户体验飞速增长的十年。不管是技术完善度还是从业人数，前端这个方向受到了足够多技术人员的关注，同时也受到了足够多企业的重视。经过前端人不断的努力，现在的情况又如何呢？</p>\n<h2 id=\"前端的现状\"><a href=\"#前端的现状\" class=\"headerlink\" title=\"前端的现状\"></a>前端的现状</h2><p>提到现状，必须先提到一个概念 <strong>大前端</strong>。由于近几年互联网的发展，尤其是移动互联网的发展，有的大前端概念将 Native 归入前端的范畴，有的大前端概念将 Node 甚至只渲染页面的 PHP 归入前端范畴，但不管怎么说，笔者认为 <strong>大前端</strong> 是未来的一个趋势，将最终目标（提升用户体验）一致的技术归类到一起，让开发者清楚自己的最终目标是什么，要怎么做。当然，也正因为这点，作为一个前端工程师，如果你想更好的发展，你应该有更广的知识面，包括移动端知识、服务端知识。这些知识结合你的前端技术，才能更好地实现优秀的用户体验。</p>\n<p>抛开大前端，单谈前端，从前端架构层面谈，最近比较流行的有四个：老牌劲旅 jQuery、最近火得不能再火的 React、Google 精品 Angular 以及 MVVM 框架 Vue。现在几乎所有的项目都会在这四种架构方案中选择其一作为基础，进行业务开发。四种框架，四种不同的思想，简单来说：jQuery Dom 驱动的思想深入人心；React 则推崇组件化，万物皆组件；Angular 则把 MVC 在前端领域发扬光大；而 Vue 则是以数据驱动为核心的 MVVM 架构。作为一个前端新人，不可能很快就理解所有知识和思想，只能一步一步来，先把你在工作中所使用的框架理解透彻，再去思考和学习别的。说实话，会用和理解的差距很大。</p>\n<p>在这里，可能会有个疑问，上述四个架构，都很火，但是哪里涉及到用户体验了？是的，这些架构都没有直接涉及到 UI。但是就像足球，没有勤奋的训练和优秀的战术，再好的11人也踢不出好的比赛一样，这些架构从开发成本和开发体验上，降低了开发者编码和维护的难度，让其在 UI 的用户体验上的付出，事半功倍。当然，框架在编码体积、运行效率等多个方面影响了最终的用户体验。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqdd2torj20hs0afwer.jpg\" alt=\"\"></p>\n<p>上面所说的是，当前前端的一大现状 —— <strong>框架横行</strong>，现在很少有公司、有工程师用纯原始的方式撸代码了。而前端另一大现状就是 —— <strong>移动为先</strong>。原因很简单，随着移动互联网用户的暴涨，各个公司的产品都是移动为先，技术跟随着产品的步伐，也必须移动为先。这时，为了解决多平台的问题，Hybrid 方案脱颖而出，包括传统的基于 WebView 的 Hybrid 方案（例如 Cordova）和 React-Native 等一系列技术方案。在这里我就不多说了，关于移动前端的内容最近充斥着各种技术论坛、交流群、公共号，具体的，大家可以自己亲身去了解。</p>\n<p>最后，对于现状，我想大家可能最关心的其实是职业形势。由于前端的兴起，前端人才市场相当活跃，平均薪金水平也是名列前茅。与此同时，前端的技术入门比较容易，造成另一个极端情况：人员泛滥、人才稀缺。这种情况，一方面由于前端发展太快，很难短时间掌握全部知识；另一方面，高等院校并没有开设专门的前端专业，大家更多是自学，野路子很多。所谓乱世出英雄，这样的前端大环境或许对一个新入行的同学更有利。当然，在如此『乱世』中，一个好的职业规划，才能避免『误入歧途』，保证自身顺利地成长。</p>\n<h2 id=\"如何做一个职业规划\"><a href=\"#如何做一个职业规划\" class=\"headerlink\" title=\"如何做一个职业规划\"></a>如何做一个职业规划</h2><p>上面讲述了前端如何兴起和前端的现状，下面将基于上述两点，分几个方面为大家提供一些有关职业规划的观点，希望对大家有帮助。</p>\n<h3 id=\"确定方向\"><a href=\"#确定方向\" class=\"headerlink\" title=\"确定方向\"></a>确定方向</h3><p>做职业规划的目的是避免迷茫，而避免迷茫最有效的方式就是确定明确的方向和目标。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw1024/71c50075ly1fjpqg4xgwsj20sg0i2gmq.jpg\" alt=\"\"></p>\n<p>对于任何一个技术岗位，都有固定的两个方向：<strong>技术专家</strong>（架构师）和 <strong>开发经理</strong>。前者偏重技术，需要你在当前领域钻研得很深；后者偏向管理，需要你在对技术有很深掌握的同时，可以带领团队完成项目的开发。当然，两者并不是鱼与熊掌的关系，你可以同时成为技术专家和开发经理。</p>\n<p>对于技术专家和开发经理两个方向的选择，更多取决于你自身在工作中多巴胺的分泌情况。当你专研技术时，多巴胺分泌得更多，感到更兴奋，或许你会很容易成为技术专家；反之，当你跟团队一起做业务时，多巴胺分泌得更多，更有获得感，那么你可以尝试向开发经理方向发展。当然，你也可能做什么都没有分泌\u0001太多的多巴胺，那么，你可以在尝试一段时间后，转型其他职业，例如产品经理。前端作为核心是用户体验，与用户最近的工程师，转型产品经理，阻碍会小一些。况且，文艺型前端布道人豆瓣前端负责人张克军认为，<strong>前端工程师正慢慢演变为产品工程师</strong>，前端和产品离得确实很近。</p>\n<p>当你选择好一个方向后，你就要朝着这个方向一步一步进发。丹尼尔在《一万小时天才理论》提出一万小时定律，即要成为某个领域的专家，需要积累一万小时。当然这只是个概数，不过每天花更多的时间去学习和实践，肯定是最有效的。这里，成为技术专家和开发经理过程中，关注的点略有差别。成长为技术专家，要更多关注技术本身的实现，包括逻辑、架构、设计模式、方法论等；而成长为技术经理，则要更多关注技术开发的过程，考虑如何提高开发效率、降低开发成本、优化开发质量等等。不同的人，精力是有限的，选择性关注一些必要的方面，对自身快速的成长是很有必要的。</p>\n<h3 id=\"做业务还是做架构\"><a href=\"#做业务还是做架构\" class=\"headerlink\" title=\"做业务还是做架构\"></a>做业务还是做架构</h3><p>做业务，时间要求比较紧，代码质量要求高，可参考的代码比较多，业务知识需要学习。做架构，时间稍微自由，对经验要求比较高，无可参考代码，专业基础知识需要深刻理解；最主要的，做架构的你既是开发，又是用户，还是 PM ，只有 80% - 90% 的明确目标，并在开发过程中不断微调最终的目标。</p>\n<p>对于一个新人，其实不用纠结，<strong>做业务才是好的选择</strong>，而且做 <strong>技术含量高</strong>、<strong>使用流行技术</strong> 的业务才是最好的。原因很简单，架构的最终的目的是解决业务当中的问题，你没做过业务，哪能知道业务的问题在哪，你都不知道要解决什么问题，如何做好架构。所以，从业务做起，是新人最好的选择，也是唯一可行的选择。而选择有技术含量、使用流行技术的业务的原因更多在于成长，这样你的成长可能会更快、成长道路可能会更直。当然，这只是『可能』，不同的人适合不同的业务，所以不要强求一定『技术含量高、使用流行技术』的业务，更多的而是改变自己，去 <strong>适应团队</strong>、<strong>适应业务</strong>，这样才能 <strong>更快地成长</strong>。</p>\n<p>事实上，很多时候，你会遇到很业务工作很繁重没有额外时间学习的情况。而如何在这样环境中更快地成长呢？说白了就是『抄』，不不，是 <strong>参考</strong>。将学习融入到工作中，是最好的方法。做新项目，参考老项目代码；做新需求，参考老需求的代码；没有同类型的代码，参考别的业务的代码。参考前人的经验，在巨人的肩膀上，成长才会变得更快。同时，你的导师和你的伙伴，也会在业务中给你指点，帮你快速解决成长路上的问题。</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw1024/71c50075ly1fjpqppgz3kj20ro0lc76e.jpg\" alt=\"\"></p>\n<p>在这里，总结一下，在繁重的业务环境下快速成长，你需要 <strong>很优秀的学习能力</strong>、<strong>很持久的耐心</strong> 以及 <strong>很好的导师和伙伴</strong>，这样才能在技术成长的路上事半功倍。</p>\n<h3 id=\"技术的学习\"><a href=\"#技术的学习\" class=\"headerlink\" title=\"技术的学习\"></a>技术的学习</h3><p>说了半天，到了最核心的问题了，对于一个新人如何学习技术？笔者给的建议是：千万不要囫囵吞枣，<strong>先把当前使用的技术学透用熟，才是最重要的</strong>；千万不要在还没把当前使用的技术吃透之前，去学新的东西，不管新的东西有多火。就像上文所说，不同的框架，有不同的核心，有不同的思想。两个框架代码相似之处的思想不一定相似，例如 Angular 和 Vue 都有双向绑定，虽然效果相似，但是实现思想和内部实现方式是截然不同的。还在入门阶段的你，会被各种思想充斥头脑，反而会更不清楚。</p>\n<p>一定的时间后，当你理解透一个架构体系后，你可以 <strong>类比地去看</strong> 更多的架构体系。这时候，你会发现不同\u0001架构很多东西都是殊途同归，理解得很快。</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw1024/71c50075ly1fjpqhikta8j207x07xq3b.jpg\" alt=\"\"></p>\n<p>当然，理解透一个架构体系，有人需要一年，有人需要三年，还有人可能需要更长时间。为什么有这么大的区别呢？因为有些人在开发中，并不认为完成就可以了，会在开发中，追求代码的优美，会不断优化自己的代码，让自己的代码性能更好、可读性更高，并通过长时间的积累，达到 <strong>量变导致质变</strong> 的程度。即使一个特别聪明的人，没有『量』也不可能『质变』的，只不过他的量可能比其他人少而已。</p>\n<p>要提醒的一点是，学技术，一定要结合你所在公司、团队的技术栈。例如，去哪儿前端应届生会在进入业务线前，进行3个月的脱产培训，2017年的前端培训课程内容中涉及的技术主要是 React 和 React Native，而去哪儿业务的技术栈也大多是 React，那么作为去哪儿的前端应届生，你优先学习 React 的技术体系是事半功倍的，既有前人可以问，又有项目可以实践。</p>\n<p>当然，在学习架构的同时，不要忽略两样最基本的东西，一个是 <strong>技术基础</strong>，一个是 <strong>开发规范</strong>。</p>\n<p>技术基础是一切开发、架构的前提，没有一个好的基础，是无法让你自身的技术水平达到足够高的维度。例如你对于继承理解的并不透彻，你很难理解清晰 React 的内部实现。</p>\n<p>对于开发规范，笔者在带应届生时特别注意让他们遵守。代码规范比比皆是，但是很少有人严格遵守。究其原因，多是在代码规范制定之前，已经有自己的一套代码习惯，很难短时间改变自己的习惯。而应届生，一般来说代码并不多，还没有形成自己的编码习惯。这时候，开始遵守一定的规范，会促使他们养成一个较好的编码习惯，为后续的成长打好基础。下面，列举一下开发规范的几点好处，让大家明白代码规范的重要性：</p>\n<ul>\n<li>规范的代码可以促进团队合作。</li>\n<li>规范的代码可以减少 Bug 处理。</li>\n<li>规范的代码可以降低维护成本。</li>\n<li>规范的代码有助于代码审查。</li>\n<li>养成代码规范的习惯，有助于程序员自身的成长。</li>\n</ul>\n<p><img src=\"https://wx2.sinaimg.cn/mw1024/71c50075ly1fjpqisken8j20j007r0tg.jpg\" alt=\"\"></p>\n<p>这部分最后，推荐一些学习技术的好地方，例如情封大大三年不停更的《前端早读课》、阿里大漠（不是大漠穷秋）的 w3cplus.com、微信公众号《前端圈》、《前端之巅》、《Node 全栈》，当然还有公司内的 《Qunar 技术沙龙》微信公众号，笔者所在团队 YMFE 的博客 blog.ymfe.org 等，都是学习技术的好地方。</p>\n<h3 id=\"主战场-——-移动混合开发\"><a href=\"#主战场-——-移动混合开发\" class=\"headerlink\" title=\"主战场 —— 移动混合开发\"></a>主战场 —— 移动混合开发</h3><p>随着移动浪潮的兴起，业务在移动端App 的需求量迅速扩大，应用迭代更新的频率也随之极速攀升，但与此同时纯 Native 的开发和更新成本成为了业务增长难以逾越的瓶颈。因此，引入一种开发更高效、成本更低的解决方案势在必行。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw690/71c50075ly1feyt6lzpb5j208c03mq4d.jpg\" alt=\"\"></p>\n<p>在当前的移动互联网环境下，iOS 和 Android 上的 App 已经成了每个互联网产品的标配。如果一个用户端产品并不提供相应 App 版本，几乎会直接定义成一个不完整的产品。而被互联网人尊为铁律的『唯快不破』—— 快速开发、高速迭代、低成本上线，同时也是移动时代每个开发团队所追求的目标。综合以上两点原因，『Native 搭台，Web 唱戏』的 Hybrid 开发模式，以『快』的特点赢得了大家的青睐，并纷纷投入大量开发力量，使这种开发模式迅速走红。当前最常见的技术架构方案有以下三种：</p>\n<ul>\n<li>基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案</li>\n<li>非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native</li>\n<li>基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离的解决方案：微信小程序</li>\n</ul>\n<p>对于一个前端，笔者感觉每个人必须了解这三种常见方案的实现方式和优缺点，这样才能在开发移动端业务的时候，更为清楚自己所要注意、所要学习的地方。当然，仅仅了解实现方式是不够的，你要有环境去实践你学习的东西。再拿去哪儿为例，去哪儿现在大多数业务都是移动端的，Hybrid 和 RN 方案都在被使用。所以，作为一个应届生，你很有可能去做一些 Hybrid 或者 RN 的项目。做 Hybrid 项目时，你更多要考虑的是『如何高效地操作 Dom』；反之，做 RN 项目，你更多要考虑的则是『如何减少和 Native 的通信』。这两点，最终都会反应在项目的用户体验上。</p>\n<h3 id=\"前端中的『另类』——-Node\"><a href=\"#前端中的『另类』——-Node\" class=\"headerlink\" title=\"前端中的『另类』—— Node\"></a>前端中的『另类』—— Node</h3><p>对于 Node，作为一个前端，应该并不陌生。Node 最大的卖点在于完全异步的 I/O 模型，相比于阻塞 I/O ，异步 I/O 模型极大提高 Web 服务的并发性。因此，前端都可以自己开发服务端了？</p>\n<p>这样认为的同学，笔者只能说，你想多了。Node 是可以开发服务端，但是不代表所有前端都可以使用 Node 去开发一个庞大业务的服务端。你去知乎搜索使用 Node 开发服务端的相关问题，一部分人会说 Node 不能替代之前的服务端语言，另一部分人会说什么也阻挡不了 Node 在服务端的脚步；同时有很多诸如 Paypal、阿里这样大公司大规模使用 Node，也很多公司在落入 Node 深坑而不起。不论争论如何，笔者认为，Node 是否能写服务端，主要在于使用 Node 的人是否有服务端的思想。开发服务端和开发前端是完全不同的思想，服务端更注重效率、更注重稳定、更注重高并发情况下数据的处理，用前端的思想去开发服务端显然是不行的。当然，成功的案例中，Node 也更多运用在页面渲染这一层，配合前端更快的渲染页面，提高用户体验；而复杂的数据逻辑，还是用传统的服务端语言进行开发，毕竟技术成熟、运维成本低。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw1024/71c50075gy1fjqcesr5j5j20et08c0sq.jpg\" alt=\"\"></p>\n<p>这里，会出现一个问题，我只是前端，需不需要去学习 Node？笔者的答案是 <strong>需要</strong>。前端兴起已经很多年，已经从游击队乱枪打鸟的阶段逐渐变为规模化、工程化的时代。在这个时代中，尤其是在工具和流程方面，Node 起到了很大的作用，扮演很重要的角色。诸如 Webpack、Gulp、NPM 这些工具，他们被运用在各个公司的各类前端项目中。学习 Node 其实就是去学习前端的工具，去学习前端的工程化。</p>\n<p>\u0001当然，如果你立志是全栈，或者想做服务端的一些工作，再或者想通过 Node 学习服务端的技术和原理，都可以去学习 Node。请相信笔者，你不会失望的。</p>\n<h3 id=\"前端一直在『造轮子』中不断前进\"><a href=\"#前端一直在『造轮子』中不断前进\" class=\"headerlink\" title=\"前端一直在『造轮子』中不断前进\"></a>前端一直在『造轮子』中不断前进</h3><p><strong>造轮子</strong> 的意义是重新实现已有的功能，以达到更好的效果。这个词语，常见于技术圈，尤其是前端圈，逐渐被人贬义地用来『嘲讽』一个重新实现已有功能的工具、框架以及方案。那么，造轮子究竟是怎样一种行为？</p>\n<p>首先，笔者并不排斥造轮子，至少有一位大神造轮子造得很成功，那就是 Linus Torvalds。Minix 不好用，就造了一个 Linux；Bitkeeper 停止授权，就造了一个 Git。并且两个新『轮子』已经成为世界上最好的轮子之二。这种创造性的造轮子，是令人赞赏的。</p>\n<p>其次，不同的技术体系，互相学习，参考对方的思想，造自己的轮子，也是一个非常好的想法。尤其是前端，它通过学习其他语言、体系的架构方案，丰富自身，短短几年就上升到很高的高度。可以举得列子很多：例如 Angular 的 MVC + DI + IoC 的模式，很多人会直接想到 Java 的 Spring，甚至 Angular 也包含 AOP 的编程思想；再例如 MVVM 双向数据流的模式，本身就是微软的 WPF 首先提出的。轮子可以造，对开发有意义即可。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqbn6abaj20gm04r3yo.jpg\" alt=\"\"></p>\n<p>最后，大家 <strong>反感造轮子</strong>，其实更多在于反感造一个没有任何创新的轮子，还天天到处宣扬自己的产物。你可以自己造一个没有任何创新的轮子，用来学习造轮子的过程，同时这也是深入轮子最好的方式，没有之一。当你了解当前轮子的根本构造之后，你就能在这个基础上进行更多的创新。</p>\n<h3 id=\"其他方面的学习\"><a href=\"#其他方面的学习\" class=\"headerlink\" title=\"其他方面的学习\"></a>其他方面的学习</h3><p>作为一个前端，\u0001最该学习的两个方面是 <strong>产品</strong> 和 <strong>设计</strong> 。学习产品思维，会帮助你从用户的角度审查你开发的产品，找出用户体验不优、交互不好的地方；而学习设计，则帮助你分析不优的地方的原因，并找出解决方案。当然，每个人的精力有限，不可能把这两个方面学得特别深，但最好都要有接触，有一定深度的学习。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw1024/71c50075ly1fjpqn9oytbj20rs0k9gnb.jpg\" alt=\"\"></p>\n<h3 id=\"小总结\"><a href=\"#小总结\" class=\"headerlink\" title=\"小总结\"></a>小总结</h3><p>前文并没有直接跟大家说明怎么做职业规划，而是从发展方向、技术学习、主要业务场景、NodeJS、造轮子问题等多个方面，来给大家分析：作为前端，哪些需要做、哪些不需要做、哪些必须做、哪些可以做。大家可以根据自己的兴趣、能力等特性，并且和自己在公司所做的项目结合，决定做哪些、不做哪些、强制自己做哪些、有空余时间做哪些等等类似的决定。这里可以举个例子，例如：我的目标是成为一个技术专家，因此，我要深植业务一到两年，严格控制自己的代码规范，深入了解 React 体系，在移动端主攻 React Native，而且有时间看 Node  及 Babel 相关工具，目标是彻底理解 React 的技术实现和 Web Component 的开发思想。当你有这样一个目标时，你可以清楚知道自己做事的目的，可以清晰看到自己的成长。</p>\n<p>要注意的是，如果你已经有工作的话，<strong>你的职业规划绝对不能脱离你现在的工作</strong>。实践出真知，工作带给你的实践环境，才是你成长的营养来源。</p>\n<h2 id=\"前端的未来\"><a href=\"#前端的未来\" class=\"headerlink\" title=\"前端的未来\"></a>前端的未来</h2><p>对于前端的未来，或者说是互联网技术的未来，我比较认同阮一峰老师的一个观点：将来程序员只分为两类，<strong>端工程师</strong> 和 <strong>云工程师</strong>。端工程师，直面用户，为了用户能更好使用产品而殚精竭虑，包括传统的前端、Native、AR/VR、TV 端开发等；而云工程师，直面数据，将冰冷冷的数据转化为与用户息息相关的产品，包括分布式、大数据、机器学习等等。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqlocoeij20fp09wwf2.jpg\" alt=\"\"></p>\n<p>前端不管演变成什么，它所关注的永远是 <strong>用户体验</strong>，只不过端增加了，开发的方式也增多了而已。作为一个前端工程师，要时时关注业界动态，更多地学习新技术，提升自己的实力，来适应更大的挑战。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>作为一个初入前端圈的新人，你或许对上面描述的东西并不完全理解，这没有任何问题。做一个适合自己的职业规划，并不急于一时，其实最好是在工作一段时间后，和你的 leader 或者伙伴们一起对自己做一个评估，并根据前面所讲，给自己制定一个适合自身情况、符合自身兴趣的职业规划，并按照规划一步步不断提高自己，向前方的成功迈进。</p>\n<p>笔者真心希望这篇文章可以给正在迷茫的你些许帮助。年轻且精力旺盛的前端领域，还没有形成像后端那样多的实施标准和最佳实践，每个人都可能有不同的思维、不同的思路。本文仅是笔者个人观点和看法，有错误或者疏漏之处，敬请谅解。同时也欢迎私下和笔者进行更深层次的探讨。</p>\n<p>最后，送给大家 PHP核心开发者『鸟哥』惠新宸 在近日微博上更新的一句话：</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw1024/71c50075gy1fjvv777fw0j20wy07qwkm.jpg\" alt=\"\"></p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws2.sinaimg.cn/large/006tKfTcly1frsc0k8tt4j314w0cs7a1.jpg","excerpt":"<p><strong>【前言】</strong> 近一年多的时间，笔者在公司中担任过应届生导师、实习生导师、应届生项目导师等一系列导师角色。期间，笔者发现一些即将和准备成为前端攻城狮的同学其实并没有明确前端真正的核心和定位，也没有给自己制定一个学习和发展的方向。","more":"当初选择前端这个职业，也仅仅只是为了找一份工作而已。笔者很想以自己的多年工作经验，为前端应届生们分享一下我心中适合前端工程师的职业规划，让大家对自己有一个比较清醒的认知，避免在以后的成长过程中产生迷茫情绪。当然，笔者其实也才工作五年，能达到现在的技术水平和职级，应该算是发展上升比较快的，一些经验具备一定的借鉴价值。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw1024/71c50075gy1fjk4xumc50j20kk0bf3yh.jpg\" alt=\"\"></p>\n<h2 id=\"前端的兴起\"><a href=\"#前端的兴起\" class=\"headerlink\" title=\"前端的兴起\"></a>前端的兴起</h2><p>前端真正兴起和开始频繁出现在大家的视线里，大概是在十年前。彼时的 Web 开发基本是由后端主导，前端能做的只是校验一下数据、操作一下 DOM。（其中数据检验是 JS 产生的根本原因：当时网络太慢，在服务端检验数据并反馈给用户，让用户知晓输入错误，这个流程太长、反应太慢，因此通过脚本在用户端完成第一步校验，既方便了用户，又减轻了带宽的压力。）即使 06 年 jQuery 发布并风靡全球，以及 XMLHttpRequest 被纳入 W3C 标准，也没有改变这种状况。制约它进度的原因很简单，因为很多事情前端 做不了 或者 做不好。随着时间的推移，近几年，Angular、Backbone、React、Vue 等框架陆续发布，让前端越来越正规化、体系化。此时虽然仍有很多事，前端 做不了 或者 做不好，但前端这个岗位却已变得热辣空前。那么，是什么推动着前端发展到如此大的规模和火热的程度？</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw1024/71c50075ly1fjp9sunt8qj20go08cgml.jpg\" alt=\"\"></p>\n<p>也许，你可以列举出很多各种各样的原因，但是综其一点，就是 <strong>『用户体验』</strong> ，是由于所有人对用户体验的重视，才让前端发展得这么迅猛，这么快地兴起。这里，可能要感谢 Apple，感谢 iPhone，感谢 Jobs，07 年第一代 iPhone 发布，正式引发了几乎所有人对用户体验的重视，从『只要能用就好』，变成『要好用我才买单』的心理。而，前端的先驱者们、浏览器的开发者们，也顺应了这个潮流，将一系列重要的能力加入了浏览器，加入了前端。</p>\n<p>其中最重要的一项是 XMLHttpRequest，也就是 Ajax，它是富 Web 应用的基础，它让前端可以脱离后端的掌控，不用通过跳转的方式就能实现数据交互。感谢微软，感谢 IE，虽然被 IE 6~8 虐了无数遍，但是是它引入了 XMLHttpRequest ，引入了 Ajax，开启了富 Web 应用的时代，让用户体验大幅提升。</p>\n<p>而近几年，随着移动互联网的发展，多端多平台的需求越来越多，产品形态和数据分离，是形势所趋。而与此同时，移动时代对产品形态跨端、跨平台、多元化的用户体验要求，让本身就有跨平台特性的前端技术着实又火了一把，它让开发者有更多的时间和精力关注用户体验，并很容易保持多平台用户体验的统一（不同平台用不同技术实现，虽然可以，但成本太高）；除去上面的原因之外，前端技术自带的热发布、热更新特性，能在及时更新业务需求的同时快速修复用户所遇到的问题，也是大家选择它的一种原因。虽然另外还有很多零零总总、各种各样的原因，再促使着前端成为当前最火爆的几个职位之一，但是最根本的原因仍旧是大家对用户体验的要求。</p>\n<p>从上面可以看出，前端的兴起源于所有人对 <strong>用户体验</strong> 的重视，而火爆更是由于所有人对 <strong>多元化的用户体验</strong> 的关注。当然，用户体验不只只是 UI 漂亮、好看，它是多方面的，例如视图的加载速度和流畅程度，这些取决于你选择技术的编码体积、运行效率等多种因素。说白了，前端的目的就是 <strong>让用户用得爽</strong>，那么 <strong>用户体验</strong> 必须是重中之重。</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/71c50075jw1fbb967wpzlj20gp0c0mzy.jpg\" alt=\"\"></p>\n<p>说了这么多，其实有一个很重要的点没有提到，那就是 CSS。注重用户体验，首先你要用界面要有 UI，HTML + CSS 作为最简单的 UI 构建方式，让前端的 UI 开发成本低到无与伦比，而开发成本低才会有更多的时间和精力去注重用户体验。同时，现在 CSS 也有相应的框架，像 PostCss、Sass 等，更进一步降低了开发成本，释放了开发者的时间和精力。</p>\n<p>前端兴起这十年，也是用户体验飞速增长的十年。不管是技术完善度还是从业人数，前端这个方向受到了足够多技术人员的关注，同时也受到了足够多企业的重视。经过前端人不断的努力，现在的情况又如何呢？</p>\n<h2 id=\"前端的现状\"><a href=\"#前端的现状\" class=\"headerlink\" title=\"前端的现状\"></a>前端的现状</h2><p>提到现状，必须先提到一个概念 <strong>大前端</strong>。由于近几年互联网的发展，尤其是移动互联网的发展，有的大前端概念将 Native 归入前端的范畴，有的大前端概念将 Node 甚至只渲染页面的 PHP 归入前端范畴，但不管怎么说，笔者认为 <strong>大前端</strong> 是未来的一个趋势，将最终目标（提升用户体验）一致的技术归类到一起，让开发者清楚自己的最终目标是什么，要怎么做。当然，也正因为这点，作为一个前端工程师，如果你想更好的发展，你应该有更广的知识面，包括移动端知识、服务端知识。这些知识结合你的前端技术，才能更好地实现优秀的用户体验。</p>\n<p>抛开大前端，单谈前端，从前端架构层面谈，最近比较流行的有四个：老牌劲旅 jQuery、最近火得不能再火的 React、Google 精品 Angular 以及 MVVM 框架 Vue。现在几乎所有的项目都会在这四种架构方案中选择其一作为基础，进行业务开发。四种框架，四种不同的思想，简单来说：jQuery Dom 驱动的思想深入人心；React 则推崇组件化，万物皆组件；Angular 则把 MVC 在前端领域发扬光大；而 Vue 则是以数据驱动为核心的 MVVM 架构。作为一个前端新人，不可能很快就理解所有知识和思想，只能一步一步来，先把你在工作中所使用的框架理解透彻，再去思考和学习别的。说实话，会用和理解的差距很大。</p>\n<p>在这里，可能会有个疑问，上述四个架构，都很火，但是哪里涉及到用户体验了？是的，这些架构都没有直接涉及到 UI。但是就像足球，没有勤奋的训练和优秀的战术，再好的11人也踢不出好的比赛一样，这些架构从开发成本和开发体验上，降低了开发者编码和维护的难度，让其在 UI 的用户体验上的付出，事半功倍。当然，框架在编码体积、运行效率等多个方面影响了最终的用户体验。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqdd2torj20hs0afwer.jpg\" alt=\"\"></p>\n<p>上面所说的是，当前前端的一大现状 —— <strong>框架横行</strong>，现在很少有公司、有工程师用纯原始的方式撸代码了。而前端另一大现状就是 —— <strong>移动为先</strong>。原因很简单，随着移动互联网用户的暴涨，各个公司的产品都是移动为先，技术跟随着产品的步伐，也必须移动为先。这时，为了解决多平台的问题，Hybrid 方案脱颖而出，包括传统的基于 WebView 的 Hybrid 方案（例如 Cordova）和 React-Native 等一系列技术方案。在这里我就不多说了，关于移动前端的内容最近充斥着各种技术论坛、交流群、公共号，具体的，大家可以自己亲身去了解。</p>\n<p>最后，对于现状，我想大家可能最关心的其实是职业形势。由于前端的兴起，前端人才市场相当活跃，平均薪金水平也是名列前茅。与此同时，前端的技术入门比较容易，造成另一个极端情况：人员泛滥、人才稀缺。这种情况，一方面由于前端发展太快，很难短时间掌握全部知识；另一方面，高等院校并没有开设专门的前端专业，大家更多是自学，野路子很多。所谓乱世出英雄，这样的前端大环境或许对一个新入行的同学更有利。当然，在如此『乱世』中，一个好的职业规划，才能避免『误入歧途』，保证自身顺利地成长。</p>\n<h2 id=\"如何做一个职业规划\"><a href=\"#如何做一个职业规划\" class=\"headerlink\" title=\"如何做一个职业规划\"></a>如何做一个职业规划</h2><p>上面讲述了前端如何兴起和前端的现状，下面将基于上述两点，分几个方面为大家提供一些有关职业规划的观点，希望对大家有帮助。</p>\n<h3 id=\"确定方向\"><a href=\"#确定方向\" class=\"headerlink\" title=\"确定方向\"></a>确定方向</h3><p>做职业规划的目的是避免迷茫，而避免迷茫最有效的方式就是确定明确的方向和目标。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw1024/71c50075ly1fjpqg4xgwsj20sg0i2gmq.jpg\" alt=\"\"></p>\n<p>对于任何一个技术岗位，都有固定的两个方向：<strong>技术专家</strong>（架构师）和 <strong>开发经理</strong>。前者偏重技术，需要你在当前领域钻研得很深；后者偏向管理，需要你在对技术有很深掌握的同时，可以带领团队完成项目的开发。当然，两者并不是鱼与熊掌的关系，你可以同时成为技术专家和开发经理。</p>\n<p>对于技术专家和开发经理两个方向的选择，更多取决于你自身在工作中多巴胺的分泌情况。当你专研技术时，多巴胺分泌得更多，感到更兴奋，或许你会很容易成为技术专家；反之，当你跟团队一起做业务时，多巴胺分泌得更多，更有获得感，那么你可以尝试向开发经理方向发展。当然，你也可能做什么都没有分泌\u0001太多的多巴胺，那么，你可以在尝试一段时间后，转型其他职业，例如产品经理。前端作为核心是用户体验，与用户最近的工程师，转型产品经理，阻碍会小一些。况且，文艺型前端布道人豆瓣前端负责人张克军认为，<strong>前端工程师正慢慢演变为产品工程师</strong>，前端和产品离得确实很近。</p>\n<p>当你选择好一个方向后，你就要朝着这个方向一步一步进发。丹尼尔在《一万小时天才理论》提出一万小时定律，即要成为某个领域的专家，需要积累一万小时。当然这只是个概数，不过每天花更多的时间去学习和实践，肯定是最有效的。这里，成为技术专家和开发经理过程中，关注的点略有差别。成长为技术专家，要更多关注技术本身的实现，包括逻辑、架构、设计模式、方法论等；而成长为技术经理，则要更多关注技术开发的过程，考虑如何提高开发效率、降低开发成本、优化开发质量等等。不同的人，精力是有限的，选择性关注一些必要的方面，对自身快速的成长是很有必要的。</p>\n<h3 id=\"做业务还是做架构\"><a href=\"#做业务还是做架构\" class=\"headerlink\" title=\"做业务还是做架构\"></a>做业务还是做架构</h3><p>做业务，时间要求比较紧，代码质量要求高，可参考的代码比较多，业务知识需要学习。做架构，时间稍微自由，对经验要求比较高，无可参考代码，专业基础知识需要深刻理解；最主要的，做架构的你既是开发，又是用户，还是 PM ，只有 80% - 90% 的明确目标，并在开发过程中不断微调最终的目标。</p>\n<p>对于一个新人，其实不用纠结，<strong>做业务才是好的选择</strong>，而且做 <strong>技术含量高</strong>、<strong>使用流行技术</strong> 的业务才是最好的。原因很简单，架构的最终的目的是解决业务当中的问题，你没做过业务，哪能知道业务的问题在哪，你都不知道要解决什么问题，如何做好架构。所以，从业务做起，是新人最好的选择，也是唯一可行的选择。而选择有技术含量、使用流行技术的业务的原因更多在于成长，这样你的成长可能会更快、成长道路可能会更直。当然，这只是『可能』，不同的人适合不同的业务，所以不要强求一定『技术含量高、使用流行技术』的业务，更多的而是改变自己，去 <strong>适应团队</strong>、<strong>适应业务</strong>，这样才能 <strong>更快地成长</strong>。</p>\n<p>事实上，很多时候，你会遇到很业务工作很繁重没有额外时间学习的情况。而如何在这样环境中更快地成长呢？说白了就是『抄』，不不，是 <strong>参考</strong>。将学习融入到工作中，是最好的方法。做新项目，参考老项目代码；做新需求，参考老需求的代码；没有同类型的代码，参考别的业务的代码。参考前人的经验，在巨人的肩膀上，成长才会变得更快。同时，你的导师和你的伙伴，也会在业务中给你指点，帮你快速解决成长路上的问题。</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw1024/71c50075ly1fjpqppgz3kj20ro0lc76e.jpg\" alt=\"\"></p>\n<p>在这里，总结一下，在繁重的业务环境下快速成长，你需要 <strong>很优秀的学习能力</strong>、<strong>很持久的耐心</strong> 以及 <strong>很好的导师和伙伴</strong>，这样才能在技术成长的路上事半功倍。</p>\n<h3 id=\"技术的学习\"><a href=\"#技术的学习\" class=\"headerlink\" title=\"技术的学习\"></a>技术的学习</h3><p>说了半天，到了最核心的问题了，对于一个新人如何学习技术？笔者给的建议是：千万不要囫囵吞枣，<strong>先把当前使用的技术学透用熟，才是最重要的</strong>；千万不要在还没把当前使用的技术吃透之前，去学新的东西，不管新的东西有多火。就像上文所说，不同的框架，有不同的核心，有不同的思想。两个框架代码相似之处的思想不一定相似，例如 Angular 和 Vue 都有双向绑定，虽然效果相似，但是实现思想和内部实现方式是截然不同的。还在入门阶段的你，会被各种思想充斥头脑，反而会更不清楚。</p>\n<p>一定的时间后，当你理解透一个架构体系后，你可以 <strong>类比地去看</strong> 更多的架构体系。这时候，你会发现不同\u0001架构很多东西都是殊途同归，理解得很快。</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw1024/71c50075ly1fjpqhikta8j207x07xq3b.jpg\" alt=\"\"></p>\n<p>当然，理解透一个架构体系，有人需要一年，有人需要三年，还有人可能需要更长时间。为什么有这么大的区别呢？因为有些人在开发中，并不认为完成就可以了，会在开发中，追求代码的优美，会不断优化自己的代码，让自己的代码性能更好、可读性更高，并通过长时间的积累，达到 <strong>量变导致质变</strong> 的程度。即使一个特别聪明的人，没有『量』也不可能『质变』的，只不过他的量可能比其他人少而已。</p>\n<p>要提醒的一点是，学技术，一定要结合你所在公司、团队的技术栈。例如，去哪儿前端应届生会在进入业务线前，进行3个月的脱产培训，2017年的前端培训课程内容中涉及的技术主要是 React 和 React Native，而去哪儿业务的技术栈也大多是 React，那么作为去哪儿的前端应届生，你优先学习 React 的技术体系是事半功倍的，既有前人可以问，又有项目可以实践。</p>\n<p>当然，在学习架构的同时，不要忽略两样最基本的东西，一个是 <strong>技术基础</strong>，一个是 <strong>开发规范</strong>。</p>\n<p>技术基础是一切开发、架构的前提，没有一个好的基础，是无法让你自身的技术水平达到足够高的维度。例如你对于继承理解的并不透彻，你很难理解清晰 React 的内部实现。</p>\n<p>对于开发规范，笔者在带应届生时特别注意让他们遵守。代码规范比比皆是，但是很少有人严格遵守。究其原因，多是在代码规范制定之前，已经有自己的一套代码习惯，很难短时间改变自己的习惯。而应届生，一般来说代码并不多，还没有形成自己的编码习惯。这时候，开始遵守一定的规范，会促使他们养成一个较好的编码习惯，为后续的成长打好基础。下面，列举一下开发规范的几点好处，让大家明白代码规范的重要性：</p>\n<ul>\n<li>规范的代码可以促进团队合作。</li>\n<li>规范的代码可以减少 Bug 处理。</li>\n<li>规范的代码可以降低维护成本。</li>\n<li>规范的代码有助于代码审查。</li>\n<li>养成代码规范的习惯，有助于程序员自身的成长。</li>\n</ul>\n<p><img src=\"https://wx2.sinaimg.cn/mw1024/71c50075ly1fjpqisken8j20j007r0tg.jpg\" alt=\"\"></p>\n<p>这部分最后，推荐一些学习技术的好地方，例如情封大大三年不停更的《前端早读课》、阿里大漠（不是大漠穷秋）的 w3cplus.com、微信公众号《前端圈》、《前端之巅》、《Node 全栈》，当然还有公司内的 《Qunar 技术沙龙》微信公众号，笔者所在团队 YMFE 的博客 blog.ymfe.org 等，都是学习技术的好地方。</p>\n<h3 id=\"主战场-——-移动混合开发\"><a href=\"#主战场-——-移动混合开发\" class=\"headerlink\" title=\"主战场 —— 移动混合开发\"></a>主战场 —— 移动混合开发</h3><p>随着移动浪潮的兴起，业务在移动端App 的需求量迅速扩大，应用迭代更新的频率也随之极速攀升，但与此同时纯 Native 的开发和更新成本成为了业务增长难以逾越的瓶颈。因此，引入一种开发更高效、成本更低的解决方案势在必行。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw690/71c50075ly1feyt6lzpb5j208c03mq4d.jpg\" alt=\"\"></p>\n<p>在当前的移动互联网环境下，iOS 和 Android 上的 App 已经成了每个互联网产品的标配。如果一个用户端产品并不提供相应 App 版本，几乎会直接定义成一个不完整的产品。而被互联网人尊为铁律的『唯快不破』—— 快速开发、高速迭代、低成本上线，同时也是移动时代每个开发团队所追求的目标。综合以上两点原因，『Native 搭台，Web 唱戏』的 Hybrid 开发模式，以『快』的特点赢得了大家的青睐，并纷纷投入大量开发力量，使这种开发模式迅速走红。当前最常见的技术架构方案有以下三种：</p>\n<ul>\n<li>基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案</li>\n<li>非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native</li>\n<li>基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离的解决方案：微信小程序</li>\n</ul>\n<p>对于一个前端，笔者感觉每个人必须了解这三种常见方案的实现方式和优缺点，这样才能在开发移动端业务的时候，更为清楚自己所要注意、所要学习的地方。当然，仅仅了解实现方式是不够的，你要有环境去实践你学习的东西。再拿去哪儿为例，去哪儿现在大多数业务都是移动端的，Hybrid 和 RN 方案都在被使用。所以，作为一个应届生，你很有可能去做一些 Hybrid 或者 RN 的项目。做 Hybrid 项目时，你更多要考虑的是『如何高效地操作 Dom』；反之，做 RN 项目，你更多要考虑的则是『如何减少和 Native 的通信』。这两点，最终都会反应在项目的用户体验上。</p>\n<h3 id=\"前端中的『另类』——-Node\"><a href=\"#前端中的『另类』——-Node\" class=\"headerlink\" title=\"前端中的『另类』—— Node\"></a>前端中的『另类』—— Node</h3><p>对于 Node，作为一个前端，应该并不陌生。Node 最大的卖点在于完全异步的 I/O 模型，相比于阻塞 I/O ，异步 I/O 模型极大提高 Web 服务的并发性。因此，前端都可以自己开发服务端了？</p>\n<p>这样认为的同学，笔者只能说，你想多了。Node 是可以开发服务端，但是不代表所有前端都可以使用 Node 去开发一个庞大业务的服务端。你去知乎搜索使用 Node 开发服务端的相关问题，一部分人会说 Node 不能替代之前的服务端语言，另一部分人会说什么也阻挡不了 Node 在服务端的脚步；同时有很多诸如 Paypal、阿里这样大公司大规模使用 Node，也很多公司在落入 Node 深坑而不起。不论争论如何，笔者认为，Node 是否能写服务端，主要在于使用 Node 的人是否有服务端的思想。开发服务端和开发前端是完全不同的思想，服务端更注重效率、更注重稳定、更注重高并发情况下数据的处理，用前端的思想去开发服务端显然是不行的。当然，成功的案例中，Node 也更多运用在页面渲染这一层，配合前端更快的渲染页面，提高用户体验；而复杂的数据逻辑，还是用传统的服务端语言进行开发，毕竟技术成熟、运维成本低。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw1024/71c50075gy1fjqcesr5j5j20et08c0sq.jpg\" alt=\"\"></p>\n<p>这里，会出现一个问题，我只是前端，需不需要去学习 Node？笔者的答案是 <strong>需要</strong>。前端兴起已经很多年，已经从游击队乱枪打鸟的阶段逐渐变为规模化、工程化的时代。在这个时代中，尤其是在工具和流程方面，Node 起到了很大的作用，扮演很重要的角色。诸如 Webpack、Gulp、NPM 这些工具，他们被运用在各个公司的各类前端项目中。学习 Node 其实就是去学习前端的工具，去学习前端的工程化。</p>\n<p>\u0001当然，如果你立志是全栈，或者想做服务端的一些工作，再或者想通过 Node 学习服务端的技术和原理，都可以去学习 Node。请相信笔者，你不会失望的。</p>\n<h3 id=\"前端一直在『造轮子』中不断前进\"><a href=\"#前端一直在『造轮子』中不断前进\" class=\"headerlink\" title=\"前端一直在『造轮子』中不断前进\"></a>前端一直在『造轮子』中不断前进</h3><p><strong>造轮子</strong> 的意义是重新实现已有的功能，以达到更好的效果。这个词语，常见于技术圈，尤其是前端圈，逐渐被人贬义地用来『嘲讽』一个重新实现已有功能的工具、框架以及方案。那么，造轮子究竟是怎样一种行为？</p>\n<p>首先，笔者并不排斥造轮子，至少有一位大神造轮子造得很成功，那就是 Linus Torvalds。Minix 不好用，就造了一个 Linux；Bitkeeper 停止授权，就造了一个 Git。并且两个新『轮子』已经成为世界上最好的轮子之二。这种创造性的造轮子，是令人赞赏的。</p>\n<p>其次，不同的技术体系，互相学习，参考对方的思想，造自己的轮子，也是一个非常好的想法。尤其是前端，它通过学习其他语言、体系的架构方案，丰富自身，短短几年就上升到很高的高度。可以举得列子很多：例如 Angular 的 MVC + DI + IoC 的模式，很多人会直接想到 Java 的 Spring，甚至 Angular 也包含 AOP 的编程思想；再例如 MVVM 双向数据流的模式，本身就是微软的 WPF 首先提出的。轮子可以造，对开发有意义即可。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqbn6abaj20gm04r3yo.jpg\" alt=\"\"></p>\n<p>最后，大家 <strong>反感造轮子</strong>，其实更多在于反感造一个没有任何创新的轮子，还天天到处宣扬自己的产物。你可以自己造一个没有任何创新的轮子，用来学习造轮子的过程，同时这也是深入轮子最好的方式，没有之一。当你了解当前轮子的根本构造之后，你就能在这个基础上进行更多的创新。</p>\n<h3 id=\"其他方面的学习\"><a href=\"#其他方面的学习\" class=\"headerlink\" title=\"其他方面的学习\"></a>其他方面的学习</h3><p>作为一个前端，\u0001最该学习的两个方面是 <strong>产品</strong> 和 <strong>设计</strong> 。学习产品思维，会帮助你从用户的角度审查你开发的产品，找出用户体验不优、交互不好的地方；而学习设计，则帮助你分析不优的地方的原因，并找出解决方案。当然，每个人的精力有限，不可能把这两个方面学得特别深，但最好都要有接触，有一定深度的学习。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw1024/71c50075ly1fjpqn9oytbj20rs0k9gnb.jpg\" alt=\"\"></p>\n<h3 id=\"小总结\"><a href=\"#小总结\" class=\"headerlink\" title=\"小总结\"></a>小总结</h3><p>前文并没有直接跟大家说明怎么做职业规划，而是从发展方向、技术学习、主要业务场景、NodeJS、造轮子问题等多个方面，来给大家分析：作为前端，哪些需要做、哪些不需要做、哪些必须做、哪些可以做。大家可以根据自己的兴趣、能力等特性，并且和自己在公司所做的项目结合，决定做哪些、不做哪些、强制自己做哪些、有空余时间做哪些等等类似的决定。这里可以举个例子，例如：我的目标是成为一个技术专家，因此，我要深植业务一到两年，严格控制自己的代码规范，深入了解 React 体系，在移动端主攻 React Native，而且有时间看 Node  及 Babel 相关工具，目标是彻底理解 React 的技术实现和 Web Component 的开发思想。当你有这样一个目标时，你可以清楚知道自己做事的目的，可以清晰看到自己的成长。</p>\n<p>要注意的是，如果你已经有工作的话，<strong>你的职业规划绝对不能脱离你现在的工作</strong>。实践出真知，工作带给你的实践环境，才是你成长的营养来源。</p>\n<h2 id=\"前端的未来\"><a href=\"#前端的未来\" class=\"headerlink\" title=\"前端的未来\"></a>前端的未来</h2><p>对于前端的未来，或者说是互联网技术的未来，我比较认同阮一峰老师的一个观点：将来程序员只分为两类，<strong>端工程师</strong> 和 <strong>云工程师</strong>。端工程师，直面用户，为了用户能更好使用产品而殚精竭虑，包括传统的前端、Native、AR/VR、TV 端开发等；而云工程师，直面数据，将冰冷冷的数据转化为与用户息息相关的产品，包括分布式、大数据、机器学习等等。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw1024/71c50075ly1fjpqlocoeij20fp09wwf2.jpg\" alt=\"\"></p>\n<p>前端不管演变成什么，它所关注的永远是 <strong>用户体验</strong>，只不过端增加了，开发的方式也增多了而已。作为一个前端工程师，要时时关注业界动态，更多地学习新技术，提升自己的实力，来适应更大的挑战。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>作为一个初入前端圈的新人，你或许对上面描述的东西并不完全理解，这没有任何问题。做一个适合自己的职业规划，并不急于一时，其实最好是在工作一段时间后，和你的 leader 或者伙伴们一起对自己做一个评估，并根据前面所讲，给自己制定一个适合自身情况、符合自身兴趣的职业规划，并按照规划一步步不断提高自己，向前方的成功迈进。</p>\n<p>笔者真心希望这篇文章可以给正在迷茫的你些许帮助。年轻且精力旺盛的前端领域，还没有形成像后端那样多的实施标准和最佳实践，每个人都可能有不同的思维、不同的思路。本文仅是笔者个人观点和看法，有错误或者疏漏之处，敬请谅解。同时也欢迎私下和笔者进行更深层次的探讨。</p>\n<p>最后，送给大家 PHP核心开发者『鸟哥』惠新宸 在近日微博上更新的一句话：</p>\n<p><img src=\"https://wx1.sinaimg.cn/mw1024/71c50075gy1fjvv777fw0j20wy07qwkm.jpg\" alt=\"\"></p>"},{"title":"审美 VS 科学 —— 用科学定义设计","date":"2018-03-10T04:00:00.000Z","thumbnailImage":"https://ws1.sinaimg.cn/large/006tKfTcly1frsbzrqjj3j315i0de4qp.jpg","_content":"\n在去年的博客《写给应届生的职业规划建议》里，提及了“作为一个前端，\u0001最该学习的两个方面是 **产品** 和 **设计**”的观点，而在这篇博客中，笔者就来谈一谈设计，谈一谈偏重逻辑思维的工程师怎么有效地学习和运用设计。<!-- more -->\n\n笔者所在的团队从去年系半年开始，成立设计小组，逐步开始负责团队产品的 UI/UE 设计，以求让团队产品更为 **易用**。\n\n前言到此为止，接下来要进入正题，而正题的第一点，就是—— **互联网产品中设计的重要性**。\n\n## α. 设计之重\n\n从苹果的崛起，大家充分认识到设计的重要性 —— **拥有优秀设计的产品，是不需要说明书的**。不管从工业设计还是视觉设计上，苹果都给人一种美轮美奂的感觉。虽然如此，但是很多人仍旧认为设计是锦上添花的事情，只要产品功能完善，一切就无可阻挡。可是，虽然从巴莱特定律（80/20法则）来看，设计很有可能在产品的20%部分，但是殊不知，在大家都能完成了 80% 时，这 20% 仍会轻于鸿毛吗？\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fp91dl4w3kj31ja0ls41m.jpg)\n\n年初蚂蚁金服的 See Conf 中，蚂蚁的演讲人提出一个非常新颖的观点 —— **互联网逐步会“消失”** 。当然这里的“消失”并不是“灭亡”的意思，而是 **互联网将和我们的世界充分融合**，人们将从 **Connect the Internet** 到 **Use the Internet**，再在 **Enjoy the Internet**，而现在所处的阶段就是从 **Use the Internet** 到 **Enjoy the Internet** 的过程中，让用户更容易、更便捷地使用，从而享受互联网带来的一切。进一步，从用户的视角来看，**人机交互** 将是实现这个目标的重中之重，而 **设计** 则是 **人机交互** 的重中之重。\n\n不管观点如何，历史总可以给我们答案。当一个事物从胜到极胜的过程中，细节绝对是决定成败的最关键因素，而 **设计才能将产品细节体现得更为突出** 。互联网发展到现在，甚至有人说“互联网已经是传统行业”的时候，要更进一步的发展，**忠于用户体验的设计绝对是必不可少的**。\n\n## β. 无设计的开发过程\n\n着眼现在，在很多前端需求的开发过程中，是 **无设计的**，主要的是以下两种情况：\n\n* 没有 UI/UE 图，工程师自己对着需求撸代码，设计随遇而安。\n* 有 UI/UE 图，但是由于工程师对设计不理解，还原得很“糟糕”。\n\n其中，第二种情况尤其突出。这里的“糟糕”是带双引号的，并不是指工程师还原 UI/UE 图还原得不到位，而更多的是说当工程师将 UI/UE 图还原至很高的程度以后，实际效果并不像设计图上所展现的那样美观。这里往往是因为工程师对设计不理解，从而带来一些实现上的细节差异，造成了实际效果差别巨大。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fp931493ioj31100lghdt.jpg)\n\n虽然，这两种情况，可以通过规范相关的开发、评审流程来避免，但是有些时候，不可避免因为业务、产品变更频繁、页面复杂或者人力问题，造成此类情况。因此，如果工程师懂一些设计，那么这些问题，虽然可能不会完全避免，但是也足以让影响尽可能地变小。\n\n但是，对一个理科出身、擅长逻辑思维、平时天天撸代码的、甚至毫无审美可言的工程师来说，如何 **理解设计**，**学习设计**，并在实际中 **运用所学的设计知识**，看起来是一项 **不可能完成的任务**。但是事实真的如此吗？\n\n## γ. 审美 VS 科学\n\n什么是 **审美**？欣赏、品味或领会事物及艺术品的美。每个人都有审美的，虽然有差别，但是很多时候，例如去景区旅游、去博物馆欣赏艺术品，大家对美的评判其实是很相近的。但是为什么有很多工程师，硬要说自己没有审美呢？\n\n其实，**没有审美** 并不是 **没有评判美的能力**，更多的是 **他们找不到不美的原因**，找不到原因，就不能修复缺陷，就不能让产品变得更美。\n\n什么是 **科学**？科学是一个建立在可检验的解释和对客观事物的形式、组织等进行预测的有序的知识的系统。而最基础的自然科学，则是工程师心里“最高的信仰”，就像“给我一个支点，我能撬动地球”一样，给工程师一个规则，什么事都可以做到最好。\n\n这就好办了，用科学的方法定义一下“美”，把提炼出来的“公式”给工程师，工程师就能让产品“美美哒”了。那么科学和审美碰撞的效果究竟是什么？\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fp99r5xzexj31kw0ikteu.jpg)\n\n团队内，一些人参加了年初的 See Conf，有一位小伙伴听完以后，竟然有“朝闻道，夕死可矣”的感受。原因是在《Ant Design 3.0 背后的故事》里，他看到了身为一个不是科班出身却非常喜欢设计的技术工程师的价值。\n\n“Ant Design 认为，一切看似自然的事物在背后都是有数学/物理规律可循的。映射到我们的设计中，从自然的数理规律中寻找启发，理性的看待我们设计决策的过程，将设计结果、影响结果的变量、以及他们之间的规律发掘出来，就是我们的方向。而这个理性思考，感性表达的过程和我们团队的技术基因也是非常匹配的。”\n\n这句话，是笔者非常赞同的，并深深被其打动。人类一贯是用科学来定义方法，然后按方法来执行具体的行动，而按照所谓的“感觉”来行事的，一贯被认为是“不靠谱”的。当然，笔者不是指设计师做设计都是靠感觉的，他们有一套设计科学，包括配色、沟通等很多专业性的理论基础，但是，对于一个没有设计基础的工程师来讲，他的感觉很大概率是偏离方向的。\n\n同时，科学也让设计理论更为确定，更容易被人接受。就像中医，笔者相信中医是一门确定性非常强的医学，否则中国古代不可能出现那么多像贞观之治一般的鼎盛时代，但是由于中医的很多理论都没有科学基础，所以才被大众所质疑。设计也一样，“因为这个规则，所以这样做更好”肯定比“我觉得这样比较好”要更有说服力。\n\nAnt Design 3.0 的设计价值观是“**确定**”和“**自然**”，从自然中提取出“美”，然后用确定的科学规则来描述它，最终形成一套准确的设计规范，这样才更有价值。下面是个很“自然”的例子。\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fp9axiuuvdj30k005rjrj.jpg)\n\n什么样的字号，用户看得最舒服？从图中可以看到，在人和屏幕距离一定的时候，人观看文字的视线角度（a），决定了人的舒适程度。有机构和团队做过研究，当大于 0.3 度时的阅读效率是最好的。同时我们在操作电脑时，一般来说眼睛距离电脑屏幕的平均值大概会在 50 厘米(2.45 inch)左右。这就算出来，字体应有的高度大于 12 px，再根据屏幕的 PPI，可以算出字号为 14px 时，77% 的用户最为舒服，而这个字号，就成为 Ant Design 3.0 的主字号。\n\n当你有一个主字号的时候，其他字号又怎么算出来的呢？\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fp9bivt56lj30k006q3yo.jpg)\n\n14是主字号，而 2.71828 和 5 又是怎么来的？\n\n* 2.71828 其实是就数学课中学到的自然常数，也可以称她为欧拉数，是一个超越数（无限不循环小数），和 π 称兄道弟。\n* 5 的来源更为神奇。有国外大神建议，参考音律的规则，令字阶呈现出一种自然的节奏感。最终通过实验验证出来的最合适的数值是 5，而 5 声音阶是很多古典乐遵循的规律，比如宫、商、角、徵、羽。\n\n**Amazing！** 你有没有感受到自然之美，一个追寻着科学的真理，让处女座都生不出丝毫厌恶之心的规则，对于工程师来说，是多么美妙啊。\n\n不仅仅是字号，包括行高，包括字间距，包括排版，包括颜色，都可以用很自然的规则去定义它们。同时也不仅仅是蚂蚁金服，苹果的设计一直很自然，从拟物到偏平，虽然每次升级是都会被人吐槽，但是用习惯了都会觉得很舒服。从 Google 的新 Logo，到腾信的独创字体，都很自然，同时也都很确定。\n\n给你一个支点，你能撬动地球；给你一个确定的科学规则，你是否能产出足够美的产品呢？\n\n## δ. 设计不只是美\n\n设计不只是美，美只是设计的第一步，它让用户在使用时，尤其是第一次使用时，至少可以有个好的印象。而设计的最终目的其实是为了更好地、更准确地传达信息，让用户更方便、更容易的接受信息，从而让产品能解决用户的问题。\n\n因此，设计追求的是卓越的用户体验，不仅仅是感官的体验还有使用的体验。使用的体验或许更为重要，但是它要在感觉体验的基础上完成，才能让体验相辅相成，让设计更为完整。\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fp9w8eu48hj30go08w0t5.jpg)\n\n用户体验的核心是 **研究用户在特定产品的场景下的思维和行为模式，然后利用研究的结论，创造出适应用户、让用户感觉舒服的产品**。一个优秀的用户体验，会将产品设计成符合用户的思维行为习惯；而一个卓越的用户体验，会基于用户本身的思维行为习惯创造出符合产品特性的设计，并引导用户进行使用。\n\n因此，理解产品，才能做出好的设计；理解产品并理解好的设计，工程师才能更好地对产品进行开发。但是工程师如何去学习设计呢？上文说过，设计是一个门包含众多的理论，不可能面面俱到地去学。这时，我们应该选取比较容易但效果足够好的东西去学，那就是设计的基本原则。\n\n## ε. 无原则，不科学\n\n既然谈到了科学，那么就应该谈一谈规则、原则。所有科学，基本上都是建立在确定的规则上的，而设计也一样。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fp9wti2sdkj30go04qdgh.jpg)\n\n左侧是一个让处女座发狂的“放荡不羁”的设计，而右侧则是符合设计原则的。或许有人会觉得左侧的设计体现的是自由、奔放，体现出舞蹈的多样性，但是不管如何自由，让用户不能快速地获取信息，这就是个坏的设计。那么，到底什么是设计的原则呢？\n\n在《写给大家看的设计书》中，Robin 提出了设计的四大基本原则：**对齐**、**重复**、**对比**、**亲密性**。每一个优秀的设计作品通常都遵守这四大基本原则，互联网设计也不例外。\n\n* **亲密性**：**彼此相关的应当靠近，归组在一起。** 如果多个项目相互之间存在很近的亲密性，它们就会成为一个视觉单元，而不是多个独立的元素，这有助于信息组织，减少混乱，为读者提供清晰的结构。\n* **对齐**：**任何东西都不能在页面上随意安放。** 每个元素都应当与页面上的另一个元素有某种视觉联系。这样能建立一种清晰、精巧而且清爽的外观。\n* **重复**：**让设计中的视觉要素在整个作品中重复出现。** 可以重复颜色、形状、材质、空间关系、线宽、字体、大小和图片，等等。这样一来，技能增加条理性，还可以加强统一性。\n* **对比**：**避免页面上的元素太过相似。** 如果元素（字体、颜色、大小、线宽、形状、空间等）不相同，那就干脆让它们截然不同。\n\n这四项基本原则非常基础，就像数学中的加减乘除一般，对于一个工程师，这些很容易学会并理解。\n\n可是，作为工程师，为什么要学呢？学这么点又有什么用呢？很简单的原因，虽然学习这些很基本的东西，并不能让你真正可以进行设计，但是它能在你无设计的开发过程中，**不再用感觉来尝试修复“审美的不足”，而用科学的方法去发现并解决问题**。虽然它也许只能做巴莱特定律中 80% 里的东西，但它可以以很小的成本，规避一些很常见的错误，让工程师少走几次弯路，少改几次代码。笔者觉得这样就足够了。\n\n如果作为工程师的你，真的下定决心学习设计，那么阅读《写给大家看的设计书》是个不错的选择。\n\n## ζ. 写在最后\n\n其实设计小组的成员并不是纯粹的设计师，他们更像 **体验工程师**，把优秀的体验真正实现在项目中。最后还是那句话：\n\n作为一个前端，\u0001最该学习的两个方面是 **产品** 和 **设计** 。学习产品思维，会帮助你从用户的角度审查你开发的产品，找出用户体验不优、交互不好的地方；而学习设计，则帮助你分析不优的地方的原因，并找出解决方案。\n\n对于团队的交互设计发展，我们准备像成熟的设计团队一般，并模仿他们，构建自己的设计体系 —— **Youth Design**。我们要不断地 **拥抱未来**，不断探索未来的交互形式，吸收前沿的设计理念的同时，**对科学保持保持敬畏**，用科学的态度保持设计产品的确定性。当然，身为 Qunar 人，我们必须要 **立足青春**，让我们的设计真正被年轻人喜欢。\n\n最后，感谢董文博、张文杰、田琦、侯情缘这些 YMFE 交互设计小组的成员们给这篇文章提供了这么多很有价值的内容。\n","source":"_posts/2018-03-10-用科学定义设计.md","raw":"title: 审美 VS 科学 —— 用科学定义设计\ndate: 2018-03-10 12:00:00\ncategory: 产品设计\ntags: [Design]\nthumbnailImage: https://ws1.sinaimg.cn/large/006tKfTcly1frsbzrqjj3j315i0de4qp.jpg\n---\n\n在去年的博客《写给应届生的职业规划建议》里，提及了“作为一个前端，\u0001最该学习的两个方面是 **产品** 和 **设计**”的观点，而在这篇博客中，笔者就来谈一谈设计，谈一谈偏重逻辑思维的工程师怎么有效地学习和运用设计。<!-- more -->\n\n笔者所在的团队从去年系半年开始，成立设计小组，逐步开始负责团队产品的 UI/UE 设计，以求让团队产品更为 **易用**。\n\n前言到此为止，接下来要进入正题，而正题的第一点，就是—— **互联网产品中设计的重要性**。\n\n## α. 设计之重\n\n从苹果的崛起，大家充分认识到设计的重要性 —— **拥有优秀设计的产品，是不需要说明书的**。不管从工业设计还是视觉设计上，苹果都给人一种美轮美奂的感觉。虽然如此，但是很多人仍旧认为设计是锦上添花的事情，只要产品功能完善，一切就无可阻挡。可是，虽然从巴莱特定律（80/20法则）来看，设计很有可能在产品的20%部分，但是殊不知，在大家都能完成了 80% 时，这 20% 仍会轻于鸿毛吗？\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fp91dl4w3kj31ja0ls41m.jpg)\n\n年初蚂蚁金服的 See Conf 中，蚂蚁的演讲人提出一个非常新颖的观点 —— **互联网逐步会“消失”** 。当然这里的“消失”并不是“灭亡”的意思，而是 **互联网将和我们的世界充分融合**，人们将从 **Connect the Internet** 到 **Use the Internet**，再在 **Enjoy the Internet**，而现在所处的阶段就是从 **Use the Internet** 到 **Enjoy the Internet** 的过程中，让用户更容易、更便捷地使用，从而享受互联网带来的一切。进一步，从用户的视角来看，**人机交互** 将是实现这个目标的重中之重，而 **设计** 则是 **人机交互** 的重中之重。\n\n不管观点如何，历史总可以给我们答案。当一个事物从胜到极胜的过程中，细节绝对是决定成败的最关键因素，而 **设计才能将产品细节体现得更为突出** 。互联网发展到现在，甚至有人说“互联网已经是传统行业”的时候，要更进一步的发展，**忠于用户体验的设计绝对是必不可少的**。\n\n## β. 无设计的开发过程\n\n着眼现在，在很多前端需求的开发过程中，是 **无设计的**，主要的是以下两种情况：\n\n* 没有 UI/UE 图，工程师自己对着需求撸代码，设计随遇而安。\n* 有 UI/UE 图，但是由于工程师对设计不理解，还原得很“糟糕”。\n\n其中，第二种情况尤其突出。这里的“糟糕”是带双引号的，并不是指工程师还原 UI/UE 图还原得不到位，而更多的是说当工程师将 UI/UE 图还原至很高的程度以后，实际效果并不像设计图上所展现的那样美观。这里往往是因为工程师对设计不理解，从而带来一些实现上的细节差异，造成了实际效果差别巨大。\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fp931493ioj31100lghdt.jpg)\n\n虽然，这两种情况，可以通过规范相关的开发、评审流程来避免，但是有些时候，不可避免因为业务、产品变更频繁、页面复杂或者人力问题，造成此类情况。因此，如果工程师懂一些设计，那么这些问题，虽然可能不会完全避免，但是也足以让影响尽可能地变小。\n\n但是，对一个理科出身、擅长逻辑思维、平时天天撸代码的、甚至毫无审美可言的工程师来说，如何 **理解设计**，**学习设计**，并在实际中 **运用所学的设计知识**，看起来是一项 **不可能完成的任务**。但是事实真的如此吗？\n\n## γ. 审美 VS 科学\n\n什么是 **审美**？欣赏、品味或领会事物及艺术品的美。每个人都有审美的，虽然有差别，但是很多时候，例如去景区旅游、去博物馆欣赏艺术品，大家对美的评判其实是很相近的。但是为什么有很多工程师，硬要说自己没有审美呢？\n\n其实，**没有审美** 并不是 **没有评判美的能力**，更多的是 **他们找不到不美的原因**，找不到原因，就不能修复缺陷，就不能让产品变得更美。\n\n什么是 **科学**？科学是一个建立在可检验的解释和对客观事物的形式、组织等进行预测的有序的知识的系统。而最基础的自然科学，则是工程师心里“最高的信仰”，就像“给我一个支点，我能撬动地球”一样，给工程师一个规则，什么事都可以做到最好。\n\n这就好办了，用科学的方法定义一下“美”，把提炼出来的“公式”给工程师，工程师就能让产品“美美哒”了。那么科学和审美碰撞的效果究竟是什么？\n\n![](https://ws4.sinaimg.cn/large/006tNbRwly1fp99r5xzexj31kw0ikteu.jpg)\n\n团队内，一些人参加了年初的 See Conf，有一位小伙伴听完以后，竟然有“朝闻道，夕死可矣”的感受。原因是在《Ant Design 3.0 背后的故事》里，他看到了身为一个不是科班出身却非常喜欢设计的技术工程师的价值。\n\n“Ant Design 认为，一切看似自然的事物在背后都是有数学/物理规律可循的。映射到我们的设计中，从自然的数理规律中寻找启发，理性的看待我们设计决策的过程，将设计结果、影响结果的变量、以及他们之间的规律发掘出来，就是我们的方向。而这个理性思考，感性表达的过程和我们团队的技术基因也是非常匹配的。”\n\n这句话，是笔者非常赞同的，并深深被其打动。人类一贯是用科学来定义方法，然后按方法来执行具体的行动，而按照所谓的“感觉”来行事的，一贯被认为是“不靠谱”的。当然，笔者不是指设计师做设计都是靠感觉的，他们有一套设计科学，包括配色、沟通等很多专业性的理论基础，但是，对于一个没有设计基础的工程师来讲，他的感觉很大概率是偏离方向的。\n\n同时，科学也让设计理论更为确定，更容易被人接受。就像中医，笔者相信中医是一门确定性非常强的医学，否则中国古代不可能出现那么多像贞观之治一般的鼎盛时代，但是由于中医的很多理论都没有科学基础，所以才被大众所质疑。设计也一样，“因为这个规则，所以这样做更好”肯定比“我觉得这样比较好”要更有说服力。\n\nAnt Design 3.0 的设计价值观是“**确定**”和“**自然**”，从自然中提取出“美”，然后用确定的科学规则来描述它，最终形成一套准确的设计规范，这样才更有价值。下面是个很“自然”的例子。\n\n![](https://ws1.sinaimg.cn/large/006tNbRwly1fp9axiuuvdj30k005rjrj.jpg)\n\n什么样的字号，用户看得最舒服？从图中可以看到，在人和屏幕距离一定的时候，人观看文字的视线角度（a），决定了人的舒适程度。有机构和团队做过研究，当大于 0.3 度时的阅读效率是最好的。同时我们在操作电脑时，一般来说眼睛距离电脑屏幕的平均值大概会在 50 厘米(2.45 inch)左右。这就算出来，字体应有的高度大于 12 px，再根据屏幕的 PPI，可以算出字号为 14px 时，77% 的用户最为舒服，而这个字号，就成为 Ant Design 3.0 的主字号。\n\n当你有一个主字号的时候，其他字号又怎么算出来的呢？\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fp9bivt56lj30k006q3yo.jpg)\n\n14是主字号，而 2.71828 和 5 又是怎么来的？\n\n* 2.71828 其实是就数学课中学到的自然常数，也可以称她为欧拉数，是一个超越数（无限不循环小数），和 π 称兄道弟。\n* 5 的来源更为神奇。有国外大神建议，参考音律的规则，令字阶呈现出一种自然的节奏感。最终通过实验验证出来的最合适的数值是 5，而 5 声音阶是很多古典乐遵循的规律，比如宫、商、角、徵、羽。\n\n**Amazing！** 你有没有感受到自然之美，一个追寻着科学的真理，让处女座都生不出丝毫厌恶之心的规则，对于工程师来说，是多么美妙啊。\n\n不仅仅是字号，包括行高，包括字间距，包括排版，包括颜色，都可以用很自然的规则去定义它们。同时也不仅仅是蚂蚁金服，苹果的设计一直很自然，从拟物到偏平，虽然每次升级是都会被人吐槽，但是用习惯了都会觉得很舒服。从 Google 的新 Logo，到腾信的独创字体，都很自然，同时也都很确定。\n\n给你一个支点，你能撬动地球；给你一个确定的科学规则，你是否能产出足够美的产品呢？\n\n## δ. 设计不只是美\n\n设计不只是美，美只是设计的第一步，它让用户在使用时，尤其是第一次使用时，至少可以有个好的印象。而设计的最终目的其实是为了更好地、更准确地传达信息，让用户更方便、更容易的接受信息，从而让产品能解决用户的问题。\n\n因此，设计追求的是卓越的用户体验，不仅仅是感官的体验还有使用的体验。使用的体验或许更为重要，但是它要在感觉体验的基础上完成，才能让体验相辅相成，让设计更为完整。\n\n![](https://ws2.sinaimg.cn/large/006tNbRwly1fp9w8eu48hj30go08w0t5.jpg)\n\n用户体验的核心是 **研究用户在特定产品的场景下的思维和行为模式，然后利用研究的结论，创造出适应用户、让用户感觉舒服的产品**。一个优秀的用户体验，会将产品设计成符合用户的思维行为习惯；而一个卓越的用户体验，会基于用户本身的思维行为习惯创造出符合产品特性的设计，并引导用户进行使用。\n\n因此，理解产品，才能做出好的设计；理解产品并理解好的设计，工程师才能更好地对产品进行开发。但是工程师如何去学习设计呢？上文说过，设计是一个门包含众多的理论，不可能面面俱到地去学。这时，我们应该选取比较容易但效果足够好的东西去学，那就是设计的基本原则。\n\n## ε. 无原则，不科学\n\n既然谈到了科学，那么就应该谈一谈规则、原则。所有科学，基本上都是建立在确定的规则上的，而设计也一样。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fp9wti2sdkj30go04qdgh.jpg)\n\n左侧是一个让处女座发狂的“放荡不羁”的设计，而右侧则是符合设计原则的。或许有人会觉得左侧的设计体现的是自由、奔放，体现出舞蹈的多样性，但是不管如何自由，让用户不能快速地获取信息，这就是个坏的设计。那么，到底什么是设计的原则呢？\n\n在《写给大家看的设计书》中，Robin 提出了设计的四大基本原则：**对齐**、**重复**、**对比**、**亲密性**。每一个优秀的设计作品通常都遵守这四大基本原则，互联网设计也不例外。\n\n* **亲密性**：**彼此相关的应当靠近，归组在一起。** 如果多个项目相互之间存在很近的亲密性，它们就会成为一个视觉单元，而不是多个独立的元素，这有助于信息组织，减少混乱，为读者提供清晰的结构。\n* **对齐**：**任何东西都不能在页面上随意安放。** 每个元素都应当与页面上的另一个元素有某种视觉联系。这样能建立一种清晰、精巧而且清爽的外观。\n* **重复**：**让设计中的视觉要素在整个作品中重复出现。** 可以重复颜色、形状、材质、空间关系、线宽、字体、大小和图片，等等。这样一来，技能增加条理性，还可以加强统一性。\n* **对比**：**避免页面上的元素太过相似。** 如果元素（字体、颜色、大小、线宽、形状、空间等）不相同，那就干脆让它们截然不同。\n\n这四项基本原则非常基础，就像数学中的加减乘除一般，对于一个工程师，这些很容易学会并理解。\n\n可是，作为工程师，为什么要学呢？学这么点又有什么用呢？很简单的原因，虽然学习这些很基本的东西，并不能让你真正可以进行设计，但是它能在你无设计的开发过程中，**不再用感觉来尝试修复“审美的不足”，而用科学的方法去发现并解决问题**。虽然它也许只能做巴莱特定律中 80% 里的东西，但它可以以很小的成本，规避一些很常见的错误，让工程师少走几次弯路，少改几次代码。笔者觉得这样就足够了。\n\n如果作为工程师的你，真的下定决心学习设计，那么阅读《写给大家看的设计书》是个不错的选择。\n\n## ζ. 写在最后\n\n其实设计小组的成员并不是纯粹的设计师，他们更像 **体验工程师**，把优秀的体验真正实现在项目中。最后还是那句话：\n\n作为一个前端，\u0001最该学习的两个方面是 **产品** 和 **设计** 。学习产品思维，会帮助你从用户的角度审查你开发的产品，找出用户体验不优、交互不好的地方；而学习设计，则帮助你分析不优的地方的原因，并找出解决方案。\n\n对于团队的交互设计发展，我们准备像成熟的设计团队一般，并模仿他们，构建自己的设计体系 —— **Youth Design**。我们要不断地 **拥抱未来**，不断探索未来的交互形式，吸收前沿的设计理念的同时，**对科学保持保持敬畏**，用科学的态度保持设计产品的确定性。当然，身为 Qunar 人，我们必须要 **立足青春**，让我们的设计真正被年轻人喜欢。\n\n最后，感谢董文博、张文杰、田琦、侯情缘这些 YMFE 交互设计小组的成员们给这篇文章提供了这么多很有价值的内容。\n","slug":"2018-03-10-用科学定义设计","published":1,"updated":"2018-05-29T09:50:43.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc79000rhxp4fy3lrvyk","content":"<p>在去年的博客《写给应届生的职业规划建议》里，提及了“作为一个前端，\u0001最该学习的两个方面是 <strong>产品</strong> 和 <strong>设计</strong>”的观点，而在这篇博客中，笔者就来谈一谈设计，谈一谈偏重逻辑思维的工程师怎么有效地学习和运用设计。<a id=\"more\"></a></p>\n<p>笔者所在的团队从去年系半年开始，成立设计小组，逐步开始负责团队产品的 UI/UE 设计，以求让团队产品更为 <strong>易用</strong>。</p>\n<p>前言到此为止，接下来要进入正题，而正题的第一点，就是—— <strong>互联网产品中设计的重要性</strong>。</p>\n<h2 id=\"α-设计之重\"><a href=\"#α-设计之重\" class=\"headerlink\" title=\"α. 设计之重\"></a>α. 设计之重</h2><p>从苹果的崛起，大家充分认识到设计的重要性 —— <strong>拥有优秀设计的产品，是不需要说明书的</strong>。不管从工业设计还是视觉设计上，苹果都给人一种美轮美奂的感觉。虽然如此，但是很多人仍旧认为设计是锦上添花的事情，只要产品功能完善，一切就无可阻挡。可是，虽然从巴莱特定律（80/20法则）来看，设计很有可能在产品的20%部分，但是殊不知，在大家都能完成了 80% 时，这 20% 仍会轻于鸿毛吗？</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fp91dl4w3kj31ja0ls41m.jpg\" alt=\"\"></p>\n<p>年初蚂蚁金服的 See Conf 中，蚂蚁的演讲人提出一个非常新颖的观点 —— <strong>互联网逐步会“消失”</strong> 。当然这里的“消失”并不是“灭亡”的意思，而是 <strong>互联网将和我们的世界充分融合</strong>，人们将从 <strong>Connect the Internet</strong> 到 <strong>Use the Internet</strong>，再在 <strong>Enjoy the Internet</strong>，而现在所处的阶段就是从 <strong>Use the Internet</strong> 到 <strong>Enjoy the Internet</strong> 的过程中，让用户更容易、更便捷地使用，从而享受互联网带来的一切。进一步，从用户的视角来看，<strong>人机交互</strong> 将是实现这个目标的重中之重，而 <strong>设计</strong> 则是 <strong>人机交互</strong> 的重中之重。</p>\n<p>不管观点如何，历史总可以给我们答案。当一个事物从胜到极胜的过程中，细节绝对是决定成败的最关键因素，而 <strong>设计才能将产品细节体现得更为突出</strong> 。互联网发展到现在，甚至有人说“互联网已经是传统行业”的时候，要更进一步的发展，<strong>忠于用户体验的设计绝对是必不可少的</strong>。</p>\n<h2 id=\"β-无设计的开发过程\"><a href=\"#β-无设计的开发过程\" class=\"headerlink\" title=\"β. 无设计的开发过程\"></a>β. 无设计的开发过程</h2><p>着眼现在，在很多前端需求的开发过程中，是 <strong>无设计的</strong>，主要的是以下两种情况：</p>\n<ul>\n<li>没有 UI/UE 图，工程师自己对着需求撸代码，设计随遇而安。</li>\n<li>有 UI/UE 图，但是由于工程师对设计不理解，还原得很“糟糕”。</li>\n</ul>\n<p>其中，第二种情况尤其突出。这里的“糟糕”是带双引号的，并不是指工程师还原 UI/UE 图还原得不到位，而更多的是说当工程师将 UI/UE 图还原至很高的程度以后，实际效果并不像设计图上所展现的那样美观。这里往往是因为工程师对设计不理解，从而带来一些实现上的细节差异，造成了实际效果差别巨大。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fp931493ioj31100lghdt.jpg\" alt=\"\"></p>\n<p>虽然，这两种情况，可以通过规范相关的开发、评审流程来避免，但是有些时候，不可避免因为业务、产品变更频繁、页面复杂或者人力问题，造成此类情况。因此，如果工程师懂一些设计，那么这些问题，虽然可能不会完全避免，但是也足以让影响尽可能地变小。</p>\n<p>但是，对一个理科出身、擅长逻辑思维、平时天天撸代码的、甚至毫无审美可言的工程师来说，如何 <strong>理解设计</strong>，<strong>学习设计</strong>，并在实际中 <strong>运用所学的设计知识</strong>，看起来是一项 <strong>不可能完成的任务</strong>。但是事实真的如此吗？</p>\n<h2 id=\"γ-审美-VS-科学\"><a href=\"#γ-审美-VS-科学\" class=\"headerlink\" title=\"γ. 审美 VS 科学\"></a>γ. 审美 VS 科学</h2><p>什么是 <strong>审美</strong>？欣赏、品味或领会事物及艺术品的美。每个人都有审美的，虽然有差别，但是很多时候，例如去景区旅游、去博物馆欣赏艺术品，大家对美的评判其实是很相近的。但是为什么有很多工程师，硬要说自己没有审美呢？</p>\n<p>其实，<strong>没有审美</strong> 并不是 <strong>没有评判美的能力</strong>，更多的是 <strong>他们找不到不美的原因</strong>，找不到原因，就不能修复缺陷，就不能让产品变得更美。</p>\n<p>什么是 <strong>科学</strong>？科学是一个建立在可检验的解释和对客观事物的形式、组织等进行预测的有序的知识的系统。而最基础的自然科学，则是工程师心里“最高的信仰”，就像“给我一个支点，我能撬动地球”一样，给工程师一个规则，什么事都可以做到最好。</p>\n<p>这就好办了，用科学的方法定义一下“美”，把提炼出来的“公式”给工程师，工程师就能让产品“美美哒”了。那么科学和审美碰撞的效果究竟是什么？</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fp99r5xzexj31kw0ikteu.jpg\" alt=\"\"></p>\n<p>团队内，一些人参加了年初的 See Conf，有一位小伙伴听完以后，竟然有“朝闻道，夕死可矣”的感受。原因是在《Ant Design 3.0 背后的故事》里，他看到了身为一个不是科班出身却非常喜欢设计的技术工程师的价值。</p>\n<p>“Ant Design 认为，一切看似自然的事物在背后都是有数学/物理规律可循的。映射到我们的设计中，从自然的数理规律中寻找启发，理性的看待我们设计决策的过程，将设计结果、影响结果的变量、以及他们之间的规律发掘出来，就是我们的方向。而这个理性思考，感性表达的过程和我们团队的技术基因也是非常匹配的。”</p>\n<p>这句话，是笔者非常赞同的，并深深被其打动。人类一贯是用科学来定义方法，然后按方法来执行具体的行动，而按照所谓的“感觉”来行事的，一贯被认为是“不靠谱”的。当然，笔者不是指设计师做设计都是靠感觉的，他们有一套设计科学，包括配色、沟通等很多专业性的理论基础，但是，对于一个没有设计基础的工程师来讲，他的感觉很大概率是偏离方向的。</p>\n<p>同时，科学也让设计理论更为确定，更容易被人接受。就像中医，笔者相信中医是一门确定性非常强的医学，否则中国古代不可能出现那么多像贞观之治一般的鼎盛时代，但是由于中医的很多理论都没有科学基础，所以才被大众所质疑。设计也一样，“因为这个规则，所以这样做更好”肯定比“我觉得这样比较好”要更有说服力。</p>\n<p>Ant Design 3.0 的设计价值观是“<strong>确定</strong>”和“<strong>自然</strong>”，从自然中提取出“美”，然后用确定的科学规则来描述它，最终形成一套准确的设计规范，这样才更有价值。下面是个很“自然”的例子。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fp9axiuuvdj30k005rjrj.jpg\" alt=\"\"></p>\n<p>什么样的字号，用户看得最舒服？从图中可以看到，在人和屏幕距离一定的时候，人观看文字的视线角度（a），决定了人的舒适程度。有机构和团队做过研究，当大于 0.3 度时的阅读效率是最好的。同时我们在操作电脑时，一般来说眼睛距离电脑屏幕的平均值大概会在 50 厘米(2.45 inch)左右。这就算出来，字体应有的高度大于 12 px，再根据屏幕的 PPI，可以算出字号为 14px 时，77% 的用户最为舒服，而这个字号，就成为 Ant Design 3.0 的主字号。</p>\n<p>当你有一个主字号的时候，其他字号又怎么算出来的呢？</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fp9bivt56lj30k006q3yo.jpg\" alt=\"\"></p>\n<p>14是主字号，而 2.71828 和 5 又是怎么来的？</p>\n<ul>\n<li>2.71828 其实是就数学课中学到的自然常数，也可以称她为欧拉数，是一个超越数（无限不循环小数），和 π 称兄道弟。</li>\n<li>5 的来源更为神奇。有国外大神建议，参考音律的规则，令字阶呈现出一种自然的节奏感。最终通过实验验证出来的最合适的数值是 5，而 5 声音阶是很多古典乐遵循的规律，比如宫、商、角、徵、羽。</li>\n</ul>\n<p><strong>Amazing！</strong> 你有没有感受到自然之美，一个追寻着科学的真理，让处女座都生不出丝毫厌恶之心的规则，对于工程师来说，是多么美妙啊。</p>\n<p>不仅仅是字号，包括行高，包括字间距，包括排版，包括颜色，都可以用很自然的规则去定义它们。同时也不仅仅是蚂蚁金服，苹果的设计一直很自然，从拟物到偏平，虽然每次升级是都会被人吐槽，但是用习惯了都会觉得很舒服。从 Google 的新 Logo，到腾信的独创字体，都很自然，同时也都很确定。</p>\n<p>给你一个支点，你能撬动地球；给你一个确定的科学规则，你是否能产出足够美的产品呢？</p>\n<h2 id=\"δ-设计不只是美\"><a href=\"#δ-设计不只是美\" class=\"headerlink\" title=\"δ. 设计不只是美\"></a>δ. 设计不只是美</h2><p>设计不只是美，美只是设计的第一步，它让用户在使用时，尤其是第一次使用时，至少可以有个好的印象。而设计的最终目的其实是为了更好地、更准确地传达信息，让用户更方便、更容易的接受信息，从而让产品能解决用户的问题。</p>\n<p>因此，设计追求的是卓越的用户体验，不仅仅是感官的体验还有使用的体验。使用的体验或许更为重要，但是它要在感觉体验的基础上完成，才能让体验相辅相成，让设计更为完整。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fp9w8eu48hj30go08w0t5.jpg\" alt=\"\"></p>\n<p>用户体验的核心是 <strong>研究用户在特定产品的场景下的思维和行为模式，然后利用研究的结论，创造出适应用户、让用户感觉舒服的产品</strong>。一个优秀的用户体验，会将产品设计成符合用户的思维行为习惯；而一个卓越的用户体验，会基于用户本身的思维行为习惯创造出符合产品特性的设计，并引导用户进行使用。</p>\n<p>因此，理解产品，才能做出好的设计；理解产品并理解好的设计，工程师才能更好地对产品进行开发。但是工程师如何去学习设计呢？上文说过，设计是一个门包含众多的理论，不可能面面俱到地去学。这时，我们应该选取比较容易但效果足够好的东西去学，那就是设计的基本原则。</p>\n<h2 id=\"ε-无原则，不科学\"><a href=\"#ε-无原则，不科学\" class=\"headerlink\" title=\"ε. 无原则，不科学\"></a>ε. 无原则，不科学</h2><p>既然谈到了科学，那么就应该谈一谈规则、原则。所有科学，基本上都是建立在确定的规则上的，而设计也一样。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fp9wti2sdkj30go04qdgh.jpg\" alt=\"\"></p>\n<p>左侧是一个让处女座发狂的“放荡不羁”的设计，而右侧则是符合设计原则的。或许有人会觉得左侧的设计体现的是自由、奔放，体现出舞蹈的多样性，但是不管如何自由，让用户不能快速地获取信息，这就是个坏的设计。那么，到底什么是设计的原则呢？</p>\n<p>在《写给大家看的设计书》中，Robin 提出了设计的四大基本原则：<strong>对齐</strong>、<strong>重复</strong>、<strong>对比</strong>、<strong>亲密性</strong>。每一个优秀的设计作品通常都遵守这四大基本原则，互联网设计也不例外。</p>\n<ul>\n<li><strong>亲密性</strong>：<strong>彼此相关的应当靠近，归组在一起。</strong> 如果多个项目相互之间存在很近的亲密性，它们就会成为一个视觉单元，而不是多个独立的元素，这有助于信息组织，减少混乱，为读者提供清晰的结构。</li>\n<li><strong>对齐</strong>：<strong>任何东西都不能在页面上随意安放。</strong> 每个元素都应当与页面上的另一个元素有某种视觉联系。这样能建立一种清晰、精巧而且清爽的外观。</li>\n<li><strong>重复</strong>：<strong>让设计中的视觉要素在整个作品中重复出现。</strong> 可以重复颜色、形状、材质、空间关系、线宽、字体、大小和图片，等等。这样一来，技能增加条理性，还可以加强统一性。</li>\n<li><strong>对比</strong>：<strong>避免页面上的元素太过相似。</strong> 如果元素（字体、颜色、大小、线宽、形状、空间等）不相同，那就干脆让它们截然不同。</li>\n</ul>\n<p>这四项基本原则非常基础，就像数学中的加减乘除一般，对于一个工程师，这些很容易学会并理解。</p>\n<p>可是，作为工程师，为什么要学呢？学这么点又有什么用呢？很简单的原因，虽然学习这些很基本的东西，并不能让你真正可以进行设计，但是它能在你无设计的开发过程中，<strong>不再用感觉来尝试修复“审美的不足”，而用科学的方法去发现并解决问题</strong>。虽然它也许只能做巴莱特定律中 80% 里的东西，但它可以以很小的成本，规避一些很常见的错误，让工程师少走几次弯路，少改几次代码。笔者觉得这样就足够了。</p>\n<p>如果作为工程师的你，真的下定决心学习设计，那么阅读《写给大家看的设计书》是个不错的选择。</p>\n<h2 id=\"ζ-写在最后\"><a href=\"#ζ-写在最后\" class=\"headerlink\" title=\"ζ. 写在最后\"></a>ζ. 写在最后</h2><p>其实设计小组的成员并不是纯粹的设计师，他们更像 <strong>体验工程师</strong>，把优秀的体验真正实现在项目中。最后还是那句话：</p>\n<p>作为一个前端，\u0001最该学习的两个方面是 <strong>产品</strong> 和 <strong>设计</strong> 。学习产品思维，会帮助你从用户的角度审查你开发的产品，找出用户体验不优、交互不好的地方；而学习设计，则帮助你分析不优的地方的原因，并找出解决方案。</p>\n<p>对于团队的交互设计发展，我们准备像成熟的设计团队一般，并模仿他们，构建自己的设计体系 —— <strong>Youth Design</strong>。我们要不断地 <strong>拥抱未来</strong>，不断探索未来的交互形式，吸收前沿的设计理念的同时，<strong>对科学保持保持敬畏</strong>，用科学的态度保持设计产品的确定性。当然，身为 Qunar 人，我们必须要 <strong>立足青春</strong>，让我们的设计真正被年轻人喜欢。</p>\n<p>最后，感谢董文博、张文杰、田琦、侯情缘这些 YMFE 交互设计小组的成员们给这篇文章提供了这么多很有价值的内容。</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws1.sinaimg.cn/large/006tKfTcly1frsbzrqjj3j315i0de4qp.jpg","excerpt":"<p>在去年的博客《写给应届生的职业规划建议》里，提及了“作为一个前端，\u0001最该学习的两个方面是 <strong>产品</strong> 和 <strong>设计</strong>”的观点，而在这篇博客中，笔者就来谈一谈设计，谈一谈偏重逻辑思维的工程师怎么有效地学习和运用设计。","more":"</p>\n<p>笔者所在的团队从去年系半年开始，成立设计小组，逐步开始负责团队产品的 UI/UE 设计，以求让团队产品更为 <strong>易用</strong>。</p>\n<p>前言到此为止，接下来要进入正题，而正题的第一点，就是—— <strong>互联网产品中设计的重要性</strong>。</p>\n<h2 id=\"α-设计之重\"><a href=\"#α-设计之重\" class=\"headerlink\" title=\"α. 设计之重\"></a>α. 设计之重</h2><p>从苹果的崛起，大家充分认识到设计的重要性 —— <strong>拥有优秀设计的产品，是不需要说明书的</strong>。不管从工业设计还是视觉设计上，苹果都给人一种美轮美奂的感觉。虽然如此，但是很多人仍旧认为设计是锦上添花的事情，只要产品功能完善，一切就无可阻挡。可是，虽然从巴莱特定律（80/20法则）来看，设计很有可能在产品的20%部分，但是殊不知，在大家都能完成了 80% 时，这 20% 仍会轻于鸿毛吗？</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fp91dl4w3kj31ja0ls41m.jpg\" alt=\"\"></p>\n<p>年初蚂蚁金服的 See Conf 中，蚂蚁的演讲人提出一个非常新颖的观点 —— <strong>互联网逐步会“消失”</strong> 。当然这里的“消失”并不是“灭亡”的意思，而是 <strong>互联网将和我们的世界充分融合</strong>，人们将从 <strong>Connect the Internet</strong> 到 <strong>Use the Internet</strong>，再在 <strong>Enjoy the Internet</strong>，而现在所处的阶段就是从 <strong>Use the Internet</strong> 到 <strong>Enjoy the Internet</strong> 的过程中，让用户更容易、更便捷地使用，从而享受互联网带来的一切。进一步，从用户的视角来看，<strong>人机交互</strong> 将是实现这个目标的重中之重，而 <strong>设计</strong> 则是 <strong>人机交互</strong> 的重中之重。</p>\n<p>不管观点如何，历史总可以给我们答案。当一个事物从胜到极胜的过程中，细节绝对是决定成败的最关键因素，而 <strong>设计才能将产品细节体现得更为突出</strong> 。互联网发展到现在，甚至有人说“互联网已经是传统行业”的时候，要更进一步的发展，<strong>忠于用户体验的设计绝对是必不可少的</strong>。</p>\n<h2 id=\"β-无设计的开发过程\"><a href=\"#β-无设计的开发过程\" class=\"headerlink\" title=\"β. 无设计的开发过程\"></a>β. 无设计的开发过程</h2><p>着眼现在，在很多前端需求的开发过程中，是 <strong>无设计的</strong>，主要的是以下两种情况：</p>\n<ul>\n<li>没有 UI/UE 图，工程师自己对着需求撸代码，设计随遇而安。</li>\n<li>有 UI/UE 图，但是由于工程师对设计不理解，还原得很“糟糕”。</li>\n</ul>\n<p>其中，第二种情况尤其突出。这里的“糟糕”是带双引号的，并不是指工程师还原 UI/UE 图还原得不到位，而更多的是说当工程师将 UI/UE 图还原至很高的程度以后，实际效果并不像设计图上所展现的那样美观。这里往往是因为工程师对设计不理解，从而带来一些实现上的细节差异，造成了实际效果差别巨大。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fp931493ioj31100lghdt.jpg\" alt=\"\"></p>\n<p>虽然，这两种情况，可以通过规范相关的开发、评审流程来避免，但是有些时候，不可避免因为业务、产品变更频繁、页面复杂或者人力问题，造成此类情况。因此，如果工程师懂一些设计，那么这些问题，虽然可能不会完全避免，但是也足以让影响尽可能地变小。</p>\n<p>但是，对一个理科出身、擅长逻辑思维、平时天天撸代码的、甚至毫无审美可言的工程师来说，如何 <strong>理解设计</strong>，<strong>学习设计</strong>，并在实际中 <strong>运用所学的设计知识</strong>，看起来是一项 <strong>不可能完成的任务</strong>。但是事实真的如此吗？</p>\n<h2 id=\"γ-审美-VS-科学\"><a href=\"#γ-审美-VS-科学\" class=\"headerlink\" title=\"γ. 审美 VS 科学\"></a>γ. 审美 VS 科学</h2><p>什么是 <strong>审美</strong>？欣赏、品味或领会事物及艺术品的美。每个人都有审美的，虽然有差别，但是很多时候，例如去景区旅游、去博物馆欣赏艺术品，大家对美的评判其实是很相近的。但是为什么有很多工程师，硬要说自己没有审美呢？</p>\n<p>其实，<strong>没有审美</strong> 并不是 <strong>没有评判美的能力</strong>，更多的是 <strong>他们找不到不美的原因</strong>，找不到原因，就不能修复缺陷，就不能让产品变得更美。</p>\n<p>什么是 <strong>科学</strong>？科学是一个建立在可检验的解释和对客观事物的形式、组织等进行预测的有序的知识的系统。而最基础的自然科学，则是工程师心里“最高的信仰”，就像“给我一个支点，我能撬动地球”一样，给工程师一个规则，什么事都可以做到最好。</p>\n<p>这就好办了，用科学的方法定义一下“美”，把提炼出来的“公式”给工程师，工程师就能让产品“美美哒”了。那么科学和审美碰撞的效果究竟是什么？</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fp99r5xzexj31kw0ikteu.jpg\" alt=\"\"></p>\n<p>团队内，一些人参加了年初的 See Conf，有一位小伙伴听完以后，竟然有“朝闻道，夕死可矣”的感受。原因是在《Ant Design 3.0 背后的故事》里，他看到了身为一个不是科班出身却非常喜欢设计的技术工程师的价值。</p>\n<p>“Ant Design 认为，一切看似自然的事物在背后都是有数学/物理规律可循的。映射到我们的设计中，从自然的数理规律中寻找启发，理性的看待我们设计决策的过程，将设计结果、影响结果的变量、以及他们之间的规律发掘出来，就是我们的方向。而这个理性思考，感性表达的过程和我们团队的技术基因也是非常匹配的。”</p>\n<p>这句话，是笔者非常赞同的，并深深被其打动。人类一贯是用科学来定义方法，然后按方法来执行具体的行动，而按照所谓的“感觉”来行事的，一贯被认为是“不靠谱”的。当然，笔者不是指设计师做设计都是靠感觉的，他们有一套设计科学，包括配色、沟通等很多专业性的理论基础，但是，对于一个没有设计基础的工程师来讲，他的感觉很大概率是偏离方向的。</p>\n<p>同时，科学也让设计理论更为确定，更容易被人接受。就像中医，笔者相信中医是一门确定性非常强的医学，否则中国古代不可能出现那么多像贞观之治一般的鼎盛时代，但是由于中医的很多理论都没有科学基础，所以才被大众所质疑。设计也一样，“因为这个规则，所以这样做更好”肯定比“我觉得这样比较好”要更有说服力。</p>\n<p>Ant Design 3.0 的设计价值观是“<strong>确定</strong>”和“<strong>自然</strong>”，从自然中提取出“美”，然后用确定的科学规则来描述它，最终形成一套准确的设计规范，这样才更有价值。下面是个很“自然”的例子。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/006tNbRwly1fp9axiuuvdj30k005rjrj.jpg\" alt=\"\"></p>\n<p>什么样的字号，用户看得最舒服？从图中可以看到，在人和屏幕距离一定的时候，人观看文字的视线角度（a），决定了人的舒适程度。有机构和团队做过研究，当大于 0.3 度时的阅读效率是最好的。同时我们在操作电脑时，一般来说眼睛距离电脑屏幕的平均值大概会在 50 厘米(2.45 inch)左右。这就算出来，字体应有的高度大于 12 px，再根据屏幕的 PPI，可以算出字号为 14px 时，77% 的用户最为舒服，而这个字号，就成为 Ant Design 3.0 的主字号。</p>\n<p>当你有一个主字号的时候，其他字号又怎么算出来的呢？</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fp9bivt56lj30k006q3yo.jpg\" alt=\"\"></p>\n<p>14是主字号，而 2.71828 和 5 又是怎么来的？</p>\n<ul>\n<li>2.71828 其实是就数学课中学到的自然常数，也可以称她为欧拉数，是一个超越数（无限不循环小数），和 π 称兄道弟。</li>\n<li>5 的来源更为神奇。有国外大神建议，参考音律的规则，令字阶呈现出一种自然的节奏感。最终通过实验验证出来的最合适的数值是 5，而 5 声音阶是很多古典乐遵循的规律，比如宫、商、角、徵、羽。</li>\n</ul>\n<p><strong>Amazing！</strong> 你有没有感受到自然之美，一个追寻着科学的真理，让处女座都生不出丝毫厌恶之心的规则，对于工程师来说，是多么美妙啊。</p>\n<p>不仅仅是字号，包括行高，包括字间距，包括排版，包括颜色，都可以用很自然的规则去定义它们。同时也不仅仅是蚂蚁金服，苹果的设计一直很自然，从拟物到偏平，虽然每次升级是都会被人吐槽，但是用习惯了都会觉得很舒服。从 Google 的新 Logo，到腾信的独创字体，都很自然，同时也都很确定。</p>\n<p>给你一个支点，你能撬动地球；给你一个确定的科学规则，你是否能产出足够美的产品呢？</p>\n<h2 id=\"δ-设计不只是美\"><a href=\"#δ-设计不只是美\" class=\"headerlink\" title=\"δ. 设计不只是美\"></a>δ. 设计不只是美</h2><p>设计不只是美，美只是设计的第一步，它让用户在使用时，尤其是第一次使用时，至少可以有个好的印象。而设计的最终目的其实是为了更好地、更准确地传达信息，让用户更方便、更容易的接受信息，从而让产品能解决用户的问题。</p>\n<p>因此，设计追求的是卓越的用户体验，不仅仅是感官的体验还有使用的体验。使用的体验或许更为重要，但是它要在感觉体验的基础上完成，才能让体验相辅相成，让设计更为完整。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fp9w8eu48hj30go08w0t5.jpg\" alt=\"\"></p>\n<p>用户体验的核心是 <strong>研究用户在特定产品的场景下的思维和行为模式，然后利用研究的结论，创造出适应用户、让用户感觉舒服的产品</strong>。一个优秀的用户体验，会将产品设计成符合用户的思维行为习惯；而一个卓越的用户体验，会基于用户本身的思维行为习惯创造出符合产品特性的设计，并引导用户进行使用。</p>\n<p>因此，理解产品，才能做出好的设计；理解产品并理解好的设计，工程师才能更好地对产品进行开发。但是工程师如何去学习设计呢？上文说过，设计是一个门包含众多的理论，不可能面面俱到地去学。这时，我们应该选取比较容易但效果足够好的东西去学，那就是设计的基本原则。</p>\n<h2 id=\"ε-无原则，不科学\"><a href=\"#ε-无原则，不科学\" class=\"headerlink\" title=\"ε. 无原则，不科学\"></a>ε. 无原则，不科学</h2><p>既然谈到了科学，那么就应该谈一谈规则、原则。所有科学，基本上都是建立在确定的规则上的，而设计也一样。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fp9wti2sdkj30go04qdgh.jpg\" alt=\"\"></p>\n<p>左侧是一个让处女座发狂的“放荡不羁”的设计，而右侧则是符合设计原则的。或许有人会觉得左侧的设计体现的是自由、奔放，体现出舞蹈的多样性，但是不管如何自由，让用户不能快速地获取信息，这就是个坏的设计。那么，到底什么是设计的原则呢？</p>\n<p>在《写给大家看的设计书》中，Robin 提出了设计的四大基本原则：<strong>对齐</strong>、<strong>重复</strong>、<strong>对比</strong>、<strong>亲密性</strong>。每一个优秀的设计作品通常都遵守这四大基本原则，互联网设计也不例外。</p>\n<ul>\n<li><strong>亲密性</strong>：<strong>彼此相关的应当靠近，归组在一起。</strong> 如果多个项目相互之间存在很近的亲密性，它们就会成为一个视觉单元，而不是多个独立的元素，这有助于信息组织，减少混乱，为读者提供清晰的结构。</li>\n<li><strong>对齐</strong>：<strong>任何东西都不能在页面上随意安放。</strong> 每个元素都应当与页面上的另一个元素有某种视觉联系。这样能建立一种清晰、精巧而且清爽的外观。</li>\n<li><strong>重复</strong>：<strong>让设计中的视觉要素在整个作品中重复出现。</strong> 可以重复颜色、形状、材质、空间关系、线宽、字体、大小和图片，等等。这样一来，技能增加条理性，还可以加强统一性。</li>\n<li><strong>对比</strong>：<strong>避免页面上的元素太过相似。</strong> 如果元素（字体、颜色、大小、线宽、形状、空间等）不相同，那就干脆让它们截然不同。</li>\n</ul>\n<p>这四项基本原则非常基础，就像数学中的加减乘除一般，对于一个工程师，这些很容易学会并理解。</p>\n<p>可是，作为工程师，为什么要学呢？学这么点又有什么用呢？很简单的原因，虽然学习这些很基本的东西，并不能让你真正可以进行设计，但是它能在你无设计的开发过程中，<strong>不再用感觉来尝试修复“审美的不足”，而用科学的方法去发现并解决问题</strong>。虽然它也许只能做巴莱特定律中 80% 里的东西，但它可以以很小的成本，规避一些很常见的错误，让工程师少走几次弯路，少改几次代码。笔者觉得这样就足够了。</p>\n<p>如果作为工程师的你，真的下定决心学习设计，那么阅读《写给大家看的设计书》是个不错的选择。</p>\n<h2 id=\"ζ-写在最后\"><a href=\"#ζ-写在最后\" class=\"headerlink\" title=\"ζ. 写在最后\"></a>ζ. 写在最后</h2><p>其实设计小组的成员并不是纯粹的设计师，他们更像 <strong>体验工程师</strong>，把优秀的体验真正实现在项目中。最后还是那句话：</p>\n<p>作为一个前端，\u0001最该学习的两个方面是 <strong>产品</strong> 和 <strong>设计</strong> 。学习产品思维，会帮助你从用户的角度审查你开发的产品，找出用户体验不优、交互不好的地方；而学习设计，则帮助你分析不优的地方的原因，并找出解决方案。</p>\n<p>对于团队的交互设计发展，我们准备像成熟的设计团队一般，并模仿他们，构建自己的设计体系 —— <strong>Youth Design</strong>。我们要不断地 <strong>拥抱未来</strong>，不断探索未来的交互形式，吸收前沿的设计理念的同时，<strong>对科学保持保持敬畏</strong>，用科学的态度保持设计产品的确定性。当然，身为 Qunar 人，我们必须要 <strong>立足青春</strong>，让我们的设计真正被年轻人喜欢。</p>\n<p>最后，感谢董文博、张文杰、田琦、侯情缘这些 YMFE 交互设计小组的成员们给这篇文章提供了这么多很有价值的内容。</p>"},{"title":"再谈移动端动态化方案","date":"2018-08-05T10:00:00.000Z","thumbnailImage":"https://ws4.sinaimg.cn/large/006tKfTcly1ftwl4uvaduj30yi1pc4qr.jpg","thumbnailImagePosition":"right","_content":"\n近几年，移动互联网发展迅猛，几乎每天一变，各种新技术、新思想犹如雨后春笋般，层出不穷。虽然移动端动态化方案已经发展了很多年，但是每天都有新的变化，所以笔者在这里重新和大家聊一下移动端动态化方案。<!-- more -->\n\n## 前言\n\n在移动开发领域，动态化方案一直争议不断，而最近 Airbnb 和 Udacity 弃用 React Native 也把这个问题推向了舆论中心。不论是独立的移动开发者，还是大的互联网软件公司，都对这类方案褒贬不一；褒的是快速迭代和跨平台，而贬的是性能效率和抹平平台差异过程中的各种坑。动态化方案究竟是一个能让开发者托付终身的大道，还是路见不平一声吼的临时方案。笔者作为一个深耕移动开发数年的老兵，将从技术、架构、成本等各个角度，对移动端动态化方案进行深入阐述。\n\n![](https://ws1.sinaimg.cn/large/0069RVTdly1fu112vxq78j30u00e4dgs.jpg)\n\n## 移动端动态化的由来\n\n“动态化”并不是最近几年才产生的名词，而是从c互联网诞生的初期，这个词就已经出现了。大家所认知的早期互联网，其实就是各种各类的“动态网站”，内容数据和页面外观都不是固定的，都是随着服务器端的更新而更新的，让用户可以很及时地看到最新的内容。因此，动态化可以说是互联网的标志，是互联网最核心的特性之一。\n\n而移动互联网的普及，移动端被各类原生应用所占据，而这些应用更近似于 Software，依托于应用市场进行更新，只有其中的数据是实时的。这样，每次产品的更新，必须依赖用户的主动更新，从而造成了一定的用户成本，不利于产品的快速迭代，降低应用的试错能力。因此，移动端动态化方案逐渐走进大家的视野，并被大家所关注。\n\n从一开始基于 WebView 的 Hybrid 方案 PhoneGap、Titanium，到现在与原生相结合的 React Native 、Weex，甚至 Flutter，都被或多或少地使用到不同的移动应用中。以“去哪儿旅行” App 为例，机票业务 90% 以上的项目都已经使用 React Native 构建，酒店主流程业务也都使用 React Native 构建，另外还有过百项目使用 Hybrid 方案。据不完全统计，平均每天至少有 25 个使用动态化方案的项目进行发布，相对于用户主动更新的频率，这样的业务迭代速度，才是互联网公司所需要的。\n\n原生开发能不能动态化？准确的说是能的，而且 Android 平台各公司都有很完善的动态化方案，甚至 Google 今年还提供了 Android App Bundles 让开发者们可以更好地支持动态化。而反观 iOS，由于 Apple 官方担忧动态化的风险，因此并不太支持动态化（去年还封杀了 JSPatch 等一类动态修复方案），因此比较通用的原生动态化方案几乎没有，只有各大厂自己实现的一些动态化框架。\n\n*Android App Bundles 图示 :*\n\n![Android App Bundles](https://ws4.sinaimg.cn/large/0069RVTdly1fu12eto17tg30qo0f04qp.gif)\n\nApple 这样的做法，其实也有情可原。试想，你从应用市场下载了一个“抖音”，然后过几天打开，发现 App 内的内容变成了“拼多多”，还变不回去，是有多恶心。Apple 如此严格要求 App，也是 Apple Store 比各类 Android 市场上的 App 质量普遍要高的原因之一。 \n\n## 从 Web 开始\n\n既然动态化起源于 Web，那么移动端为什么不直接使用 Web 进行构建呢？而且在当前设备性能有大幅提升、浏览器内核得到有效优化的情况下。\n\n首先，历史原因。移动互联网兴起之初，移动设备上的浏览器内核版本和性能都比较低，移动网络速度较慢，再加上国内 Android 厂商为了所谓的“优化”，各种阉割、改造浏览器内核，造成纯的 Web 页面，不管从交互流畅度、功能完善度，还是从兼容各个平台所需的人力成本来讲，Web 都不是最好的选择。因此，绝大多数互联网产品都以 App 的形式存在，而用户通过几年的适应，已经习惯了 App 的“先下载再使用”的方式，对于纯 Web 的“即开即用”的形式并不是十分感冒。\n\n其次，虽然 Google 为了推动 Web 的发展，提出了两个非常卓越的思路 —— AMP 和 PWA，但是由于其他厂商的跟进较慢（例如  Apple），以及浏览器（包括内核）的版本迭代存在一定的长尾效应，短时间内形成良好的 Web App 的使用环境是比较困难的。\n\n![](https://ws3.sinaimg.cn/large/0069RVTdly1fu116g36tcj30hx0b3q3u.jpg)\n\n最后是涉及安全性较高的功能，例如支付。通过 Web API 直接调用移动设备的支付功能，或者调用指纹或人脸验证，都是行不通的。虽然较为安全的 Https 协议已经被广泛使用，调用验证和支付的 API 已经写入或即将写入 Web 标准，但是不管是手机厂商还是系统厂商，都没有行动起来，去为 Web 提供相应的功能 API。不论是安全上真的有缺陷，还是厂商认为 Web 不可控，但对于一个商业闭环，支付是不可缺少的一部分，这也制约了 Web App 的发展。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu117ayo5uj30wi09qjsd.jpg)\n\n## 到混合之路\n\n既然 Web App 行不通，那就尝试和 Native 进行结合。由于设备的繁多和定制化的差异，基于设备操作系统原生开发的成本逐渐升高，最明显的示例就是同样的功能逻辑在不同的设备上要用不同的编程语言、不同的代码结构去构建，学习成本、开发成本和维护成本大幅增加，因此引入一种开发更高效、成本更低的解决方案势在必行，而这个方案就是 Hybrid 混合开发，它让 Web 的跨平台特性被利用得淋淋尽致。\n\nHybrid 这个名词越来越多地出现在人们的视野中是源于混合动力汽车（Hybrid Electrical Vehicle，简称 HEV ），由汽油和电池一起提供动力，结合了油车续航长、补充快和电车清洁、低耗能的两方面优势，达到了发动机和电动机的最佳匹配。在互联网技术中的，Hybrid 方案也具有同样的特性——结合两种混合技术的优势，例如 Web 技术的跨平台、快速部署与原生 Native 的功能、性能相结合。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu118zeq4cj30gq05q74x.jpg)\n\n大多时候，圈内人谈论到 Hybrid 时，一般是指移动端内嵌 WebView 的开发方案。实则不然，广泛地讲，包括 React-Native 方案、各厂商的小程序方案都属于移动端 Hybrid 解决方案的范畴；而 NM.js、Electron 等则属于 PC 端 Hybrid 解决方案。对于智能设备，大多基于 Android 系统，因此，智能设备上使用的 Hybrid 方案与移动端基本一致。\n\n具体来看，移动端混合开发中的 Hybrid 方案，主要有三种形式：\n\n- 基于 Web 的解决方案，例如：Cordova、微信浏览器、各公司的 Hybrid 方案。\n- 非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案，例如：React-Native, Weex，Flutter。\n- 基于 Web 且 UI 层与逻辑层分离的解决方案，此类型的代表是微信小程序，将UI展现逻辑和业务逻辑分离到多个 JavaScript Context 里，提高运行效率，效果很好。\n\n其中，第一种方案，以 Web 为基础，实现成本最低，只是 Native 提供 WebView 运行 Web 页面，并提供相应的 API，平台兼容性问题，大部分交给 Web 来处理（Native 基本上只需要处理 API 层的兼容）；而且业务的开发方式保持 Web 的形式，对于前端是友好的。缺点也显而易见，Web 的性能受到浏览器内核的影响。\n\n![](https://ws1.sinaimg.cn/large/0069RVTdly1fu11egla86j30fd08j74r.jpg)\n\n第二种方案中最具代表的是 Facebook 的 React-Native，也在前言中提到过，推崇者无数的同时，粉转黑的也大有人在。它几乎将平台兼容性的问题全部交给了 Native，业务的 JavaScript 中是纯粹的业务逻辑。其优势，主要在性能，通过原生组件与 React 组件化设计相配合的方式提供高性能的 UI，但 JavaScript Context 和 Native 通信成了这套方案的瓶颈。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu11bodplej30m8066q3j.jpg)\n\n通信过慢？不。单次通信并不慢，在某些频繁通信场景中，通信阻塞的问题会显现。例如数据量较多的列表，业务需要对现有的列表进行扩展，这时需要 JavaScript 响应各类滚动事件，这样通信量会大幅增加，造成通信阻塞。这里，有人会说，为啥 Native 组件不定制好？“魔高一尺道高一丈”，预先的设计肯定不能满足产品的所有需求。当然，Native 可以满足新的需求，这就需要依赖 App 的升级，需求不能在老版本 App 中实现。另外，React 的虚拟 Dom 机制，不能准确提供给 Native 元素复用的信息，也是影响性能的一个方面。\n\n第三种，基于 Web 且 UI 层与逻辑层分离的解决方案。微信小程序的性能是有目共睹的，但是微信小程序中由于各方面限制，复杂应用并不多，当一个应用足够庞大，性能又会如何呢（当然这种应用可能不会出现）。基于这种思路，我们也实现了一个类似架构的方案 YIS，基于 JavaScript Context 和 Web UI 的方案，业务逻辑都跑在 JavaScript Context 中，UI 在单独的 WebView 上绘制。经过验证，性能相当不错。相比于上一种，由于 UI 是 Web 实现的，故这些 UI 组件是可以动态更新的，可以更好地支持业务需求。不过，性能瓶颈仍是问题，毕竟 Web UI 的性能天花板要比 Native 低。有人说，随着移动设备性能的提升，浏览器内核的完善，Web UI 的性能问题会被解决。但是，笔者觉得，Web UI 性能的提升同时，Native UI 的性能会变得更好，可能会出现更“炫酷”的交互，例如科幻电影里，从手机中投射出 3D 视图，到那时，可能又会出现其他的性能问题。\n\n![](https://ws4.sinaimg.cn/large/0069RVTdly1fu11o4xmasj30go09ddht.jpg)\n\n所以，使用 Web UI 还是 Native UI 的争论，暂时停不下来。其实，没有最好的方案，根据自身的业务场景、公司情况，选择最适应的方案才是正道。\n\n## 终以 JSCore 为核\n\n不论是使用 Web UI 还是使用 Native UI，由于 JavaScript 是单线程，业务代码会与 UI 渲染同时占用线程资源，因此业务逻辑与 UI 分离，在现在看来是必须要做的，这样会让业务尽量动态化的同时，性能得到很大提升。\n\n运行业务逻辑的 JavaScript Context ，通常被统称成为 JSCore。通俗来讲，JSCore 就是一个即没有 DOM 也没有 BOM 的浏览器内核，和 WebWorker 近似，只能运行纯的 JavaScript 逻辑，并通过 Native提供的 API，进行网络请求、本地存储等操作。\n\n![](https://ws1.sinaimg.cn/large/0069RVTdly1fu11woinsmj30jg08c77n.jpg)\n\n当然，在实际的设计中，可以用一些例如“空间换时间”的方法，来优化 JSCore 的性能，例如预初始化 JSCore、预加载框架的 JavaScript 代码等，占用一些固有的内存，来保证业务的启动速度。\n\nJSCore 的模式，其实更像是 MVC、MVVM 盛行带来的红利。MVC、MVVM 的核心思想都是让开发者更关注业务本身，更关心业务逻辑，而剥离出来的 View 层，就可以通过组件化的形式，映射到其他的 Context 中，从而只保留非 UI 渲染逻辑在 JSCore 中，提高性能。\n\n## Web 不死，PWA 向前\n\nWeb 已死？No！同时，App 也不是未来。\n\n在移动端上，Web 还用很多瓶颈有待解决，但作为最灵活、跨平台性最好的技术，它缺是不可能被磨灭的。各种就 App 的动态化技术，都支持了兼容 Web 的方式（例如 rn-web），但是，其带来的开发和适配成本也是不小的。至少，一个短时的活动项目，用 Web 构建，可以在各个平台的浏览器中，各个 App 的 WebView 中运行，其成本远小于其他方案。再者，Web 对 SEO 的友好，也是 App 无法比拟的，这也是 Web 的一大优势。\n\n来自 App 的压力，推动着 Web 技术的发展，其中，Google 推出的 PWA 是最有颠覆性的。随着 Apple 新 Safari 和微软 Win10 对 PWA 的着力支持，PWA 的前景越来越明朗。在桌面有入口、支持控制资源缓存、支持消息推送、具备离线能力，当 PWA 应用可以完成 App 的一切，Web 或者又要重新站上顶峰。（真心推荐微博的 PWA 版本，比客户端好用多了）\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu11407dyij30fe066dg5.jpg)\n\n## 前路慢慢\n\n动态化方案，虽然由于种种原因成为了现在这个阶段中比较流行的方案，但是，动态化方案仍有很多没有解决的弊端，待我们去解决。而且，在我们解决的过程中，也会不断涌现其他各种方案。\n\n总之，动态化方案的出现，不是为了替代谁，更多是为了给用户更好的体验，同时让业务可以更快的迭代，并在不断的尝试中，给用户带来更好的产品。\n\n“路漫漫其修远兮，吾将上下而求索”。\n","source":"_posts/2018-08-05-再谈移动端动态化方案.md","raw":"title: 再谈移动端动态化方案\ndate: 2018-08-05 18:00:00\ncategory: 大前端技术\ntags: [动态化, Hybrid]\nthumbnailImage: https://ws4.sinaimg.cn/large/006tKfTcly1ftwl4uvaduj30yi1pc4qr.jpg\nthumbnailImagePosition: right\n---\n\n近几年，移动互联网发展迅猛，几乎每天一变，各种新技术、新思想犹如雨后春笋般，层出不穷。虽然移动端动态化方案已经发展了很多年，但是每天都有新的变化，所以笔者在这里重新和大家聊一下移动端动态化方案。<!-- more -->\n\n## 前言\n\n在移动开发领域，动态化方案一直争议不断，而最近 Airbnb 和 Udacity 弃用 React Native 也把这个问题推向了舆论中心。不论是独立的移动开发者，还是大的互联网软件公司，都对这类方案褒贬不一；褒的是快速迭代和跨平台，而贬的是性能效率和抹平平台差异过程中的各种坑。动态化方案究竟是一个能让开发者托付终身的大道，还是路见不平一声吼的临时方案。笔者作为一个深耕移动开发数年的老兵，将从技术、架构、成本等各个角度，对移动端动态化方案进行深入阐述。\n\n![](https://ws1.sinaimg.cn/large/0069RVTdly1fu112vxq78j30u00e4dgs.jpg)\n\n## 移动端动态化的由来\n\n“动态化”并不是最近几年才产生的名词，而是从c互联网诞生的初期，这个词就已经出现了。大家所认知的早期互联网，其实就是各种各类的“动态网站”，内容数据和页面外观都不是固定的，都是随着服务器端的更新而更新的，让用户可以很及时地看到最新的内容。因此，动态化可以说是互联网的标志，是互联网最核心的特性之一。\n\n而移动互联网的普及，移动端被各类原生应用所占据，而这些应用更近似于 Software，依托于应用市场进行更新，只有其中的数据是实时的。这样，每次产品的更新，必须依赖用户的主动更新，从而造成了一定的用户成本，不利于产品的快速迭代，降低应用的试错能力。因此，移动端动态化方案逐渐走进大家的视野，并被大家所关注。\n\n从一开始基于 WebView 的 Hybrid 方案 PhoneGap、Titanium，到现在与原生相结合的 React Native 、Weex，甚至 Flutter，都被或多或少地使用到不同的移动应用中。以“去哪儿旅行” App 为例，机票业务 90% 以上的项目都已经使用 React Native 构建，酒店主流程业务也都使用 React Native 构建，另外还有过百项目使用 Hybrid 方案。据不完全统计，平均每天至少有 25 个使用动态化方案的项目进行发布，相对于用户主动更新的频率，这样的业务迭代速度，才是互联网公司所需要的。\n\n原生开发能不能动态化？准确的说是能的，而且 Android 平台各公司都有很完善的动态化方案，甚至 Google 今年还提供了 Android App Bundles 让开发者们可以更好地支持动态化。而反观 iOS，由于 Apple 官方担忧动态化的风险，因此并不太支持动态化（去年还封杀了 JSPatch 等一类动态修复方案），因此比较通用的原生动态化方案几乎没有，只有各大厂自己实现的一些动态化框架。\n\n*Android App Bundles 图示 :*\n\n![Android App Bundles](https://ws4.sinaimg.cn/large/0069RVTdly1fu12eto17tg30qo0f04qp.gif)\n\nApple 这样的做法，其实也有情可原。试想，你从应用市场下载了一个“抖音”，然后过几天打开，发现 App 内的内容变成了“拼多多”，还变不回去，是有多恶心。Apple 如此严格要求 App，也是 Apple Store 比各类 Android 市场上的 App 质量普遍要高的原因之一。 \n\n## 从 Web 开始\n\n既然动态化起源于 Web，那么移动端为什么不直接使用 Web 进行构建呢？而且在当前设备性能有大幅提升、浏览器内核得到有效优化的情况下。\n\n首先，历史原因。移动互联网兴起之初，移动设备上的浏览器内核版本和性能都比较低，移动网络速度较慢，再加上国内 Android 厂商为了所谓的“优化”，各种阉割、改造浏览器内核，造成纯的 Web 页面，不管从交互流畅度、功能完善度，还是从兼容各个平台所需的人力成本来讲，Web 都不是最好的选择。因此，绝大多数互联网产品都以 App 的形式存在，而用户通过几年的适应，已经习惯了 App 的“先下载再使用”的方式，对于纯 Web 的“即开即用”的形式并不是十分感冒。\n\n其次，虽然 Google 为了推动 Web 的发展，提出了两个非常卓越的思路 —— AMP 和 PWA，但是由于其他厂商的跟进较慢（例如  Apple），以及浏览器（包括内核）的版本迭代存在一定的长尾效应，短时间内形成良好的 Web App 的使用环境是比较困难的。\n\n![](https://ws3.sinaimg.cn/large/0069RVTdly1fu116g36tcj30hx0b3q3u.jpg)\n\n最后是涉及安全性较高的功能，例如支付。通过 Web API 直接调用移动设备的支付功能，或者调用指纹或人脸验证，都是行不通的。虽然较为安全的 Https 协议已经被广泛使用，调用验证和支付的 API 已经写入或即将写入 Web 标准，但是不管是手机厂商还是系统厂商，都没有行动起来，去为 Web 提供相应的功能 API。不论是安全上真的有缺陷，还是厂商认为 Web 不可控，但对于一个商业闭环，支付是不可缺少的一部分，这也制约了 Web App 的发展。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu117ayo5uj30wi09qjsd.jpg)\n\n## 到混合之路\n\n既然 Web App 行不通，那就尝试和 Native 进行结合。由于设备的繁多和定制化的差异，基于设备操作系统原生开发的成本逐渐升高，最明显的示例就是同样的功能逻辑在不同的设备上要用不同的编程语言、不同的代码结构去构建，学习成本、开发成本和维护成本大幅增加，因此引入一种开发更高效、成本更低的解决方案势在必行，而这个方案就是 Hybrid 混合开发，它让 Web 的跨平台特性被利用得淋淋尽致。\n\nHybrid 这个名词越来越多地出现在人们的视野中是源于混合动力汽车（Hybrid Electrical Vehicle，简称 HEV ），由汽油和电池一起提供动力，结合了油车续航长、补充快和电车清洁、低耗能的两方面优势，达到了发动机和电动机的最佳匹配。在互联网技术中的，Hybrid 方案也具有同样的特性——结合两种混合技术的优势，例如 Web 技术的跨平台、快速部署与原生 Native 的功能、性能相结合。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu118zeq4cj30gq05q74x.jpg)\n\n大多时候，圈内人谈论到 Hybrid 时，一般是指移动端内嵌 WebView 的开发方案。实则不然，广泛地讲，包括 React-Native 方案、各厂商的小程序方案都属于移动端 Hybrid 解决方案的范畴；而 NM.js、Electron 等则属于 PC 端 Hybrid 解决方案。对于智能设备，大多基于 Android 系统，因此，智能设备上使用的 Hybrid 方案与移动端基本一致。\n\n具体来看，移动端混合开发中的 Hybrid 方案，主要有三种形式：\n\n- 基于 Web 的解决方案，例如：Cordova、微信浏览器、各公司的 Hybrid 方案。\n- 非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案，例如：React-Native, Weex，Flutter。\n- 基于 Web 且 UI 层与逻辑层分离的解决方案，此类型的代表是微信小程序，将UI展现逻辑和业务逻辑分离到多个 JavaScript Context 里，提高运行效率，效果很好。\n\n其中，第一种方案，以 Web 为基础，实现成本最低，只是 Native 提供 WebView 运行 Web 页面，并提供相应的 API，平台兼容性问题，大部分交给 Web 来处理（Native 基本上只需要处理 API 层的兼容）；而且业务的开发方式保持 Web 的形式，对于前端是友好的。缺点也显而易见，Web 的性能受到浏览器内核的影响。\n\n![](https://ws1.sinaimg.cn/large/0069RVTdly1fu11egla86j30fd08j74r.jpg)\n\n第二种方案中最具代表的是 Facebook 的 React-Native，也在前言中提到过，推崇者无数的同时，粉转黑的也大有人在。它几乎将平台兼容性的问题全部交给了 Native，业务的 JavaScript 中是纯粹的业务逻辑。其优势，主要在性能，通过原生组件与 React 组件化设计相配合的方式提供高性能的 UI，但 JavaScript Context 和 Native 通信成了这套方案的瓶颈。\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu11bodplej30m8066q3j.jpg)\n\n通信过慢？不。单次通信并不慢，在某些频繁通信场景中，通信阻塞的问题会显现。例如数据量较多的列表，业务需要对现有的列表进行扩展，这时需要 JavaScript 响应各类滚动事件，这样通信量会大幅增加，造成通信阻塞。这里，有人会说，为啥 Native 组件不定制好？“魔高一尺道高一丈”，预先的设计肯定不能满足产品的所有需求。当然，Native 可以满足新的需求，这就需要依赖 App 的升级，需求不能在老版本 App 中实现。另外，React 的虚拟 Dom 机制，不能准确提供给 Native 元素复用的信息，也是影响性能的一个方面。\n\n第三种，基于 Web 且 UI 层与逻辑层分离的解决方案。微信小程序的性能是有目共睹的，但是微信小程序中由于各方面限制，复杂应用并不多，当一个应用足够庞大，性能又会如何呢（当然这种应用可能不会出现）。基于这种思路，我们也实现了一个类似架构的方案 YIS，基于 JavaScript Context 和 Web UI 的方案，业务逻辑都跑在 JavaScript Context 中，UI 在单独的 WebView 上绘制。经过验证，性能相当不错。相比于上一种，由于 UI 是 Web 实现的，故这些 UI 组件是可以动态更新的，可以更好地支持业务需求。不过，性能瓶颈仍是问题，毕竟 Web UI 的性能天花板要比 Native 低。有人说，随着移动设备性能的提升，浏览器内核的完善，Web UI 的性能问题会被解决。但是，笔者觉得，Web UI 性能的提升同时，Native UI 的性能会变得更好，可能会出现更“炫酷”的交互，例如科幻电影里，从手机中投射出 3D 视图，到那时，可能又会出现其他的性能问题。\n\n![](https://ws4.sinaimg.cn/large/0069RVTdly1fu11o4xmasj30go09ddht.jpg)\n\n所以，使用 Web UI 还是 Native UI 的争论，暂时停不下来。其实，没有最好的方案，根据自身的业务场景、公司情况，选择最适应的方案才是正道。\n\n## 终以 JSCore 为核\n\n不论是使用 Web UI 还是使用 Native UI，由于 JavaScript 是单线程，业务代码会与 UI 渲染同时占用线程资源，因此业务逻辑与 UI 分离，在现在看来是必须要做的，这样会让业务尽量动态化的同时，性能得到很大提升。\n\n运行业务逻辑的 JavaScript Context ，通常被统称成为 JSCore。通俗来讲，JSCore 就是一个即没有 DOM 也没有 BOM 的浏览器内核，和 WebWorker 近似，只能运行纯的 JavaScript 逻辑，并通过 Native提供的 API，进行网络请求、本地存储等操作。\n\n![](https://ws1.sinaimg.cn/large/0069RVTdly1fu11woinsmj30jg08c77n.jpg)\n\n当然，在实际的设计中，可以用一些例如“空间换时间”的方法，来优化 JSCore 的性能，例如预初始化 JSCore、预加载框架的 JavaScript 代码等，占用一些固有的内存，来保证业务的启动速度。\n\nJSCore 的模式，其实更像是 MVC、MVVM 盛行带来的红利。MVC、MVVM 的核心思想都是让开发者更关注业务本身，更关心业务逻辑，而剥离出来的 View 层，就可以通过组件化的形式，映射到其他的 Context 中，从而只保留非 UI 渲染逻辑在 JSCore 中，提高性能。\n\n## Web 不死，PWA 向前\n\nWeb 已死？No！同时，App 也不是未来。\n\n在移动端上，Web 还用很多瓶颈有待解决，但作为最灵活、跨平台性最好的技术，它缺是不可能被磨灭的。各种就 App 的动态化技术，都支持了兼容 Web 的方式（例如 rn-web），但是，其带来的开发和适配成本也是不小的。至少，一个短时的活动项目，用 Web 构建，可以在各个平台的浏览器中，各个 App 的 WebView 中运行，其成本远小于其他方案。再者，Web 对 SEO 的友好，也是 App 无法比拟的，这也是 Web 的一大优势。\n\n来自 App 的压力，推动着 Web 技术的发展，其中，Google 推出的 PWA 是最有颠覆性的。随着 Apple 新 Safari 和微软 Win10 对 PWA 的着力支持，PWA 的前景越来越明朗。在桌面有入口、支持控制资源缓存、支持消息推送、具备离线能力，当 PWA 应用可以完成 App 的一切，Web 或者又要重新站上顶峰。（真心推荐微博的 PWA 版本，比客户端好用多了）\n\n![](https://ws2.sinaimg.cn/large/0069RVTdly1fu11407dyij30fe066dg5.jpg)\n\n## 前路慢慢\n\n动态化方案，虽然由于种种原因成为了现在这个阶段中比较流行的方案，但是，动态化方案仍有很多没有解决的弊端，待我们去解决。而且，在我们解决的过程中，也会不断涌现其他各种方案。\n\n总之，动态化方案的出现，不是为了替代谁，更多是为了给用户更好的体验，同时让业务可以更快的迭代，并在不断的尝试中，给用户带来更好的产品。\n\n“路漫漫其修远兮，吾将上下而求索”。\n","slug":"2018-08-05-再谈移动端动态化方案","published":1,"updated":"2018-08-07T15:05:20.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc7a000vhxp4yyn7aeut","content":"<p>近几年，移动互联网发展迅猛，几乎每天一变，各种新技术、新思想犹如雨后春笋般，层出不穷。虽然移动端动态化方案已经发展了很多年，但是每天都有新的变化，所以笔者在这里重新和大家聊一下移动端动态化方案。<a id=\"more\"></a></p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在移动开发领域，动态化方案一直争议不断，而最近 Airbnb 和 Udacity 弃用 React Native 也把这个问题推向了舆论中心。不论是独立的移动开发者，还是大的互联网软件公司，都对这类方案褒贬不一；褒的是快速迭代和跨平台，而贬的是性能效率和抹平平台差异过程中的各种坑。动态化方案究竟是一个能让开发者托付终身的大道，还是路见不平一声吼的临时方案。笔者作为一个深耕移动开发数年的老兵，将从技术、架构、成本等各个角度，对移动端动态化方案进行深入阐述。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fu112vxq78j30u00e4dgs.jpg\" alt=\"\"></p>\n<h2 id=\"移动端动态化的由来\"><a href=\"#移动端动态化的由来\" class=\"headerlink\" title=\"移动端动态化的由来\"></a>移动端动态化的由来</h2><p>“动态化”并不是最近几年才产生的名词，而是从c互联网诞生的初期，这个词就已经出现了。大家所认知的早期互联网，其实就是各种各类的“动态网站”，内容数据和页面外观都不是固定的，都是随着服务器端的更新而更新的，让用户可以很及时地看到最新的内容。因此，动态化可以说是互联网的标志，是互联网最核心的特性之一。</p>\n<p>而移动互联网的普及，移动端被各类原生应用所占据，而这些应用更近似于 Software，依托于应用市场进行更新，只有其中的数据是实时的。这样，每次产品的更新，必须依赖用户的主动更新，从而造成了一定的用户成本，不利于产品的快速迭代，降低应用的试错能力。因此，移动端动态化方案逐渐走进大家的视野，并被大家所关注。</p>\n<p>从一开始基于 WebView 的 Hybrid 方案 PhoneGap、Titanium，到现在与原生相结合的 React Native 、Weex，甚至 Flutter，都被或多或少地使用到不同的移动应用中。以“去哪儿旅行” App 为例，机票业务 90% 以上的项目都已经使用 React Native 构建，酒店主流程业务也都使用 React Native 构建，另外还有过百项目使用 Hybrid 方案。据不完全统计，平均每天至少有 25 个使用动态化方案的项目进行发布，相对于用户主动更新的频率，这样的业务迭代速度，才是互联网公司所需要的。</p>\n<p>原生开发能不能动态化？准确的说是能的，而且 Android 平台各公司都有很完善的动态化方案，甚至 Google 今年还提供了 Android App Bundles 让开发者们可以更好地支持动态化。而反观 iOS，由于 Apple 官方担忧动态化的风险，因此并不太支持动态化（去年还封杀了 JSPatch 等一类动态修复方案），因此比较通用的原生动态化方案几乎没有，只有各大厂自己实现的一些动态化框架。</p>\n<p><em>Android App Bundles 图示 :</em></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/0069RVTdly1fu12eto17tg30qo0f04qp.gif\" alt=\"Android App Bundles\"></p>\n<p>Apple 这样的做法，其实也有情可原。试想，你从应用市场下载了一个“抖音”，然后过几天打开，发现 App 内的内容变成了“拼多多”，还变不回去，是有多恶心。Apple 如此严格要求 App，也是 Apple Store 比各类 Android 市场上的 App 质量普遍要高的原因之一。 </p>\n<h2 id=\"从-Web-开始\"><a href=\"#从-Web-开始\" class=\"headerlink\" title=\"从 Web 开始\"></a>从 Web 开始</h2><p>既然动态化起源于 Web，那么移动端为什么不直接使用 Web 进行构建呢？而且在当前设备性能有大幅提升、浏览器内核得到有效优化的情况下。</p>\n<p>首先，历史原因。移动互联网兴起之初，移动设备上的浏览器内核版本和性能都比较低，移动网络速度较慢，再加上国内 Android 厂商为了所谓的“优化”，各种阉割、改造浏览器内核，造成纯的 Web 页面，不管从交互流畅度、功能完善度，还是从兼容各个平台所需的人力成本来讲，Web 都不是最好的选择。因此，绝大多数互联网产品都以 App 的形式存在，而用户通过几年的适应，已经习惯了 App 的“先下载再使用”的方式，对于纯 Web 的“即开即用”的形式并不是十分感冒。</p>\n<p>其次，虽然 Google 为了推动 Web 的发展，提出了两个非常卓越的思路 —— AMP 和 PWA，但是由于其他厂商的跟进较慢（例如  Apple），以及浏览器（包括内核）的版本迭代存在一定的长尾效应，短时间内形成良好的 Web App 的使用环境是比较困难的。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fu116g36tcj30hx0b3q3u.jpg\" alt=\"\"></p>\n<p>最后是涉及安全性较高的功能，例如支付。通过 Web API 直接调用移动设备的支付功能，或者调用指纹或人脸验证，都是行不通的。虽然较为安全的 Https 协议已经被广泛使用，调用验证和支付的 API 已经写入或即将写入 Web 标准，但是不管是手机厂商还是系统厂商，都没有行动起来，去为 Web 提供相应的功能 API。不论是安全上真的有缺陷，还是厂商认为 Web 不可控，但对于一个商业闭环，支付是不可缺少的一部分，这也制约了 Web App 的发展。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu117ayo5uj30wi09qjsd.jpg\" alt=\"\"></p>\n<h2 id=\"到混合之路\"><a href=\"#到混合之路\" class=\"headerlink\" title=\"到混合之路\"></a>到混合之路</h2><p>既然 Web App 行不通，那就尝试和 Native 进行结合。由于设备的繁多和定制化的差异，基于设备操作系统原生开发的成本逐渐升高，最明显的示例就是同样的功能逻辑在不同的设备上要用不同的编程语言、不同的代码结构去构建，学习成本、开发成本和维护成本大幅增加，因此引入一种开发更高效、成本更低的解决方案势在必行，而这个方案就是 Hybrid 混合开发，它让 Web 的跨平台特性被利用得淋淋尽致。</p>\n<p>Hybrid 这个名词越来越多地出现在人们的视野中是源于混合动力汽车（Hybrid Electrical Vehicle，简称 HEV ），由汽油和电池一起提供动力，结合了油车续航长、补充快和电车清洁、低耗能的两方面优势，达到了发动机和电动机的最佳匹配。在互联网技术中的，Hybrid 方案也具有同样的特性——结合两种混合技术的优势，例如 Web 技术的跨平台、快速部署与原生 Native 的功能、性能相结合。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu118zeq4cj30gq05q74x.jpg\" alt=\"\"></p>\n<p>大多时候，圈内人谈论到 Hybrid 时，一般是指移动端内嵌 WebView 的开发方案。实则不然，广泛地讲，包括 React-Native 方案、各厂商的小程序方案都属于移动端 Hybrid 解决方案的范畴；而 NM.js、Electron 等则属于 PC 端 Hybrid 解决方案。对于智能设备，大多基于 Android 系统，因此，智能设备上使用的 Hybrid 方案与移动端基本一致。</p>\n<p>具体来看，移动端混合开发中的 Hybrid 方案，主要有三种形式：</p>\n<ul>\n<li>基于 Web 的解决方案，例如：Cordova、微信浏览器、各公司的 Hybrid 方案。</li>\n<li>非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案，例如：React-Native, Weex，Flutter。</li>\n<li>基于 Web 且 UI 层与逻辑层分离的解决方案，此类型的代表是微信小程序，将UI展现逻辑和业务逻辑分离到多个 JavaScript Context 里，提高运行效率，效果很好。</li>\n</ul>\n<p>其中，第一种方案，以 Web 为基础，实现成本最低，只是 Native 提供 WebView 运行 Web 页面，并提供相应的 API，平台兼容性问题，大部分交给 Web 来处理（Native 基本上只需要处理 API 层的兼容）；而且业务的开发方式保持 Web 的形式，对于前端是友好的。缺点也显而易见，Web 的性能受到浏览器内核的影响。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fu11egla86j30fd08j74r.jpg\" alt=\"\"></p>\n<p>第二种方案中最具代表的是 Facebook 的 React-Native，也在前言中提到过，推崇者无数的同时，粉转黑的也大有人在。它几乎将平台兼容性的问题全部交给了 Native，业务的 JavaScript 中是纯粹的业务逻辑。其优势，主要在性能，通过原生组件与 React 组件化设计相配合的方式提供高性能的 UI，但 JavaScript Context 和 Native 通信成了这套方案的瓶颈。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu11bodplej30m8066q3j.jpg\" alt=\"\"></p>\n<p>通信过慢？不。单次通信并不慢，在某些频繁通信场景中，通信阻塞的问题会显现。例如数据量较多的列表，业务需要对现有的列表进行扩展，这时需要 JavaScript 响应各类滚动事件，这样通信量会大幅增加，造成通信阻塞。这里，有人会说，为啥 Native 组件不定制好？“魔高一尺道高一丈”，预先的设计肯定不能满足产品的所有需求。当然，Native 可以满足新的需求，这就需要依赖 App 的升级，需求不能在老版本 App 中实现。另外，React 的虚拟 Dom 机制，不能准确提供给 Native 元素复用的信息，也是影响性能的一个方面。</p>\n<p>第三种，基于 Web 且 UI 层与逻辑层分离的解决方案。微信小程序的性能是有目共睹的，但是微信小程序中由于各方面限制，复杂应用并不多，当一个应用足够庞大，性能又会如何呢（当然这种应用可能不会出现）。基于这种思路，我们也实现了一个类似架构的方案 YIS，基于 JavaScript Context 和 Web UI 的方案，业务逻辑都跑在 JavaScript Context 中，UI 在单独的 WebView 上绘制。经过验证，性能相当不错。相比于上一种，由于 UI 是 Web 实现的，故这些 UI 组件是可以动态更新的，可以更好地支持业务需求。不过，性能瓶颈仍是问题，毕竟 Web UI 的性能天花板要比 Native 低。有人说，随着移动设备性能的提升，浏览器内核的完善，Web UI 的性能问题会被解决。但是，笔者觉得，Web UI 性能的提升同时，Native UI 的性能会变得更好，可能会出现更“炫酷”的交互，例如科幻电影里，从手机中投射出 3D 视图，到那时，可能又会出现其他的性能问题。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/0069RVTdly1fu11o4xmasj30go09ddht.jpg\" alt=\"\"></p>\n<p>所以，使用 Web UI 还是 Native UI 的争论，暂时停不下来。其实，没有最好的方案，根据自身的业务场景、公司情况，选择最适应的方案才是正道。</p>\n<h2 id=\"终以-JSCore-为核\"><a href=\"#终以-JSCore-为核\" class=\"headerlink\" title=\"终以 JSCore 为核\"></a>终以 JSCore 为核</h2><p>不论是使用 Web UI 还是使用 Native UI，由于 JavaScript 是单线程，业务代码会与 UI 渲染同时占用线程资源，因此业务逻辑与 UI 分离，在现在看来是必须要做的，这样会让业务尽量动态化的同时，性能得到很大提升。</p>\n<p>运行业务逻辑的 JavaScript Context ，通常被统称成为 JSCore。通俗来讲，JSCore 就是一个即没有 DOM 也没有 BOM 的浏览器内核，和 WebWorker 近似，只能运行纯的 JavaScript 逻辑，并通过 Native提供的 API，进行网络请求、本地存储等操作。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fu11woinsmj30jg08c77n.jpg\" alt=\"\"></p>\n<p>当然，在实际的设计中，可以用一些例如“空间换时间”的方法，来优化 JSCore 的性能，例如预初始化 JSCore、预加载框架的 JavaScript 代码等，占用一些固有的内存，来保证业务的启动速度。</p>\n<p>JSCore 的模式，其实更像是 MVC、MVVM 盛行带来的红利。MVC、MVVM 的核心思想都是让开发者更关注业务本身，更关心业务逻辑，而剥离出来的 View 层，就可以通过组件化的形式，映射到其他的 Context 中，从而只保留非 UI 渲染逻辑在 JSCore 中，提高性能。</p>\n<h2 id=\"Web-不死，PWA-向前\"><a href=\"#Web-不死，PWA-向前\" class=\"headerlink\" title=\"Web 不死，PWA 向前\"></a>Web 不死，PWA 向前</h2><p>Web 已死？No！同时，App 也不是未来。</p>\n<p>在移动端上，Web 还用很多瓶颈有待解决，但作为最灵活、跨平台性最好的技术，它缺是不可能被磨灭的。各种就 App 的动态化技术，都支持了兼容 Web 的方式（例如 rn-web），但是，其带来的开发和适配成本也是不小的。至少，一个短时的活动项目，用 Web 构建，可以在各个平台的浏览器中，各个 App 的 WebView 中运行，其成本远小于其他方案。再者，Web 对 SEO 的友好，也是 App 无法比拟的，这也是 Web 的一大优势。</p>\n<p>来自 App 的压力，推动着 Web 技术的发展，其中，Google 推出的 PWA 是最有颠覆性的。随着 Apple 新 Safari 和微软 Win10 对 PWA 的着力支持，PWA 的前景越来越明朗。在桌面有入口、支持控制资源缓存、支持消息推送、具备离线能力，当 PWA 应用可以完成 App 的一切，Web 或者又要重新站上顶峰。（真心推荐微博的 PWA 版本，比客户端好用多了）</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu11407dyij30fe066dg5.jpg\" alt=\"\"></p>\n<h2 id=\"前路慢慢\"><a href=\"#前路慢慢\" class=\"headerlink\" title=\"前路慢慢\"></a>前路慢慢</h2><p>动态化方案，虽然由于种种原因成为了现在这个阶段中比较流行的方案，但是，动态化方案仍有很多没有解决的弊端，待我们去解决。而且，在我们解决的过程中，也会不断涌现其他各种方案。</p>\n<p>总之，动态化方案的出现，不是为了替代谁，更多是为了给用户更好的体验，同时让业务可以更快的迭代，并在不断的尝试中，给用户带来更好的产品。</p>\n<p>“路漫漫其修远兮，吾将上下而求索”。</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws4.sinaimg.cn/large/006tKfTcly1ftwl4uvaduj30yi1pc4qr.jpg","excerpt":"<p>近几年，移动互联网发展迅猛，几乎每天一变，各种新技术、新思想犹如雨后春笋般，层出不穷。虽然移动端动态化方案已经发展了很多年，但是每天都有新的变化，所以笔者在这里重新和大家聊一下移动端动态化方案。","more":"</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在移动开发领域，动态化方案一直争议不断，而最近 Airbnb 和 Udacity 弃用 React Native 也把这个问题推向了舆论中心。不论是独立的移动开发者，还是大的互联网软件公司，都对这类方案褒贬不一；褒的是快速迭代和跨平台，而贬的是性能效率和抹平平台差异过程中的各种坑。动态化方案究竟是一个能让开发者托付终身的大道，还是路见不平一声吼的临时方案。笔者作为一个深耕移动开发数年的老兵，将从技术、架构、成本等各个角度，对移动端动态化方案进行深入阐述。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fu112vxq78j30u00e4dgs.jpg\" alt=\"\"></p>\n<h2 id=\"移动端动态化的由来\"><a href=\"#移动端动态化的由来\" class=\"headerlink\" title=\"移动端动态化的由来\"></a>移动端动态化的由来</h2><p>“动态化”并不是最近几年才产生的名词，而是从c互联网诞生的初期，这个词就已经出现了。大家所认知的早期互联网，其实就是各种各类的“动态网站”，内容数据和页面外观都不是固定的，都是随着服务器端的更新而更新的，让用户可以很及时地看到最新的内容。因此，动态化可以说是互联网的标志，是互联网最核心的特性之一。</p>\n<p>而移动互联网的普及，移动端被各类原生应用所占据，而这些应用更近似于 Software，依托于应用市场进行更新，只有其中的数据是实时的。这样，每次产品的更新，必须依赖用户的主动更新，从而造成了一定的用户成本，不利于产品的快速迭代，降低应用的试错能力。因此，移动端动态化方案逐渐走进大家的视野，并被大家所关注。</p>\n<p>从一开始基于 WebView 的 Hybrid 方案 PhoneGap、Titanium，到现在与原生相结合的 React Native 、Weex，甚至 Flutter，都被或多或少地使用到不同的移动应用中。以“去哪儿旅行” App 为例，机票业务 90% 以上的项目都已经使用 React Native 构建，酒店主流程业务也都使用 React Native 构建，另外还有过百项目使用 Hybrid 方案。据不完全统计，平均每天至少有 25 个使用动态化方案的项目进行发布，相对于用户主动更新的频率，这样的业务迭代速度，才是互联网公司所需要的。</p>\n<p>原生开发能不能动态化？准确的说是能的，而且 Android 平台各公司都有很完善的动态化方案，甚至 Google 今年还提供了 Android App Bundles 让开发者们可以更好地支持动态化。而反观 iOS，由于 Apple 官方担忧动态化的风险，因此并不太支持动态化（去年还封杀了 JSPatch 等一类动态修复方案），因此比较通用的原生动态化方案几乎没有，只有各大厂自己实现的一些动态化框架。</p>\n<p><em>Android App Bundles 图示 :</em></p>\n<p><img src=\"https://ws4.sinaimg.cn/large/0069RVTdly1fu12eto17tg30qo0f04qp.gif\" alt=\"Android App Bundles\"></p>\n<p>Apple 这样的做法，其实也有情可原。试想，你从应用市场下载了一个“抖音”，然后过几天打开，发现 App 内的内容变成了“拼多多”，还变不回去，是有多恶心。Apple 如此严格要求 App，也是 Apple Store 比各类 Android 市场上的 App 质量普遍要高的原因之一。 </p>\n<h2 id=\"从-Web-开始\"><a href=\"#从-Web-开始\" class=\"headerlink\" title=\"从 Web 开始\"></a>从 Web 开始</h2><p>既然动态化起源于 Web，那么移动端为什么不直接使用 Web 进行构建呢？而且在当前设备性能有大幅提升、浏览器内核得到有效优化的情况下。</p>\n<p>首先，历史原因。移动互联网兴起之初，移动设备上的浏览器内核版本和性能都比较低，移动网络速度较慢，再加上国内 Android 厂商为了所谓的“优化”，各种阉割、改造浏览器内核，造成纯的 Web 页面，不管从交互流畅度、功能完善度，还是从兼容各个平台所需的人力成本来讲，Web 都不是最好的选择。因此，绝大多数互联网产品都以 App 的形式存在，而用户通过几年的适应，已经习惯了 App 的“先下载再使用”的方式，对于纯 Web 的“即开即用”的形式并不是十分感冒。</p>\n<p>其次，虽然 Google 为了推动 Web 的发展，提出了两个非常卓越的思路 —— AMP 和 PWA，但是由于其他厂商的跟进较慢（例如  Apple），以及浏览器（包括内核）的版本迭代存在一定的长尾效应，短时间内形成良好的 Web App 的使用环境是比较困难的。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fu116g36tcj30hx0b3q3u.jpg\" alt=\"\"></p>\n<p>最后是涉及安全性较高的功能，例如支付。通过 Web API 直接调用移动设备的支付功能，或者调用指纹或人脸验证，都是行不通的。虽然较为安全的 Https 协议已经被广泛使用，调用验证和支付的 API 已经写入或即将写入 Web 标准，但是不管是手机厂商还是系统厂商，都没有行动起来，去为 Web 提供相应的功能 API。不论是安全上真的有缺陷，还是厂商认为 Web 不可控，但对于一个商业闭环，支付是不可缺少的一部分，这也制约了 Web App 的发展。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu117ayo5uj30wi09qjsd.jpg\" alt=\"\"></p>\n<h2 id=\"到混合之路\"><a href=\"#到混合之路\" class=\"headerlink\" title=\"到混合之路\"></a>到混合之路</h2><p>既然 Web App 行不通，那就尝试和 Native 进行结合。由于设备的繁多和定制化的差异，基于设备操作系统原生开发的成本逐渐升高，最明显的示例就是同样的功能逻辑在不同的设备上要用不同的编程语言、不同的代码结构去构建，学习成本、开发成本和维护成本大幅增加，因此引入一种开发更高效、成本更低的解决方案势在必行，而这个方案就是 Hybrid 混合开发，它让 Web 的跨平台特性被利用得淋淋尽致。</p>\n<p>Hybrid 这个名词越来越多地出现在人们的视野中是源于混合动力汽车（Hybrid Electrical Vehicle，简称 HEV ），由汽油和电池一起提供动力，结合了油车续航长、补充快和电车清洁、低耗能的两方面优势，达到了发动机和电动机的最佳匹配。在互联网技术中的，Hybrid 方案也具有同样的特性——结合两种混合技术的优势，例如 Web 技术的跨平台、快速部署与原生 Native 的功能、性能相结合。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu118zeq4cj30gq05q74x.jpg\" alt=\"\"></p>\n<p>大多时候，圈内人谈论到 Hybrid 时，一般是指移动端内嵌 WebView 的开发方案。实则不然，广泛地讲，包括 React-Native 方案、各厂商的小程序方案都属于移动端 Hybrid 解决方案的范畴；而 NM.js、Electron 等则属于 PC 端 Hybrid 解决方案。对于智能设备，大多基于 Android 系统，因此，智能设备上使用的 Hybrid 方案与移动端基本一致。</p>\n<p>具体来看，移动端混合开发中的 Hybrid 方案，主要有三种形式：</p>\n<ul>\n<li>基于 Web 的解决方案，例如：Cordova、微信浏览器、各公司的 Hybrid 方案。</li>\n<li>非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案，例如：React-Native, Weex，Flutter。</li>\n<li>基于 Web 且 UI 层与逻辑层分离的解决方案，此类型的代表是微信小程序，将UI展现逻辑和业务逻辑分离到多个 JavaScript Context 里，提高运行效率，效果很好。</li>\n</ul>\n<p>其中，第一种方案，以 Web 为基础，实现成本最低，只是 Native 提供 WebView 运行 Web 页面，并提供相应的 API，平台兼容性问题，大部分交给 Web 来处理（Native 基本上只需要处理 API 层的兼容）；而且业务的开发方式保持 Web 的形式，对于前端是友好的。缺点也显而易见，Web 的性能受到浏览器内核的影响。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fu11egla86j30fd08j74r.jpg\" alt=\"\"></p>\n<p>第二种方案中最具代表的是 Facebook 的 React-Native，也在前言中提到过，推崇者无数的同时，粉转黑的也大有人在。它几乎将平台兼容性的问题全部交给了 Native，业务的 JavaScript 中是纯粹的业务逻辑。其优势，主要在性能，通过原生组件与 React 组件化设计相配合的方式提供高性能的 UI，但 JavaScript Context 和 Native 通信成了这套方案的瓶颈。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu11bodplej30m8066q3j.jpg\" alt=\"\"></p>\n<p>通信过慢？不。单次通信并不慢，在某些频繁通信场景中，通信阻塞的问题会显现。例如数据量较多的列表，业务需要对现有的列表进行扩展，这时需要 JavaScript 响应各类滚动事件，这样通信量会大幅增加，造成通信阻塞。这里，有人会说，为啥 Native 组件不定制好？“魔高一尺道高一丈”，预先的设计肯定不能满足产品的所有需求。当然，Native 可以满足新的需求，这就需要依赖 App 的升级，需求不能在老版本 App 中实现。另外，React 的虚拟 Dom 机制，不能准确提供给 Native 元素复用的信息，也是影响性能的一个方面。</p>\n<p>第三种，基于 Web 且 UI 层与逻辑层分离的解决方案。微信小程序的性能是有目共睹的，但是微信小程序中由于各方面限制，复杂应用并不多，当一个应用足够庞大，性能又会如何呢（当然这种应用可能不会出现）。基于这种思路，我们也实现了一个类似架构的方案 YIS，基于 JavaScript Context 和 Web UI 的方案，业务逻辑都跑在 JavaScript Context 中，UI 在单独的 WebView 上绘制。经过验证，性能相当不错。相比于上一种，由于 UI 是 Web 实现的，故这些 UI 组件是可以动态更新的，可以更好地支持业务需求。不过，性能瓶颈仍是问题，毕竟 Web UI 的性能天花板要比 Native 低。有人说，随着移动设备性能的提升，浏览器内核的完善，Web UI 的性能问题会被解决。但是，笔者觉得，Web UI 性能的提升同时，Native UI 的性能会变得更好，可能会出现更“炫酷”的交互，例如科幻电影里，从手机中投射出 3D 视图，到那时，可能又会出现其他的性能问题。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/0069RVTdly1fu11o4xmasj30go09ddht.jpg\" alt=\"\"></p>\n<p>所以，使用 Web UI 还是 Native UI 的争论，暂时停不下来。其实，没有最好的方案，根据自身的业务场景、公司情况，选择最适应的方案才是正道。</p>\n<h2 id=\"终以-JSCore-为核\"><a href=\"#终以-JSCore-为核\" class=\"headerlink\" title=\"终以 JSCore 为核\"></a>终以 JSCore 为核</h2><p>不论是使用 Web UI 还是使用 Native UI，由于 JavaScript 是单线程，业务代码会与 UI 渲染同时占用线程资源，因此业务逻辑与 UI 分离，在现在看来是必须要做的，这样会让业务尽量动态化的同时，性能得到很大提升。</p>\n<p>运行业务逻辑的 JavaScript Context ，通常被统称成为 JSCore。通俗来讲，JSCore 就是一个即没有 DOM 也没有 BOM 的浏览器内核，和 WebWorker 近似，只能运行纯的 JavaScript 逻辑，并通过 Native提供的 API，进行网络请求、本地存储等操作。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fu11woinsmj30jg08c77n.jpg\" alt=\"\"></p>\n<p>当然，在实际的设计中，可以用一些例如“空间换时间”的方法，来优化 JSCore 的性能，例如预初始化 JSCore、预加载框架的 JavaScript 代码等，占用一些固有的内存，来保证业务的启动速度。</p>\n<p>JSCore 的模式，其实更像是 MVC、MVVM 盛行带来的红利。MVC、MVVM 的核心思想都是让开发者更关注业务本身，更关心业务逻辑，而剥离出来的 View 层，就可以通过组件化的形式，映射到其他的 Context 中，从而只保留非 UI 渲染逻辑在 JSCore 中，提高性能。</p>\n<h2 id=\"Web-不死，PWA-向前\"><a href=\"#Web-不死，PWA-向前\" class=\"headerlink\" title=\"Web 不死，PWA 向前\"></a>Web 不死，PWA 向前</h2><p>Web 已死？No！同时，App 也不是未来。</p>\n<p>在移动端上，Web 还用很多瓶颈有待解决，但作为最灵活、跨平台性最好的技术，它缺是不可能被磨灭的。各种就 App 的动态化技术，都支持了兼容 Web 的方式（例如 rn-web），但是，其带来的开发和适配成本也是不小的。至少，一个短时的活动项目，用 Web 构建，可以在各个平台的浏览器中，各个 App 的 WebView 中运行，其成本远小于其他方案。再者，Web 对 SEO 的友好，也是 App 无法比拟的，这也是 Web 的一大优势。</p>\n<p>来自 App 的压力，推动着 Web 技术的发展，其中，Google 推出的 PWA 是最有颠覆性的。随着 Apple 新 Safari 和微软 Win10 对 PWA 的着力支持，PWA 的前景越来越明朗。在桌面有入口、支持控制资源缓存、支持消息推送、具备离线能力，当 PWA 应用可以完成 App 的一切，Web 或者又要重新站上顶峰。（真心推荐微博的 PWA 版本，比客户端好用多了）</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fu11407dyij30fe066dg5.jpg\" alt=\"\"></p>\n<h2 id=\"前路慢慢\"><a href=\"#前路慢慢\" class=\"headerlink\" title=\"前路慢慢\"></a>前路慢慢</h2><p>动态化方案，虽然由于种种原因成为了现在这个阶段中比较流行的方案，但是，动态化方案仍有很多没有解决的弊端，待我们去解决。而且，在我们解决的过程中，也会不断涌现其他各种方案。</p>\n<p>总之，动态化方案的出现，不是为了替代谁，更多是为了给用户更好的体验，同时让业务可以更快的迭代，并在不断的尝试中，给用户带来更好的产品。</p>\n<p>“路漫漫其修远兮，吾将上下而求索”。</p>"},{"title":"深入 Web 缓存策略","date":"2018-10-10T04:00:00.000Z","thumbnailImage":"https://ws4.sinaimg.cn/large/006tNbRwly1fuzvbbtcb0j30s60do407.jpg","_content":"\n移动互联网时代，各种互联网技术层出不穷，尤其在移动端方面，各种动态化方案如雨后春笋般，在各自的领域蓬勃生长。但是，不管哪种方案，都会涉及到资源的迭代更新问题。如何让用户在更快地使用最新资源的同时，也能结合缓存保证应用的加载效率，是这类方案必须要考虑的。本文将从浏览器缓存谈起，在涵盖 App Cache、SW Cache 等纯 Web 缓存方案的同时，也将站在大前端角度去分析不同方案的差异，最终，让大家对 web 缓存策略有一个详尽的了解。<!-- more -->\n\n## 1. 资源更新与缓存\n\n从互联网开始向大众普及，Web 技术就成为不能缺少的一部分，其资源控制权，也从用户端转向服务端，由服务端响应客户端的请求，并推送最新的资源。理论上，可以让用户每次都能使用到最新的资源，从而让产品迭代更快速、更有效。但是，这样的逻辑也带来了一些很严重的问题：\n\n* 当无网时，用户端取不到相应的资源，导致产品不可用。\n* 当弱网时，用户端获取资源速度很低，使产品加载缓慢，最终导致产品体验很差。 \n\n为了解决此类问题，必须要引入资源的本地暂存机制，也就是通常说的 —— **缓存**。缓存的出现，始于计算机对性能的要求。计算机为了在性能上能有指数级的增长，引入了缓存设计。简单说，存储和读取速度和硬件的成本成正比：相同空间的存储硬件，存取越快，成本越高。下图说明了计算机中缓存的设计，会分很多不同层级的缓存，当然内存也可以算作缓存的一种。\n\n![缓存设计](https://ws1.sinaimg.cn/large/0069RVTdly1fv3lc27kpbj30go06y74t.jpg)\n\n所以为了权衡，两者相结合，使得性价比最大。而这篇文章里主要讨论的是偏向用户端的缓存，与传统缓存类似，虽然缓存运用得越广泛，用户的体验越好，但同时也增加了相应的维护成本。\n\nPhil Karlton 说过一句广受大家共鸣的一句话：“There are only two hard things in Computer Science: cache invalidation and naming things.（命名和缓存失效是计算机科学里面最难对付的两件事）”，可以看出缓存是大家很难去维护但不得不去维护的策略。只要存在缓存，就能得到性能和体验上的提升；而在合适的时机删除之前缓存的资源并更新最新资源，却是一个很难完美解决的问题。\n\n当前缓存运用的场景，除了计算机硬件及系统以外，主要在数据库和网络资源两个主要方向。而其中，网络资源更多运用在用户端，尤其在 Web 技术中，浏览器基于网络协议配置的缓存是最常见，同时也是最贴近用户的使用场景。因此，为了让大家更好地了解缓存策略的细节，笔者将从 Web 缓存谈起。\n\n## 2. Web 缓存\n\n之前，大家提到 Web 缓存，大多是指浏览器缓存。但随着 HTML5 的发展（App Cache）以及 PWA 技术的推广（SW Cache），前端工程师可以可以自由控制浏览器对资源的缓存。Web 缓存从服务端配置化逐渐演变为用户端逻辑化，从由浏览器自动控制到由工程师自主设计，使资源更新更灵活，但也带来一些不易解决的问题。\n\n下面，从最传统的浏览器缓存谈起，深入了解资源缓存的细节。\n\n### 2.1 浏览器缓存 —— Browser Cache（HTTP 客户端缓存）\n\n现在的大型网站，不管是 PC 端还是移动端，动不动就几十个请求，如果没有浏览器缓存的存在，用户体验会急剧下降，同时服务器压力和网络带宽都将面临严重的考验。因此，浏览器缓存是现代互联网中必不可少的一环。\n\n从技术角度讲，浏览器缓存是 HTTP 缓存机制中客户端部分的一个实现。\n\nHTTP 缓存机制分为两种，**客户端缓存** 和 **服务端缓存** ，而服务端缓存又分为 **代理服务器缓存**（例：CDN 服务）和 **反向代理服务器缓存**（例：Nginx 反向代理服务）。由于篇幅有限，服务端缓存部分就不加赘述了。\n\n关于客户端缓存，浏览器缓存是其中的一种实现形式，在浏览器内核中实现基于 HTTP 缓存机制的缓存。当然，在各类网络请求的开发库中，也实现了几乎同样的逻辑。这些逻辑，都是基于 HTTP 协议中的 HEADER 来实现的，根据  HEADER 中相应配置的不同，执行不同的缓存逻辑。\n\n![HTTP 报文结构](https://ws1.sinaimg.cn/large/0069RVTdly1fv3nmog9rpj30dw05twf1.jpg)\n\n对于客户端整体缓存逻辑，大家应该比较清楚：判断是否有缓存，如果有就直接使用缓存中的内容，如果没有则进行网络请求获取内容。（如下图）\n\n![HTTP 客户端整体缓存逻辑](https://ws3.sinaimg.cn/large/0069RVTdly1fv3nw5x397j30lb09amxe.jpg)\n\n但是客户端怎么根据 HTTP 的 HEADER 来更为细化地控制缓存的呢？其实 HTTP 客户端缓存有两种不同的策略机制：\n\n* **服务端决策缓存**：由服务端决定并告知客户端是否使用缓存。\n* **客户端决策缓存**：服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。\n\n对于这两种策略机制的区别，最明显的表象是：从 Chrome DevTool 中 Network 面板里看到缓存的请求，服务端决策缓存在 Status 一栏显示的是 `304`，而客户端决策缓存在 Status 一栏显示的是 `200`，不过在 Size 一栏会显示 `from disk cache`。这两种策略机制，从解释中就可以看出，区别在于上图中的检查是否有缓存的部分。\n\n道上常说，有图有真相，所以先把两种策略机制的流程图奉上，每种策略机制都分有 **缓存命中** 和 **缓存未命中** 两种情况。\n\n![HTTP 客户端缓存策略流程图](https://ws2.sinaimg.cn/large/0069RVTdly1fv3pcj7k4ej30qo0ub76e.jpg)\n\n这两种缓存策略机制主要是由 HTTP Header 中的 `Cache-Control` 来决定和控制使用的。此属性常见的取值有以下6类：\n\n* `public`：全部缓存，包括客户端和服务端（时长 365 天）\n* `private`：仅客户端缓存（时长 365 天）\n* `no-cache`：不适用客户端的缓存，使用“服务端决策缓存”。并不是表面意义上的“不使用缓存”。\n* `no-store`：所有内容都不会被缓存，不论哪种策略机制都不会被缓存。不同浏览器对这种情况的实现不同，有些浏览器是不缓存，有些是在特定实际清除缓存，例如当前页面关闭、浏览器关闭等。\n* `must-revalidation/proxy-revalidation`：如果缓存内容失效，请求必须发送服务器/代理进行验证。也就是当“客户端决策缓存”未命中时，使用“服务端决策缓存”，理论上是最优的缓存策略。不过，只有最新的部分浏览器和网络库支持此配置，还未普及。\n* `max-age=<s>`：缓存内容在s秒后失效，仅 HTTP 1.1 可用。（HTTP 1.0 可以用 `Expires`）\n\n其中，对于前端资源，最常用的是 `Cache-Control: no-cache` 和 `Cache-Control: max-age=123`，分别对应笔者上文提到的两种策略机制。而对于数据请求，一般使用 `Cache-Control: no-store` 来保证每次数据都是新的，而由于前文提到 `no-store` 的实现方式有异，最好还是加随机参数来避免缓存。\n\n当然，`Cache-Control` 不仅仅这六类取值，更多的可以直接查看 HTTP 1.1 协议文档 [rfc2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)。\n\n在上面的流程图中，提到了“缓存标识”，此标识也是使用 HTTP Header 进行通信的，可以使用 `Etag/If-None-Match` 或 `Last-Modified/If-Modified-Since` 对资源进行标识，前者是资源的特征值，也可看做为标识符，而后者则是资源的更新时间。具体使用哪个，由服务端获取特征值和修改时间的效率决定，使用效率较好的一个。当然，这两个标识可以同时使用，此时 `Etag/If-None-Match` 的优先级要高于 `Last-Modified/If-Modified-Since`。\n\n![Header 截图](https://ws2.sinaimg.cn/large/0069RVTdly1fv3rnvfn9sj317e0p6qae.jpg)\n\n从上文来看，`Cache-Control: must-revalidation` 或许是最优的缓存机制，不过由于支持度有限，而且有时候缓存策略跟业务逻辑有关，因此前端需要一种更自由，更定制化的缓存机制，因此 HTML5 的 App Cache 的出现，给广大前端开发者打了一大盆鸡血，不过事实如何呢？\n\n### 2.2 HTML5 性特性 —— App Cache\n\n![](https://ws3.sinaimg.cn/large/0069RVTdly1fv3qsgxvazj30hq09zmye.jpg)\n\n笔者在 2014 年开发 Hybrid 框架时，调研过 App Cache。虽然当时已经有了相应的标准（[WD-html5-20120329](https://www.w3.org/TR/2012/WD-html5-20120329/offline.html#offline) ），但当时浏览器对 App Cache 的支持程度很差，很多浏览器实现的方式也不同，让笔者很是苦恼。不过，经过这几年的发展，App Cache 的完善度越来越高，也有更多的开发者采用此技术。\n\nApp Cache 本质上是通过一个配置文件（`Manifest`）来决定访问资源的缓存策略，并提供相应的状态和事件让开发者可以有效利用它。\n\nApp Cache 配置文件如下：\n\n```\nCACHE MANIFEST\n\nCACHE:\n# 需要缓存的列表\nlocal.jpg\nstatic.js\nunupdate.css\n\nNETWORK:\n# 需要请求网络的资源\nnetwork.jpg\n\nFALLBACK:\n# 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件*.html /offline.html\nindex.html /404.html\n```\n\n在页面的 `html` 标签内加入，此配置文件，即可让 App Cache 生效。\n\n```\n<!DOCTYPE HTML>\n<html manifest=\"filename.appcache\">\n</html>\n```\n\n可见，配置中对不同资源的缓存策略进行了分别的定义。这样，开发可以自由控制不同文件的缓存策略，而不需要服务端针对不同的文件进行特殊的配置。为了让开发者可以对缓存中资源更新的情况有更多的了解，App Cache 方案给用户提供了 `cached` 、`checking` 、`downloading` 、`error` 、`noupdate` 、`obsolete` 、`progress` 、`updateready` 8个事件（`window.applicationCache.on('someEvent')`），以及 `status`（`window.applicationCache.status`）来标识它的状态。下图中，标识出每个事件的时机以及相应的 `status` 的取值。\n\n![App Cache 流程图](https://ws1.sinaimg.cn/large/0069RVTdly1fv3swsojzej30sa0sy0vf.jpg)\n\n此外，开发者还可以使用 `window.applicationCache.update()` 方法强制启动更新逻辑，使用 `window.applicationCache.abort()` 方法强制停止更新逻辑。\n\n从上文，看出 App Cache 提供一套配置化的缓存方案，通过配置来控制不同资源的缓存策略，但对在线更新并未提供太多机制和优化方案。而且 App Cache 与 Browser Cache 在逻辑上属于同一层次，对于它们之间如何协同工作，HTML5 的相关规范没有对具体细节给出非常明确的规定，同时，浏览器官方文档也没有给出非常明确的说明。这就造成在不同的浏览器，可能需要使用不同的配置和方案，来保证缓存策略的正确性，这样会使出错的几率上升。并且当出错时，你很有可能遇到计算机科学里面最难对付的两件事之一的缓存失效问题，甚至于只能让用户主动清除缓存才能解决问题。除去技术上的问题，一个项目使用 App Cache ，不仅仅需要前端开发人员，同时也需要服务端配合，这样让成本成倍增加，包括之后的维护成本也会成倍增加。总结下来，这些问题，都是 App Cache 没有被广泛使用的原因。\n\nApp Cache 看似盛宴，却又不堪，如何来真正解决资源更新和缓存问题？Google 推出的 PWA 方案给出了另一种思路。\n\n### 2.3 PWA 的大跨步 —— SW Cache\n\nPWA，全称是 Progressive Web App，渐进式 Web 应用。是 Google 2015 年提出，2016 年年中才着力推广的全新前端技术。其实与其说它是一项技术，还不如将它理解为一个方向，而这个方向的目标就是 **在 Web 应用中实现与原生应用相近的用户体验** 。\n\n![PWA VS Native](https://wx3.sinaimg.cn/mw690/71c50075ly1fvafqtz828j20m80b474t.jpg)\n\n官网上给出 PWA 宣传的重点词是 ： **Reliable** （ 可靠的 ）、**Fast**（ 快速的 ）、**Engaging**（ 可参与的 ）。\n\n![PWA](https://ws4.sinaimg.cn/large/006tNbRwly1fvacbdprvuj30fe066dg5.jpg)\n\n而为了实现这三个特点，让 Web 应用更贴近原生应用，PWA 优先提供了下面几个个关键技术（相信后面会不断补充更多的技术）：\n\n* `Manifest`：是一个 W3C 规范，它定义了一个基于 JSON 的配置文件，让 Web 应用可以和原生应用一样可以被安装，并在屏幕上有自己的入口。\n* `Push Notification`：接收服务端推送通知，一个“原生”应用必须有的功能。\n* `App Shell`: 先显示 Web 应用的主结构，再填充其他数据和结构，让加载过程更友好，用户体验更佳\n* `Service Worker`：另外的服务工作线程，在 Web 应用的后台执行，相比于 HTML5 提出的 Web Worker 功能更加强大。PWA 提供的新功能的逻辑，都需要在 Service Worker 中实现，例如下列基础功能：\n  * 管理 Web 应用生命周期（Manifest 的眼神）\n  * 消息推送（Push Notification 的实现）\n  * 不限域的获取或同步数据\n  * 接受计算密集型数据的更新，多页面共享该数据\n  * 拦截 Web 应用中的请求并做缓存。\n  * 等等 ......\n\n而列表中最后提到的，就是本文要谈到的 `SW Cache`，也就是 `Service Worker Cache`。就像 Service Worker 不是只用于 Cache 的，Service Worker Cache 也不是只用于静态资源缓存。它可以拦截 Web 应用所有请求，通过逻辑的实现，来配置自己的缓存策略，不仅仅能缓存静态资源，业务的动态数据接口也同样可以缓存。\n\n从 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API) 上可以找到 Service Worker 现在拥有的 API：\n\n![Server Worker API 列表](https://ws2.sinaimg.cn/large/006tNbRwly1fvam86ngcuj30dg0p2tb1.jpg)\n\n其中，用于缓存的是 `Cache` 和 `CacheStorage`，只需要下面在 Service Worker 内的一段代码即可实现页面资源的缓存，并在离线时可用。\n\n```\n// 缓存的ID，唯一性标识，用于缓存的控制\nconst CACHE_ID = \"v1.0.0\";\n\n// 为了保证线程不影响整个 Web 应用（同步 API 阻塞），Service Worker 中的 API 都是 Promise 的异步形式。\n// cacheStorage.open() 获取的 Cache 对象，就是从全局对象里取的 caches 对象，因此可以直接使用 caches 对象。\n\n// Service Worker 安装事件（并不是 Web 应用安装到手机上，可以看出 Service Worker 开始充初始化的事件）\nself.addEventListener('install', event => {\n    // event.waitUtil 用于在安装成功之前执行一些预装逻辑\n    // 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率\n    // 安装成功后 Service Worker 状态会从 installing 变为 installed\n    event.waitUntil(\n        // 使用 cache API 打开指定的 cache \n        caches.open(CACHE_ID).then(cache => {\n            // 添加要缓存的资源列表\n            return cache.addAll([\n                './static/example.js',\n                './static/example.css',\n                './static/404.jpg',\n                './index.html'\n            ]);\n        })\n    );\n});\n\n// Service Worker 激活时间，此事用于删除失效的缓存\nself.addEventListener('activate', function (event) {\n    event.waitUntil(\n        caches.keys().then(function (cacheIDs) {\n            return Promise.all(\n                cacheIDs.map(function (cacheID) {\n                    // 如果获取到的版本和缓存版本不一致，则删除相应缓存\n                    if (cacheID !== CACHE_ID) {\n                        return caches.delete(cacheID);\n                    }\n                })\n            );\n        })\n    );\n});\n\n// 拦截请求，做匹配，对于从线上请求的数据，将其缓存\nself.addEventListener('fetch', function (event) {\n    // 从缓存中匹配相应请求\n    event.respondWith(caches.match(event.request).catch(function () {\n        // 匹配失败，从线上请求\n        return fetch(event.request);\n    }).then(function (response) {\n        // 将请求结果缓存\n        caches.open(CACHE_ID).then(function (cache) {\n            cache.put(event.request, response);\n        });\n        return response.clone();\n    }).catch(function () {\n        // 发生错误，则从缓存里匹配相应的 Fallback 内容\n        return caches.match('./static/404.jpg');\n    }));\n});\n```\n\n从代码中可以看出不论是缓存的内容，还是缓存的管理，甚至添加缓存，都是由开发者实现代码来控制的，让更新和缓存逻辑完全掌控在开发者手里。上面的代码只是个基本逻辑，开发者可以根据自身的情况，设计出符合自身情况的逻辑，例如说，公共资源与业务资源分开，使用不同的缓存（不同的 CACHE_ID），等等。笔者只是在这里抛砖引玉，具体的情况还需要具体分析。\n\n上文，在谈到 App Cache 时，提到 App Cache 与 Browser Cache 互相影响，纠缠不清。那么，SW Cache 和 Browser Cache 又是什么关系呢？请看下图。\n\n![SW Cache](https://ws3.sinaimg.cn/large/0069RVTdly1fv3na9dpxjj30c7077dg5.jpg)\n\n相比于 Browser Cache ，SW Cache 更偏向于应用层，和 Browser Cache 是串行关系。**SW Cache 匹配失败的资源请求线上时，仍旧会走 Browser Cache。** 因此，对于 Browser Cache 的服务端，只要不将缓存时间设置过长，就不会影响 SW Cache 的使用。\n\n总之，SW Cache 是一个想简单也异常简单，想复杂也可以复杂的开发者可控的缓存机制，可以让开发者根据资深情况定制不同的缓存策略。\n\n### 3. 总结\n\n这一部分，主要讲了 Web 缓存，从浏览器缓存到 HTML5 的 App Cache，再到跨时代技术 PWA 的 SW Cache。与硬件或系统缓存不同，Web 缓存是最早运用在用户端应用层的缓存策略，从浏览器缓存的前端不可控，到 App Cache、SW Cache 方案中前端有一定的控制权，策略的改变体现了开发者对用户端缓存给予了越来越多的重视。\n\n谈到缓存，就不得不谈到另一个概念 —— **热更新**。Web 应用与传统的原生应用项目，最大的优势在于可以非常及时地使用到最新版本的应用，而不是像传统原生应用一样，必须删除应用后再从应用市场下载进行重装，其操作和时间成本都很高，尤其在细微的更新或者修复 Bug 时。因此，越来越多的原生应用参考 Web 应用的缓存策略，实现自己的资源热更新机制，让绝大多数资源的更新不需要通过应用市场来更新应用，而是通过自身的机制进行更新，降低用户的升级成本。其中，在游戏方面，由于游戏应用体积一般较大，不便于每次小调整都要从应用市场更新应用，因此，使用资源的热更新机制成为了不二选择。下图就是游戏《王者荣耀》的资源更新界面。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fvbg4nmz78j31kw0w0x6z.jpg)\n\n最后做个简单的总结：Web 缓存策略是广泛应用在每一个 Web 应用中，深入理解 Web 缓存策略有利于去优化 Web 应用的性能、提高 Web 应用的使用体验。同时，也有助于理解或设计原生客户端中的热更新策略，毕竟 Web 缓存策略是应用最广泛的，而所有新生的客户端热更新策略都会借鉴其经验。","source":"_posts/2018-10-10-深入Web缓存策略.md","raw":"title: 深入 Web 缓存策略\ndate: 2018-10-10 12:00:00\ncategory: 大前端技术\ntags: [资源更新, 缓存]\nthumbnailImage: https://ws4.sinaimg.cn/large/006tNbRwly1fuzvbbtcb0j30s60do407.jpg\n---\n\n移动互联网时代，各种互联网技术层出不穷，尤其在移动端方面，各种动态化方案如雨后春笋般，在各自的领域蓬勃生长。但是，不管哪种方案，都会涉及到资源的迭代更新问题。如何让用户在更快地使用最新资源的同时，也能结合缓存保证应用的加载效率，是这类方案必须要考虑的。本文将从浏览器缓存谈起，在涵盖 App Cache、SW Cache 等纯 Web 缓存方案的同时，也将站在大前端角度去分析不同方案的差异，最终，让大家对 web 缓存策略有一个详尽的了解。<!-- more -->\n\n## 1. 资源更新与缓存\n\n从互联网开始向大众普及，Web 技术就成为不能缺少的一部分，其资源控制权，也从用户端转向服务端，由服务端响应客户端的请求，并推送最新的资源。理论上，可以让用户每次都能使用到最新的资源，从而让产品迭代更快速、更有效。但是，这样的逻辑也带来了一些很严重的问题：\n\n* 当无网时，用户端取不到相应的资源，导致产品不可用。\n* 当弱网时，用户端获取资源速度很低，使产品加载缓慢，最终导致产品体验很差。 \n\n为了解决此类问题，必须要引入资源的本地暂存机制，也就是通常说的 —— **缓存**。缓存的出现，始于计算机对性能的要求。计算机为了在性能上能有指数级的增长，引入了缓存设计。简单说，存储和读取速度和硬件的成本成正比：相同空间的存储硬件，存取越快，成本越高。下图说明了计算机中缓存的设计，会分很多不同层级的缓存，当然内存也可以算作缓存的一种。\n\n![缓存设计](https://ws1.sinaimg.cn/large/0069RVTdly1fv3lc27kpbj30go06y74t.jpg)\n\n所以为了权衡，两者相结合，使得性价比最大。而这篇文章里主要讨论的是偏向用户端的缓存，与传统缓存类似，虽然缓存运用得越广泛，用户的体验越好，但同时也增加了相应的维护成本。\n\nPhil Karlton 说过一句广受大家共鸣的一句话：“There are only two hard things in Computer Science: cache invalidation and naming things.（命名和缓存失效是计算机科学里面最难对付的两件事）”，可以看出缓存是大家很难去维护但不得不去维护的策略。只要存在缓存，就能得到性能和体验上的提升；而在合适的时机删除之前缓存的资源并更新最新资源，却是一个很难完美解决的问题。\n\n当前缓存运用的场景，除了计算机硬件及系统以外，主要在数据库和网络资源两个主要方向。而其中，网络资源更多运用在用户端，尤其在 Web 技术中，浏览器基于网络协议配置的缓存是最常见，同时也是最贴近用户的使用场景。因此，为了让大家更好地了解缓存策略的细节，笔者将从 Web 缓存谈起。\n\n## 2. Web 缓存\n\n之前，大家提到 Web 缓存，大多是指浏览器缓存。但随着 HTML5 的发展（App Cache）以及 PWA 技术的推广（SW Cache），前端工程师可以可以自由控制浏览器对资源的缓存。Web 缓存从服务端配置化逐渐演变为用户端逻辑化，从由浏览器自动控制到由工程师自主设计，使资源更新更灵活，但也带来一些不易解决的问题。\n\n下面，从最传统的浏览器缓存谈起，深入了解资源缓存的细节。\n\n### 2.1 浏览器缓存 —— Browser Cache（HTTP 客户端缓存）\n\n现在的大型网站，不管是 PC 端还是移动端，动不动就几十个请求，如果没有浏览器缓存的存在，用户体验会急剧下降，同时服务器压力和网络带宽都将面临严重的考验。因此，浏览器缓存是现代互联网中必不可少的一环。\n\n从技术角度讲，浏览器缓存是 HTTP 缓存机制中客户端部分的一个实现。\n\nHTTP 缓存机制分为两种，**客户端缓存** 和 **服务端缓存** ，而服务端缓存又分为 **代理服务器缓存**（例：CDN 服务）和 **反向代理服务器缓存**（例：Nginx 反向代理服务）。由于篇幅有限，服务端缓存部分就不加赘述了。\n\n关于客户端缓存，浏览器缓存是其中的一种实现形式，在浏览器内核中实现基于 HTTP 缓存机制的缓存。当然，在各类网络请求的开发库中，也实现了几乎同样的逻辑。这些逻辑，都是基于 HTTP 协议中的 HEADER 来实现的，根据  HEADER 中相应配置的不同，执行不同的缓存逻辑。\n\n![HTTP 报文结构](https://ws1.sinaimg.cn/large/0069RVTdly1fv3nmog9rpj30dw05twf1.jpg)\n\n对于客户端整体缓存逻辑，大家应该比较清楚：判断是否有缓存，如果有就直接使用缓存中的内容，如果没有则进行网络请求获取内容。（如下图）\n\n![HTTP 客户端整体缓存逻辑](https://ws3.sinaimg.cn/large/0069RVTdly1fv3nw5x397j30lb09amxe.jpg)\n\n但是客户端怎么根据 HTTP 的 HEADER 来更为细化地控制缓存的呢？其实 HTTP 客户端缓存有两种不同的策略机制：\n\n* **服务端决策缓存**：由服务端决定并告知客户端是否使用缓存。\n* **客户端决策缓存**：服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。\n\n对于这两种策略机制的区别，最明显的表象是：从 Chrome DevTool 中 Network 面板里看到缓存的请求，服务端决策缓存在 Status 一栏显示的是 `304`，而客户端决策缓存在 Status 一栏显示的是 `200`，不过在 Size 一栏会显示 `from disk cache`。这两种策略机制，从解释中就可以看出，区别在于上图中的检查是否有缓存的部分。\n\n道上常说，有图有真相，所以先把两种策略机制的流程图奉上，每种策略机制都分有 **缓存命中** 和 **缓存未命中** 两种情况。\n\n![HTTP 客户端缓存策略流程图](https://ws2.sinaimg.cn/large/0069RVTdly1fv3pcj7k4ej30qo0ub76e.jpg)\n\n这两种缓存策略机制主要是由 HTTP Header 中的 `Cache-Control` 来决定和控制使用的。此属性常见的取值有以下6类：\n\n* `public`：全部缓存，包括客户端和服务端（时长 365 天）\n* `private`：仅客户端缓存（时长 365 天）\n* `no-cache`：不适用客户端的缓存，使用“服务端决策缓存”。并不是表面意义上的“不使用缓存”。\n* `no-store`：所有内容都不会被缓存，不论哪种策略机制都不会被缓存。不同浏览器对这种情况的实现不同，有些浏览器是不缓存，有些是在特定实际清除缓存，例如当前页面关闭、浏览器关闭等。\n* `must-revalidation/proxy-revalidation`：如果缓存内容失效，请求必须发送服务器/代理进行验证。也就是当“客户端决策缓存”未命中时，使用“服务端决策缓存”，理论上是最优的缓存策略。不过，只有最新的部分浏览器和网络库支持此配置，还未普及。\n* `max-age=<s>`：缓存内容在s秒后失效，仅 HTTP 1.1 可用。（HTTP 1.0 可以用 `Expires`）\n\n其中，对于前端资源，最常用的是 `Cache-Control: no-cache` 和 `Cache-Control: max-age=123`，分别对应笔者上文提到的两种策略机制。而对于数据请求，一般使用 `Cache-Control: no-store` 来保证每次数据都是新的，而由于前文提到 `no-store` 的实现方式有异，最好还是加随机参数来避免缓存。\n\n当然，`Cache-Control` 不仅仅这六类取值，更多的可以直接查看 HTTP 1.1 协议文档 [rfc2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)。\n\n在上面的流程图中，提到了“缓存标识”，此标识也是使用 HTTP Header 进行通信的，可以使用 `Etag/If-None-Match` 或 `Last-Modified/If-Modified-Since` 对资源进行标识，前者是资源的特征值，也可看做为标识符，而后者则是资源的更新时间。具体使用哪个，由服务端获取特征值和修改时间的效率决定，使用效率较好的一个。当然，这两个标识可以同时使用，此时 `Etag/If-None-Match` 的优先级要高于 `Last-Modified/If-Modified-Since`。\n\n![Header 截图](https://ws2.sinaimg.cn/large/0069RVTdly1fv3rnvfn9sj317e0p6qae.jpg)\n\n从上文来看，`Cache-Control: must-revalidation` 或许是最优的缓存机制，不过由于支持度有限，而且有时候缓存策略跟业务逻辑有关，因此前端需要一种更自由，更定制化的缓存机制，因此 HTML5 的 App Cache 的出现，给广大前端开发者打了一大盆鸡血，不过事实如何呢？\n\n### 2.2 HTML5 性特性 —— App Cache\n\n![](https://ws3.sinaimg.cn/large/0069RVTdly1fv3qsgxvazj30hq09zmye.jpg)\n\n笔者在 2014 年开发 Hybrid 框架时，调研过 App Cache。虽然当时已经有了相应的标准（[WD-html5-20120329](https://www.w3.org/TR/2012/WD-html5-20120329/offline.html#offline) ），但当时浏览器对 App Cache 的支持程度很差，很多浏览器实现的方式也不同，让笔者很是苦恼。不过，经过这几年的发展，App Cache 的完善度越来越高，也有更多的开发者采用此技术。\n\nApp Cache 本质上是通过一个配置文件（`Manifest`）来决定访问资源的缓存策略，并提供相应的状态和事件让开发者可以有效利用它。\n\nApp Cache 配置文件如下：\n\n```\nCACHE MANIFEST\n\nCACHE:\n# 需要缓存的列表\nlocal.jpg\nstatic.js\nunupdate.css\n\nNETWORK:\n# 需要请求网络的资源\nnetwork.jpg\n\nFALLBACK:\n# 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件*.html /offline.html\nindex.html /404.html\n```\n\n在页面的 `html` 标签内加入，此配置文件，即可让 App Cache 生效。\n\n```\n<!DOCTYPE HTML>\n<html manifest=\"filename.appcache\">\n</html>\n```\n\n可见，配置中对不同资源的缓存策略进行了分别的定义。这样，开发可以自由控制不同文件的缓存策略，而不需要服务端针对不同的文件进行特殊的配置。为了让开发者可以对缓存中资源更新的情况有更多的了解，App Cache 方案给用户提供了 `cached` 、`checking` 、`downloading` 、`error` 、`noupdate` 、`obsolete` 、`progress` 、`updateready` 8个事件（`window.applicationCache.on('someEvent')`），以及 `status`（`window.applicationCache.status`）来标识它的状态。下图中，标识出每个事件的时机以及相应的 `status` 的取值。\n\n![App Cache 流程图](https://ws1.sinaimg.cn/large/0069RVTdly1fv3swsojzej30sa0sy0vf.jpg)\n\n此外，开发者还可以使用 `window.applicationCache.update()` 方法强制启动更新逻辑，使用 `window.applicationCache.abort()` 方法强制停止更新逻辑。\n\n从上文，看出 App Cache 提供一套配置化的缓存方案，通过配置来控制不同资源的缓存策略，但对在线更新并未提供太多机制和优化方案。而且 App Cache 与 Browser Cache 在逻辑上属于同一层次，对于它们之间如何协同工作，HTML5 的相关规范没有对具体细节给出非常明确的规定，同时，浏览器官方文档也没有给出非常明确的说明。这就造成在不同的浏览器，可能需要使用不同的配置和方案，来保证缓存策略的正确性，这样会使出错的几率上升。并且当出错时，你很有可能遇到计算机科学里面最难对付的两件事之一的缓存失效问题，甚至于只能让用户主动清除缓存才能解决问题。除去技术上的问题，一个项目使用 App Cache ，不仅仅需要前端开发人员，同时也需要服务端配合，这样让成本成倍增加，包括之后的维护成本也会成倍增加。总结下来，这些问题，都是 App Cache 没有被广泛使用的原因。\n\nApp Cache 看似盛宴，却又不堪，如何来真正解决资源更新和缓存问题？Google 推出的 PWA 方案给出了另一种思路。\n\n### 2.3 PWA 的大跨步 —— SW Cache\n\nPWA，全称是 Progressive Web App，渐进式 Web 应用。是 Google 2015 年提出，2016 年年中才着力推广的全新前端技术。其实与其说它是一项技术，还不如将它理解为一个方向，而这个方向的目标就是 **在 Web 应用中实现与原生应用相近的用户体验** 。\n\n![PWA VS Native](https://wx3.sinaimg.cn/mw690/71c50075ly1fvafqtz828j20m80b474t.jpg)\n\n官网上给出 PWA 宣传的重点词是 ： **Reliable** （ 可靠的 ）、**Fast**（ 快速的 ）、**Engaging**（ 可参与的 ）。\n\n![PWA](https://ws4.sinaimg.cn/large/006tNbRwly1fvacbdprvuj30fe066dg5.jpg)\n\n而为了实现这三个特点，让 Web 应用更贴近原生应用，PWA 优先提供了下面几个个关键技术（相信后面会不断补充更多的技术）：\n\n* `Manifest`：是一个 W3C 规范，它定义了一个基于 JSON 的配置文件，让 Web 应用可以和原生应用一样可以被安装，并在屏幕上有自己的入口。\n* `Push Notification`：接收服务端推送通知，一个“原生”应用必须有的功能。\n* `App Shell`: 先显示 Web 应用的主结构，再填充其他数据和结构，让加载过程更友好，用户体验更佳\n* `Service Worker`：另外的服务工作线程，在 Web 应用的后台执行，相比于 HTML5 提出的 Web Worker 功能更加强大。PWA 提供的新功能的逻辑，都需要在 Service Worker 中实现，例如下列基础功能：\n  * 管理 Web 应用生命周期（Manifest 的眼神）\n  * 消息推送（Push Notification 的实现）\n  * 不限域的获取或同步数据\n  * 接受计算密集型数据的更新，多页面共享该数据\n  * 拦截 Web 应用中的请求并做缓存。\n  * 等等 ......\n\n而列表中最后提到的，就是本文要谈到的 `SW Cache`，也就是 `Service Worker Cache`。就像 Service Worker 不是只用于 Cache 的，Service Worker Cache 也不是只用于静态资源缓存。它可以拦截 Web 应用所有请求，通过逻辑的实现，来配置自己的缓存策略，不仅仅能缓存静态资源，业务的动态数据接口也同样可以缓存。\n\n从 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API) 上可以找到 Service Worker 现在拥有的 API：\n\n![Server Worker API 列表](https://ws2.sinaimg.cn/large/006tNbRwly1fvam86ngcuj30dg0p2tb1.jpg)\n\n其中，用于缓存的是 `Cache` 和 `CacheStorage`，只需要下面在 Service Worker 内的一段代码即可实现页面资源的缓存，并在离线时可用。\n\n```\n// 缓存的ID，唯一性标识，用于缓存的控制\nconst CACHE_ID = \"v1.0.0\";\n\n// 为了保证线程不影响整个 Web 应用（同步 API 阻塞），Service Worker 中的 API 都是 Promise 的异步形式。\n// cacheStorage.open() 获取的 Cache 对象，就是从全局对象里取的 caches 对象，因此可以直接使用 caches 对象。\n\n// Service Worker 安装事件（并不是 Web 应用安装到手机上，可以看出 Service Worker 开始充初始化的事件）\nself.addEventListener('install', event => {\n    // event.waitUtil 用于在安装成功之前执行一些预装逻辑\n    // 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率\n    // 安装成功后 Service Worker 状态会从 installing 变为 installed\n    event.waitUntil(\n        // 使用 cache API 打开指定的 cache \n        caches.open(CACHE_ID).then(cache => {\n            // 添加要缓存的资源列表\n            return cache.addAll([\n                './static/example.js',\n                './static/example.css',\n                './static/404.jpg',\n                './index.html'\n            ]);\n        })\n    );\n});\n\n// Service Worker 激活时间，此事用于删除失效的缓存\nself.addEventListener('activate', function (event) {\n    event.waitUntil(\n        caches.keys().then(function (cacheIDs) {\n            return Promise.all(\n                cacheIDs.map(function (cacheID) {\n                    // 如果获取到的版本和缓存版本不一致，则删除相应缓存\n                    if (cacheID !== CACHE_ID) {\n                        return caches.delete(cacheID);\n                    }\n                })\n            );\n        })\n    );\n});\n\n// 拦截请求，做匹配，对于从线上请求的数据，将其缓存\nself.addEventListener('fetch', function (event) {\n    // 从缓存中匹配相应请求\n    event.respondWith(caches.match(event.request).catch(function () {\n        // 匹配失败，从线上请求\n        return fetch(event.request);\n    }).then(function (response) {\n        // 将请求结果缓存\n        caches.open(CACHE_ID).then(function (cache) {\n            cache.put(event.request, response);\n        });\n        return response.clone();\n    }).catch(function () {\n        // 发生错误，则从缓存里匹配相应的 Fallback 内容\n        return caches.match('./static/404.jpg');\n    }));\n});\n```\n\n从代码中可以看出不论是缓存的内容，还是缓存的管理，甚至添加缓存，都是由开发者实现代码来控制的，让更新和缓存逻辑完全掌控在开发者手里。上面的代码只是个基本逻辑，开发者可以根据自身的情况，设计出符合自身情况的逻辑，例如说，公共资源与业务资源分开，使用不同的缓存（不同的 CACHE_ID），等等。笔者只是在这里抛砖引玉，具体的情况还需要具体分析。\n\n上文，在谈到 App Cache 时，提到 App Cache 与 Browser Cache 互相影响，纠缠不清。那么，SW Cache 和 Browser Cache 又是什么关系呢？请看下图。\n\n![SW Cache](https://ws3.sinaimg.cn/large/0069RVTdly1fv3na9dpxjj30c7077dg5.jpg)\n\n相比于 Browser Cache ，SW Cache 更偏向于应用层，和 Browser Cache 是串行关系。**SW Cache 匹配失败的资源请求线上时，仍旧会走 Browser Cache。** 因此，对于 Browser Cache 的服务端，只要不将缓存时间设置过长，就不会影响 SW Cache 的使用。\n\n总之，SW Cache 是一个想简单也异常简单，想复杂也可以复杂的开发者可控的缓存机制，可以让开发者根据资深情况定制不同的缓存策略。\n\n### 3. 总结\n\n这一部分，主要讲了 Web 缓存，从浏览器缓存到 HTML5 的 App Cache，再到跨时代技术 PWA 的 SW Cache。与硬件或系统缓存不同，Web 缓存是最早运用在用户端应用层的缓存策略，从浏览器缓存的前端不可控，到 App Cache、SW Cache 方案中前端有一定的控制权，策略的改变体现了开发者对用户端缓存给予了越来越多的重视。\n\n谈到缓存，就不得不谈到另一个概念 —— **热更新**。Web 应用与传统的原生应用项目，最大的优势在于可以非常及时地使用到最新版本的应用，而不是像传统原生应用一样，必须删除应用后再从应用市场下载进行重装，其操作和时间成本都很高，尤其在细微的更新或者修复 Bug 时。因此，越来越多的原生应用参考 Web 应用的缓存策略，实现自己的资源热更新机制，让绝大多数资源的更新不需要通过应用市场来更新应用，而是通过自身的机制进行更新，降低用户的升级成本。其中，在游戏方面，由于游戏应用体积一般较大，不便于每次小调整都要从应用市场更新应用，因此，使用资源的热更新机制成为了不二选择。下图就是游戏《王者荣耀》的资源更新界面。\n\n![](https://ws3.sinaimg.cn/large/006tNbRwly1fvbg4nmz78j31kw0w0x6z.jpg)\n\n最后做个简单的总结：Web 缓存策略是广泛应用在每一个 Web 应用中，深入理解 Web 缓存策略有利于去优化 Web 应用的性能、提高 Web 应用的使用体验。同时，也有助于理解或设计原生客户端中的热更新策略，毕竟 Web 缓存策略是应用最广泛的，而所有新生的客户端热更新策略都会借鉴其经验。","slug":"2018-10-10-深入Web缓存策略","published":1,"updated":"2018-10-10T12:39:56.953Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc7b000yhxp4g1ydqsg7","content":"<p>移动互联网时代，各种互联网技术层出不穷，尤其在移动端方面，各种动态化方案如雨后春笋般，在各自的领域蓬勃生长。但是，不管哪种方案，都会涉及到资源的迭代更新问题。如何让用户在更快地使用最新资源的同时，也能结合缓存保证应用的加载效率，是这类方案必须要考虑的。本文将从浏览器缓存谈起，在涵盖 App Cache、SW Cache 等纯 Web 缓存方案的同时，也将站在大前端角度去分析不同方案的差异，最终，让大家对 web 缓存策略有一个详尽的了解。<a id=\"more\"></a></p>\n<h2 id=\"1-资源更新与缓存\"><a href=\"#1-资源更新与缓存\" class=\"headerlink\" title=\"1. 资源更新与缓存\"></a>1. 资源更新与缓存</h2><p>从互联网开始向大众普及，Web 技术就成为不能缺少的一部分，其资源控制权，也从用户端转向服务端，由服务端响应客户端的请求，并推送最新的资源。理论上，可以让用户每次都能使用到最新的资源，从而让产品迭代更快速、更有效。但是，这样的逻辑也带来了一些很严重的问题：</p>\n<ul>\n<li>当无网时，用户端取不到相应的资源，导致产品不可用。</li>\n<li>当弱网时，用户端获取资源速度很低，使产品加载缓慢，最终导致产品体验很差。 </li>\n</ul>\n<p>为了解决此类问题，必须要引入资源的本地暂存机制，也就是通常说的 —— <strong>缓存</strong>。缓存的出现，始于计算机对性能的要求。计算机为了在性能上能有指数级的增长，引入了缓存设计。简单说，存储和读取速度和硬件的成本成正比：相同空间的存储硬件，存取越快，成本越高。下图说明了计算机中缓存的设计，会分很多不同层级的缓存，当然内存也可以算作缓存的一种。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fv3lc27kpbj30go06y74t.jpg\" alt=\"缓存设计\"></p>\n<p>所以为了权衡，两者相结合，使得性价比最大。而这篇文章里主要讨论的是偏向用户端的缓存，与传统缓存类似，虽然缓存运用得越广泛，用户的体验越好，但同时也增加了相应的维护成本。</p>\n<p>Phil Karlton 说过一句广受大家共鸣的一句话：“There are only two hard things in Computer Science: cache invalidation and naming things.（命名和缓存失效是计算机科学里面最难对付的两件事）”，可以看出缓存是大家很难去维护但不得不去维护的策略。只要存在缓存，就能得到性能和体验上的提升；而在合适的时机删除之前缓存的资源并更新最新资源，却是一个很难完美解决的问题。</p>\n<p>当前缓存运用的场景，除了计算机硬件及系统以外，主要在数据库和网络资源两个主要方向。而其中，网络资源更多运用在用户端，尤其在 Web 技术中，浏览器基于网络协议配置的缓存是最常见，同时也是最贴近用户的使用场景。因此，为了让大家更好地了解缓存策略的细节，笔者将从 Web 缓存谈起。</p>\n<h2 id=\"2-Web-缓存\"><a href=\"#2-Web-缓存\" class=\"headerlink\" title=\"2. Web 缓存\"></a>2. Web 缓存</h2><p>之前，大家提到 Web 缓存，大多是指浏览器缓存。但随着 HTML5 的发展（App Cache）以及 PWA 技术的推广（SW Cache），前端工程师可以可以自由控制浏览器对资源的缓存。Web 缓存从服务端配置化逐渐演变为用户端逻辑化，从由浏览器自动控制到由工程师自主设计，使资源更新更灵活，但也带来一些不易解决的问题。</p>\n<p>下面，从最传统的浏览器缓存谈起，深入了解资源缓存的细节。</p>\n<h3 id=\"2-1-浏览器缓存-——-Browser-Cache（HTTP-客户端缓存）\"><a href=\"#2-1-浏览器缓存-——-Browser-Cache（HTTP-客户端缓存）\" class=\"headerlink\" title=\"2.1 浏览器缓存 —— Browser Cache（HTTP 客户端缓存）\"></a>2.1 浏览器缓存 —— Browser Cache（HTTP 客户端缓存）</h3><p>现在的大型网站，不管是 PC 端还是移动端，动不动就几十个请求，如果没有浏览器缓存的存在，用户体验会急剧下降，同时服务器压力和网络带宽都将面临严重的考验。因此，浏览器缓存是现代互联网中必不可少的一环。</p>\n<p>从技术角度讲，浏览器缓存是 HTTP 缓存机制中客户端部分的一个实现。</p>\n<p>HTTP 缓存机制分为两种，<strong>客户端缓存</strong> 和 <strong>服务端缓存</strong> ，而服务端缓存又分为 <strong>代理服务器缓存</strong>（例：CDN 服务）和 <strong>反向代理服务器缓存</strong>（例：Nginx 反向代理服务）。由于篇幅有限，服务端缓存部分就不加赘述了。</p>\n<p>关于客户端缓存，浏览器缓存是其中的一种实现形式，在浏览器内核中实现基于 HTTP 缓存机制的缓存。当然，在各类网络请求的开发库中，也实现了几乎同样的逻辑。这些逻辑，都是基于 HTTP 协议中的 HEADER 来实现的，根据  HEADER 中相应配置的不同，执行不同的缓存逻辑。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fv3nmog9rpj30dw05twf1.jpg\" alt=\"HTTP 报文结构\"></p>\n<p>对于客户端整体缓存逻辑，大家应该比较清楚：判断是否有缓存，如果有就直接使用缓存中的内容，如果没有则进行网络请求获取内容。（如下图）</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fv3nw5x397j30lb09amxe.jpg\" alt=\"HTTP 客户端整体缓存逻辑\"></p>\n<p>但是客户端怎么根据 HTTP 的 HEADER 来更为细化地控制缓存的呢？其实 HTTP 客户端缓存有两种不同的策略机制：</p>\n<ul>\n<li><strong>服务端决策缓存</strong>：由服务端决定并告知客户端是否使用缓存。</li>\n<li><strong>客户端决策缓存</strong>：服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。</li>\n</ul>\n<p>对于这两种策略机制的区别，最明显的表象是：从 Chrome DevTool 中 Network 面板里看到缓存的请求，服务端决策缓存在 Status 一栏显示的是 <code>304</code>，而客户端决策缓存在 Status 一栏显示的是 <code>200</code>，不过在 Size 一栏会显示 <code>from disk cache</code>。这两种策略机制，从解释中就可以看出，区别在于上图中的检查是否有缓存的部分。</p>\n<p>道上常说，有图有真相，所以先把两种策略机制的流程图奉上，每种策略机制都分有 <strong>缓存命中</strong> 和 <strong>缓存未命中</strong> 两种情况。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fv3pcj7k4ej30qo0ub76e.jpg\" alt=\"HTTP 客户端缓存策略流程图\"></p>\n<p>这两种缓存策略机制主要是由 HTTP Header 中的 <code>Cache-Control</code> 来决定和控制使用的。此属性常见的取值有以下6类：</p>\n<ul>\n<li><code>public</code>：全部缓存，包括客户端和服务端（时长 365 天）</li>\n<li><code>private</code>：仅客户端缓存（时长 365 天）</li>\n<li><code>no-cache</code>：不适用客户端的缓存，使用“服务端决策缓存”。并不是表面意义上的“不使用缓存”。</li>\n<li><code>no-store</code>：所有内容都不会被缓存，不论哪种策略机制都不会被缓存。不同浏览器对这种情况的实现不同，有些浏览器是不缓存，有些是在特定实际清除缓存，例如当前页面关闭、浏览器关闭等。</li>\n<li><code>must-revalidation/proxy-revalidation</code>：如果缓存内容失效，请求必须发送服务器/代理进行验证。也就是当“客户端决策缓存”未命中时，使用“服务端决策缓存”，理论上是最优的缓存策略。不过，只有最新的部分浏览器和网络库支持此配置，还未普及。</li>\n<li><code>max-age=&lt;s&gt;</code>：缓存内容在s秒后失效，仅 HTTP 1.1 可用。（HTTP 1.0 可以用 <code>Expires</code>）</li>\n</ul>\n<p>其中，对于前端资源，最常用的是 <code>Cache-Control: no-cache</code> 和 <code>Cache-Control: max-age=123</code>，分别对应笔者上文提到的两种策略机制。而对于数据请求，一般使用 <code>Cache-Control: no-store</code> 来保证每次数据都是新的，而由于前文提到 <code>no-store</code> 的实现方式有异，最好还是加随机参数来避免缓存。</p>\n<p>当然，<code>Cache-Control</code> 不仅仅这六类取值，更多的可以直接查看 HTTP 1.1 协议文档 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9\" target=\"_blank\" rel=\"noopener\">rfc2616</a>。</p>\n<p>在上面的流程图中，提到了“缓存标识”，此标识也是使用 HTTP Header 进行通信的，可以使用 <code>Etag/If-None-Match</code> 或 <code>Last-Modified/If-Modified-Since</code> 对资源进行标识，前者是资源的特征值，也可看做为标识符，而后者则是资源的更新时间。具体使用哪个，由服务端获取特征值和修改时间的效率决定，使用效率较好的一个。当然，这两个标识可以同时使用，此时 <code>Etag/If-None-Match</code> 的优先级要高于 <code>Last-Modified/If-Modified-Since</code>。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fv3rnvfn9sj317e0p6qae.jpg\" alt=\"Header 截图\"></p>\n<p>从上文来看，<code>Cache-Control: must-revalidation</code> 或许是最优的缓存机制，不过由于支持度有限，而且有时候缓存策略跟业务逻辑有关，因此前端需要一种更自由，更定制化的缓存机制，因此 HTML5 的 App Cache 的出现，给广大前端开发者打了一大盆鸡血，不过事实如何呢？</p>\n<h3 id=\"2-2-HTML5-性特性-——-App-Cache\"><a href=\"#2-2-HTML5-性特性-——-App-Cache\" class=\"headerlink\" title=\"2.2 HTML5 性特性 —— App Cache\"></a>2.2 HTML5 性特性 —— App Cache</h3><p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fv3qsgxvazj30hq09zmye.jpg\" alt=\"\"></p>\n<p>笔者在 2014 年开发 Hybrid 框架时，调研过 App Cache。虽然当时已经有了相应的标准（<a href=\"https://www.w3.org/TR/2012/WD-html5-20120329/offline.html#offline\" target=\"_blank\" rel=\"noopener\">WD-html5-20120329</a> ），但当时浏览器对 App Cache 的支持程度很差，很多浏览器实现的方式也不同，让笔者很是苦恼。不过，经过这几年的发展，App Cache 的完善度越来越高，也有更多的开发者采用此技术。</p>\n<p>App Cache 本质上是通过一个配置文件（<code>Manifest</code>）来决定访问资源的缓存策略，并提供相应的状态和事件让开发者可以有效利用它。</p>\n<p>App Cache 配置文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\"># 需要缓存的列表</span><br><span class=\"line\">local.jpg</span><br><span class=\"line\">static.js</span><br><span class=\"line\">unupdate.css</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\"># 需要请求网络的资源</span><br><span class=\"line\">network.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\"># 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件*.html /offline.html</span><br><span class=\"line\">index.html /404.html</span><br></pre></td></tr></table></figure>\n<p>在页面的 <code>html</code> 标签内加入，此配置文件，即可让 App Cache 生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html manifest=&quot;filename.appcache&quot;&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>可见，配置中对不同资源的缓存策略进行了分别的定义。这样，开发可以自由控制不同文件的缓存策略，而不需要服务端针对不同的文件进行特殊的配置。为了让开发者可以对缓存中资源更新的情况有更多的了解，App Cache 方案给用户提供了 <code>cached</code> 、<code>checking</code> 、<code>downloading</code> 、<code>error</code> 、<code>noupdate</code> 、<code>obsolete</code> 、<code>progress</code> 、<code>updateready</code> 8个事件（<code>window.applicationCache.on(&#39;someEvent&#39;)</code>），以及 <code>status</code>（<code>window.applicationCache.status</code>）来标识它的状态。下图中，标识出每个事件的时机以及相应的 <code>status</code> 的取值。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fv3swsojzej30sa0sy0vf.jpg\" alt=\"App Cache 流程图\"></p>\n<p>此外，开发者还可以使用 <code>window.applicationCache.update()</code> 方法强制启动更新逻辑，使用 <code>window.applicationCache.abort()</code> 方法强制停止更新逻辑。</p>\n<p>从上文，看出 App Cache 提供一套配置化的缓存方案，通过配置来控制不同资源的缓存策略，但对在线更新并未提供太多机制和优化方案。而且 App Cache 与 Browser Cache 在逻辑上属于同一层次，对于它们之间如何协同工作，HTML5 的相关规范没有对具体细节给出非常明确的规定，同时，浏览器官方文档也没有给出非常明确的说明。这就造成在不同的浏览器，可能需要使用不同的配置和方案，来保证缓存策略的正确性，这样会使出错的几率上升。并且当出错时，你很有可能遇到计算机科学里面最难对付的两件事之一的缓存失效问题，甚至于只能让用户主动清除缓存才能解决问题。除去技术上的问题，一个项目使用 App Cache ，不仅仅需要前端开发人员，同时也需要服务端配合，这样让成本成倍增加，包括之后的维护成本也会成倍增加。总结下来，这些问题，都是 App Cache 没有被广泛使用的原因。</p>\n<p>App Cache 看似盛宴，却又不堪，如何来真正解决资源更新和缓存问题？Google 推出的 PWA 方案给出了另一种思路。</p>\n<h3 id=\"2-3-PWA-的大跨步-——-SW-Cache\"><a href=\"#2-3-PWA-的大跨步-——-SW-Cache\" class=\"headerlink\" title=\"2.3 PWA 的大跨步 —— SW Cache\"></a>2.3 PWA 的大跨步 —— SW Cache</h3><p>PWA，全称是 Progressive Web App，渐进式 Web 应用。是 Google 2015 年提出，2016 年年中才着力推广的全新前端技术。其实与其说它是一项技术，还不如将它理解为一个方向，而这个方向的目标就是 <strong>在 Web 应用中实现与原生应用相近的用户体验</strong> 。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/71c50075ly1fvafqtz828j20m80b474t.jpg\" alt=\"PWA VS Native\"></p>\n<p>官网上给出 PWA 宣传的重点词是 ： <strong>Reliable</strong> （ 可靠的 ）、<strong>Fast</strong>（ 快速的 ）、<strong>Engaging</strong>（ 可参与的 ）。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fvacbdprvuj30fe066dg5.jpg\" alt=\"PWA\"></p>\n<p>而为了实现这三个特点，让 Web 应用更贴近原生应用，PWA 优先提供了下面几个个关键技术（相信后面会不断补充更多的技术）：</p>\n<ul>\n<li><code>Manifest</code>：是一个 W3C 规范，它定义了一个基于 JSON 的配置文件，让 Web 应用可以和原生应用一样可以被安装，并在屏幕上有自己的入口。</li>\n<li><code>Push Notification</code>：接收服务端推送通知，一个“原生”应用必须有的功能。</li>\n<li><code>App Shell</code>: 先显示 Web 应用的主结构，再填充其他数据和结构，让加载过程更友好，用户体验更佳</li>\n<li><code>Service Worker</code>：另外的服务工作线程，在 Web 应用的后台执行，相比于 HTML5 提出的 Web Worker 功能更加强大。PWA 提供的新功能的逻辑，都需要在 Service Worker 中实现，例如下列基础功能：<ul>\n<li>管理 Web 应用生命周期（Manifest 的眼神）</li>\n<li>消息推送（Push Notification 的实现）</li>\n<li>不限域的获取或同步数据</li>\n<li>接受计算密集型数据的更新，多页面共享该数据</li>\n<li>拦截 Web 应用中的请求并做缓存。</li>\n<li>等等 ……</li>\n</ul>\n</li>\n</ul>\n<p>而列表中最后提到的，就是本文要谈到的 <code>SW Cache</code>，也就是 <code>Service Worker Cache</code>。就像 Service Worker 不是只用于 Cache 的，Service Worker Cache 也不是只用于静态资源缓存。它可以拦截 Web 应用所有请求，通过逻辑的实现，来配置自己的缓存策略，不仅仅能缓存静态资源，业务的动态数据接口也同样可以缓存。</p>\n<p>从 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API\" target=\"_blank\" rel=\"noopener\">MDN</a> 上可以找到 Service Worker 现在拥有的 API：</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fvam86ngcuj30dg0p2tb1.jpg\" alt=\"Server Worker API 列表\"></p>\n<p>其中，用于缓存的是 <code>Cache</code> 和 <code>CacheStorage</code>，只需要下面在 Service Worker 内的一段代码即可实现页面资源的缓存，并在离线时可用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 缓存的ID，唯一性标识，用于缓存的控制</span><br><span class=\"line\">const CACHE_ID = &quot;v1.0.0&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 为了保证线程不影响整个 Web 应用（同步 API 阻塞），Service Worker 中的 API 都是 Promise 的异步形式。</span><br><span class=\"line\">// cacheStorage.open() 获取的 Cache 对象，就是从全局对象里取的 caches 对象，因此可以直接使用 caches 对象。</span><br><span class=\"line\"></span><br><span class=\"line\">// Service Worker 安装事件（并不是 Web 应用安装到手机上，可以看出 Service Worker 开始充初始化的事件）</span><br><span class=\"line\">self.addEventListener(&apos;install&apos;, event =&gt; &#123;</span><br><span class=\"line\">    // event.waitUtil 用于在安装成功之前执行一些预装逻辑</span><br><span class=\"line\">    // 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span><br><span class=\"line\">    // 安装成功后 Service Worker 状态会从 installing 变为 installed</span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        // 使用 cache API 打开指定的 cache </span><br><span class=\"line\">        caches.open(CACHE_ID).then(cache =&gt; &#123;</span><br><span class=\"line\">            // 添加要缓存的资源列表</span><br><span class=\"line\">            return cache.addAll([</span><br><span class=\"line\">                &apos;./static/example.js&apos;,</span><br><span class=\"line\">                &apos;./static/example.css&apos;,</span><br><span class=\"line\">                &apos;./static/404.jpg&apos;,</span><br><span class=\"line\">                &apos;./index.html&apos;</span><br><span class=\"line\">            ]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Service Worker 激活时间，此事用于删除失效的缓存</span><br><span class=\"line\">self.addEventListener(&apos;activate&apos;, function (event) &#123;</span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        caches.keys().then(function (cacheIDs) &#123;</span><br><span class=\"line\">            return Promise.all(</span><br><span class=\"line\">                cacheIDs.map(function (cacheID) &#123;</span><br><span class=\"line\">                    // 如果获取到的版本和缓存版本不一致，则删除相应缓存</span><br><span class=\"line\">                    if (cacheID !== CACHE_ID) &#123;</span><br><span class=\"line\">                        return caches.delete(cacheID);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 拦截请求，做匹配，对于从线上请求的数据，将其缓存</span><br><span class=\"line\">self.addEventListener(&apos;fetch&apos;, function (event) &#123;</span><br><span class=\"line\">    // 从缓存中匹配相应请求</span><br><span class=\"line\">    event.respondWith(caches.match(event.request).catch(function () &#123;</span><br><span class=\"line\">        // 匹配失败，从线上请求</span><br><span class=\"line\">        return fetch(event.request);</span><br><span class=\"line\">    &#125;).then(function (response) &#123;</span><br><span class=\"line\">        // 将请求结果缓存</span><br><span class=\"line\">        caches.open(CACHE_ID).then(function (cache) &#123;</span><br><span class=\"line\">            cache.put(event.request, response);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return response.clone();</span><br><span class=\"line\">    &#125;).catch(function () &#123;</span><br><span class=\"line\">        // 发生错误，则从缓存里匹配相应的 Fallback 内容</span><br><span class=\"line\">        return caches.match(&apos;./static/404.jpg&apos;);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看出不论是缓存的内容，还是缓存的管理，甚至添加缓存，都是由开发者实现代码来控制的，让更新和缓存逻辑完全掌控在开发者手里。上面的代码只是个基本逻辑，开发者可以根据自身的情况，设计出符合自身情况的逻辑，例如说，公共资源与业务资源分开，使用不同的缓存（不同的 CACHE_ID），等等。笔者只是在这里抛砖引玉，具体的情况还需要具体分析。</p>\n<p>上文，在谈到 App Cache 时，提到 App Cache 与 Browser Cache 互相影响，纠缠不清。那么，SW Cache 和 Browser Cache 又是什么关系呢？请看下图。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fv3na9dpxjj30c7077dg5.jpg\" alt=\"SW Cache\"></p>\n<p>相比于 Browser Cache ，SW Cache 更偏向于应用层，和 Browser Cache 是串行关系。<strong>SW Cache 匹配失败的资源请求线上时，仍旧会走 Browser Cache。</strong> 因此，对于 Browser Cache 的服务端，只要不将缓存时间设置过长，就不会影响 SW Cache 的使用。</p>\n<p>总之，SW Cache 是一个想简单也异常简单，想复杂也可以复杂的开发者可控的缓存机制，可以让开发者根据资深情况定制不同的缓存策略。</p>\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h3><p>这一部分，主要讲了 Web 缓存，从浏览器缓存到 HTML5 的 App Cache，再到跨时代技术 PWA 的 SW Cache。与硬件或系统缓存不同，Web 缓存是最早运用在用户端应用层的缓存策略，从浏览器缓存的前端不可控，到 App Cache、SW Cache 方案中前端有一定的控制权，策略的改变体现了开发者对用户端缓存给予了越来越多的重视。</p>\n<p>谈到缓存，就不得不谈到另一个概念 —— <strong>热更新</strong>。Web 应用与传统的原生应用项目，最大的优势在于可以非常及时地使用到最新版本的应用，而不是像传统原生应用一样，必须删除应用后再从应用市场下载进行重装，其操作和时间成本都很高，尤其在细微的更新或者修复 Bug 时。因此，越来越多的原生应用参考 Web 应用的缓存策略，实现自己的资源热更新机制，让绝大多数资源的更新不需要通过应用市场来更新应用，而是通过自身的机制进行更新，降低用户的升级成本。其中，在游戏方面，由于游戏应用体积一般较大，不便于每次小调整都要从应用市场更新应用，因此，使用资源的热更新机制成为了不二选择。下图就是游戏《王者荣耀》的资源更新界面。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fvbg4nmz78j31kw0w0x6z.jpg\" alt=\"\"></p>\n<p>最后做个简单的总结：Web 缓存策略是广泛应用在每一个 Web 应用中，深入理解 Web 缓存策略有利于去优化 Web 应用的性能、提高 Web 应用的使用体验。同时，也有助于理解或设计原生客户端中的热更新策略，毕竟 Web 缓存策略是应用最广泛的，而所有新生的客户端热更新策略都会借鉴其经验。</p>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws4.sinaimg.cn/large/006tNbRwly1fuzvbbtcb0j30s60do407.jpg","excerpt":"<p>移动互联网时代，各种互联网技术层出不穷，尤其在移动端方面，各种动态化方案如雨后春笋般，在各自的领域蓬勃生长。但是，不管哪种方案，都会涉及到资源的迭代更新问题。如何让用户在更快地使用最新资源的同时，也能结合缓存保证应用的加载效率，是这类方案必须要考虑的。本文将从浏览器缓存谈起，在涵盖 App Cache、SW Cache 等纯 Web 缓存方案的同时，也将站在大前端角度去分析不同方案的差异，最终，让大家对 web 缓存策略有一个详尽的了解。","more":"</p>\n<h2 id=\"1-资源更新与缓存\"><a href=\"#1-资源更新与缓存\" class=\"headerlink\" title=\"1. 资源更新与缓存\"></a>1. 资源更新与缓存</h2><p>从互联网开始向大众普及，Web 技术就成为不能缺少的一部分，其资源控制权，也从用户端转向服务端，由服务端响应客户端的请求，并推送最新的资源。理论上，可以让用户每次都能使用到最新的资源，从而让产品迭代更快速、更有效。但是，这样的逻辑也带来了一些很严重的问题：</p>\n<ul>\n<li>当无网时，用户端取不到相应的资源，导致产品不可用。</li>\n<li>当弱网时，用户端获取资源速度很低，使产品加载缓慢，最终导致产品体验很差。 </li>\n</ul>\n<p>为了解决此类问题，必须要引入资源的本地暂存机制，也就是通常说的 —— <strong>缓存</strong>。缓存的出现，始于计算机对性能的要求。计算机为了在性能上能有指数级的增长，引入了缓存设计。简单说，存储和读取速度和硬件的成本成正比：相同空间的存储硬件，存取越快，成本越高。下图说明了计算机中缓存的设计，会分很多不同层级的缓存，当然内存也可以算作缓存的一种。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fv3lc27kpbj30go06y74t.jpg\" alt=\"缓存设计\"></p>\n<p>所以为了权衡，两者相结合，使得性价比最大。而这篇文章里主要讨论的是偏向用户端的缓存，与传统缓存类似，虽然缓存运用得越广泛，用户的体验越好，但同时也增加了相应的维护成本。</p>\n<p>Phil Karlton 说过一句广受大家共鸣的一句话：“There are only two hard things in Computer Science: cache invalidation and naming things.（命名和缓存失效是计算机科学里面最难对付的两件事）”，可以看出缓存是大家很难去维护但不得不去维护的策略。只要存在缓存，就能得到性能和体验上的提升；而在合适的时机删除之前缓存的资源并更新最新资源，却是一个很难完美解决的问题。</p>\n<p>当前缓存运用的场景，除了计算机硬件及系统以外，主要在数据库和网络资源两个主要方向。而其中，网络资源更多运用在用户端，尤其在 Web 技术中，浏览器基于网络协议配置的缓存是最常见，同时也是最贴近用户的使用场景。因此，为了让大家更好地了解缓存策略的细节，笔者将从 Web 缓存谈起。</p>\n<h2 id=\"2-Web-缓存\"><a href=\"#2-Web-缓存\" class=\"headerlink\" title=\"2. Web 缓存\"></a>2. Web 缓存</h2><p>之前，大家提到 Web 缓存，大多是指浏览器缓存。但随着 HTML5 的发展（App Cache）以及 PWA 技术的推广（SW Cache），前端工程师可以可以自由控制浏览器对资源的缓存。Web 缓存从服务端配置化逐渐演变为用户端逻辑化，从由浏览器自动控制到由工程师自主设计，使资源更新更灵活，但也带来一些不易解决的问题。</p>\n<p>下面，从最传统的浏览器缓存谈起，深入了解资源缓存的细节。</p>\n<h3 id=\"2-1-浏览器缓存-——-Browser-Cache（HTTP-客户端缓存）\"><a href=\"#2-1-浏览器缓存-——-Browser-Cache（HTTP-客户端缓存）\" class=\"headerlink\" title=\"2.1 浏览器缓存 —— Browser Cache（HTTP 客户端缓存）\"></a>2.1 浏览器缓存 —— Browser Cache（HTTP 客户端缓存）</h3><p>现在的大型网站，不管是 PC 端还是移动端，动不动就几十个请求，如果没有浏览器缓存的存在，用户体验会急剧下降，同时服务器压力和网络带宽都将面临严重的考验。因此，浏览器缓存是现代互联网中必不可少的一环。</p>\n<p>从技术角度讲，浏览器缓存是 HTTP 缓存机制中客户端部分的一个实现。</p>\n<p>HTTP 缓存机制分为两种，<strong>客户端缓存</strong> 和 <strong>服务端缓存</strong> ，而服务端缓存又分为 <strong>代理服务器缓存</strong>（例：CDN 服务）和 <strong>反向代理服务器缓存</strong>（例：Nginx 反向代理服务）。由于篇幅有限，服务端缓存部分就不加赘述了。</p>\n<p>关于客户端缓存，浏览器缓存是其中的一种实现形式，在浏览器内核中实现基于 HTTP 缓存机制的缓存。当然，在各类网络请求的开发库中，也实现了几乎同样的逻辑。这些逻辑，都是基于 HTTP 协议中的 HEADER 来实现的，根据  HEADER 中相应配置的不同，执行不同的缓存逻辑。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fv3nmog9rpj30dw05twf1.jpg\" alt=\"HTTP 报文结构\"></p>\n<p>对于客户端整体缓存逻辑，大家应该比较清楚：判断是否有缓存，如果有就直接使用缓存中的内容，如果没有则进行网络请求获取内容。（如下图）</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fv3nw5x397j30lb09amxe.jpg\" alt=\"HTTP 客户端整体缓存逻辑\"></p>\n<p>但是客户端怎么根据 HTTP 的 HEADER 来更为细化地控制缓存的呢？其实 HTTP 客户端缓存有两种不同的策略机制：</p>\n<ul>\n<li><strong>服务端决策缓存</strong>：由服务端决定并告知客户端是否使用缓存。</li>\n<li><strong>客户端决策缓存</strong>：服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。</li>\n</ul>\n<p>对于这两种策略机制的区别，最明显的表象是：从 Chrome DevTool 中 Network 面板里看到缓存的请求，服务端决策缓存在 Status 一栏显示的是 <code>304</code>，而客户端决策缓存在 Status 一栏显示的是 <code>200</code>，不过在 Size 一栏会显示 <code>from disk cache</code>。这两种策略机制，从解释中就可以看出，区别在于上图中的检查是否有缓存的部分。</p>\n<p>道上常说，有图有真相，所以先把两种策略机制的流程图奉上，每种策略机制都分有 <strong>缓存命中</strong> 和 <strong>缓存未命中</strong> 两种情况。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fv3pcj7k4ej30qo0ub76e.jpg\" alt=\"HTTP 客户端缓存策略流程图\"></p>\n<p>这两种缓存策略机制主要是由 HTTP Header 中的 <code>Cache-Control</code> 来决定和控制使用的。此属性常见的取值有以下6类：</p>\n<ul>\n<li><code>public</code>：全部缓存，包括客户端和服务端（时长 365 天）</li>\n<li><code>private</code>：仅客户端缓存（时长 365 天）</li>\n<li><code>no-cache</code>：不适用客户端的缓存，使用“服务端决策缓存”。并不是表面意义上的“不使用缓存”。</li>\n<li><code>no-store</code>：所有内容都不会被缓存，不论哪种策略机制都不会被缓存。不同浏览器对这种情况的实现不同，有些浏览器是不缓存，有些是在特定实际清除缓存，例如当前页面关闭、浏览器关闭等。</li>\n<li><code>must-revalidation/proxy-revalidation</code>：如果缓存内容失效，请求必须发送服务器/代理进行验证。也就是当“客户端决策缓存”未命中时，使用“服务端决策缓存”，理论上是最优的缓存策略。不过，只有最新的部分浏览器和网络库支持此配置，还未普及。</li>\n<li><code>max-age=&lt;s&gt;</code>：缓存内容在s秒后失效，仅 HTTP 1.1 可用。（HTTP 1.0 可以用 <code>Expires</code>）</li>\n</ul>\n<p>其中，对于前端资源，最常用的是 <code>Cache-Control: no-cache</code> 和 <code>Cache-Control: max-age=123</code>，分别对应笔者上文提到的两种策略机制。而对于数据请求，一般使用 <code>Cache-Control: no-store</code> 来保证每次数据都是新的，而由于前文提到 <code>no-store</code> 的实现方式有异，最好还是加随机参数来避免缓存。</p>\n<p>当然，<code>Cache-Control</code> 不仅仅这六类取值，更多的可以直接查看 HTTP 1.1 协议文档 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9\" target=\"_blank\" rel=\"noopener\">rfc2616</a>。</p>\n<p>在上面的流程图中，提到了“缓存标识”，此标识也是使用 HTTP Header 进行通信的，可以使用 <code>Etag/If-None-Match</code> 或 <code>Last-Modified/If-Modified-Since</code> 对资源进行标识，前者是资源的特征值，也可看做为标识符，而后者则是资源的更新时间。具体使用哪个，由服务端获取特征值和修改时间的效率决定，使用效率较好的一个。当然，这两个标识可以同时使用，此时 <code>Etag/If-None-Match</code> 的优先级要高于 <code>Last-Modified/If-Modified-Since</code>。</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/0069RVTdly1fv3rnvfn9sj317e0p6qae.jpg\" alt=\"Header 截图\"></p>\n<p>从上文来看，<code>Cache-Control: must-revalidation</code> 或许是最优的缓存机制，不过由于支持度有限，而且有时候缓存策略跟业务逻辑有关，因此前端需要一种更自由，更定制化的缓存机制，因此 HTML5 的 App Cache 的出现，给广大前端开发者打了一大盆鸡血，不过事实如何呢？</p>\n<h3 id=\"2-2-HTML5-性特性-——-App-Cache\"><a href=\"#2-2-HTML5-性特性-——-App-Cache\" class=\"headerlink\" title=\"2.2 HTML5 性特性 —— App Cache\"></a>2.2 HTML5 性特性 —— App Cache</h3><p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fv3qsgxvazj30hq09zmye.jpg\" alt=\"\"></p>\n<p>笔者在 2014 年开发 Hybrid 框架时，调研过 App Cache。虽然当时已经有了相应的标准（<a href=\"https://www.w3.org/TR/2012/WD-html5-20120329/offline.html#offline\" target=\"_blank\" rel=\"noopener\">WD-html5-20120329</a> ），但当时浏览器对 App Cache 的支持程度很差，很多浏览器实现的方式也不同，让笔者很是苦恼。不过，经过这几年的发展，App Cache 的完善度越来越高，也有更多的开发者采用此技术。</p>\n<p>App Cache 本质上是通过一个配置文件（<code>Manifest</code>）来决定访问资源的缓存策略，并提供相应的状态和事件让开发者可以有效利用它。</p>\n<p>App Cache 配置文件如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\"># 需要缓存的列表</span><br><span class=\"line\">local.jpg</span><br><span class=\"line\">static.js</span><br><span class=\"line\">unupdate.css</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\"># 需要请求网络的资源</span><br><span class=\"line\">network.jpg</span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\"># 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件*.html /offline.html</span><br><span class=\"line\">index.html /404.html</span><br></pre></td></tr></table></figure>\n<p>在页面的 <code>html</code> 标签内加入，此配置文件，即可让 App Cache 生效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br><span class=\"line\">&lt;html manifest=&quot;filename.appcache&quot;&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>可见，配置中对不同资源的缓存策略进行了分别的定义。这样，开发可以自由控制不同文件的缓存策略，而不需要服务端针对不同的文件进行特殊的配置。为了让开发者可以对缓存中资源更新的情况有更多的了解，App Cache 方案给用户提供了 <code>cached</code> 、<code>checking</code> 、<code>downloading</code> 、<code>error</code> 、<code>noupdate</code> 、<code>obsolete</code> 、<code>progress</code> 、<code>updateready</code> 8个事件（<code>window.applicationCache.on(&#39;someEvent&#39;)</code>），以及 <code>status</code>（<code>window.applicationCache.status</code>）来标识它的状态。下图中，标识出每个事件的时机以及相应的 <code>status</code> 的取值。</p>\n<p><img src=\"https://ws1.sinaimg.cn/large/0069RVTdly1fv3swsojzej30sa0sy0vf.jpg\" alt=\"App Cache 流程图\"></p>\n<p>此外，开发者还可以使用 <code>window.applicationCache.update()</code> 方法强制启动更新逻辑，使用 <code>window.applicationCache.abort()</code> 方法强制停止更新逻辑。</p>\n<p>从上文，看出 App Cache 提供一套配置化的缓存方案，通过配置来控制不同资源的缓存策略，但对在线更新并未提供太多机制和优化方案。而且 App Cache 与 Browser Cache 在逻辑上属于同一层次，对于它们之间如何协同工作，HTML5 的相关规范没有对具体细节给出非常明确的规定，同时，浏览器官方文档也没有给出非常明确的说明。这就造成在不同的浏览器，可能需要使用不同的配置和方案，来保证缓存策略的正确性，这样会使出错的几率上升。并且当出错时，你很有可能遇到计算机科学里面最难对付的两件事之一的缓存失效问题，甚至于只能让用户主动清除缓存才能解决问题。除去技术上的问题，一个项目使用 App Cache ，不仅仅需要前端开发人员，同时也需要服务端配合，这样让成本成倍增加，包括之后的维护成本也会成倍增加。总结下来，这些问题，都是 App Cache 没有被广泛使用的原因。</p>\n<p>App Cache 看似盛宴，却又不堪，如何来真正解决资源更新和缓存问题？Google 推出的 PWA 方案给出了另一种思路。</p>\n<h3 id=\"2-3-PWA-的大跨步-——-SW-Cache\"><a href=\"#2-3-PWA-的大跨步-——-SW-Cache\" class=\"headerlink\" title=\"2.3 PWA 的大跨步 —— SW Cache\"></a>2.3 PWA 的大跨步 —— SW Cache</h3><p>PWA，全称是 Progressive Web App，渐进式 Web 应用。是 Google 2015 年提出，2016 年年中才着力推广的全新前端技术。其实与其说它是一项技术，还不如将它理解为一个方向，而这个方向的目标就是 <strong>在 Web 应用中实现与原生应用相近的用户体验</strong> 。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/71c50075ly1fvafqtz828j20m80b474t.jpg\" alt=\"PWA VS Native\"></p>\n<p>官网上给出 PWA 宣传的重点词是 ： <strong>Reliable</strong> （ 可靠的 ）、<strong>Fast</strong>（ 快速的 ）、<strong>Engaging</strong>（ 可参与的 ）。</p>\n<p><img src=\"https://ws4.sinaimg.cn/large/006tNbRwly1fvacbdprvuj30fe066dg5.jpg\" alt=\"PWA\"></p>\n<p>而为了实现这三个特点，让 Web 应用更贴近原生应用，PWA 优先提供了下面几个个关键技术（相信后面会不断补充更多的技术）：</p>\n<ul>\n<li><code>Manifest</code>：是一个 W3C 规范，它定义了一个基于 JSON 的配置文件，让 Web 应用可以和原生应用一样可以被安装，并在屏幕上有自己的入口。</li>\n<li><code>Push Notification</code>：接收服务端推送通知，一个“原生”应用必须有的功能。</li>\n<li><code>App Shell</code>: 先显示 Web 应用的主结构，再填充其他数据和结构，让加载过程更友好，用户体验更佳</li>\n<li><code>Service Worker</code>：另外的服务工作线程，在 Web 应用的后台执行，相比于 HTML5 提出的 Web Worker 功能更加强大。PWA 提供的新功能的逻辑，都需要在 Service Worker 中实现，例如下列基础功能：<ul>\n<li>管理 Web 应用生命周期（Manifest 的眼神）</li>\n<li>消息推送（Push Notification 的实现）</li>\n<li>不限域的获取或同步数据</li>\n<li>接受计算密集型数据的更新，多页面共享该数据</li>\n<li>拦截 Web 应用中的请求并做缓存。</li>\n<li>等等 ……</li>\n</ul>\n</li>\n</ul>\n<p>而列表中最后提到的，就是本文要谈到的 <code>SW Cache</code>，也就是 <code>Service Worker Cache</code>。就像 Service Worker 不是只用于 Cache 的，Service Worker Cache 也不是只用于静态资源缓存。它可以拦截 Web 应用所有请求，通过逻辑的实现，来配置自己的缓存策略，不仅仅能缓存静态资源，业务的动态数据接口也同样可以缓存。</p>\n<p>从 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API\" target=\"_blank\" rel=\"noopener\">MDN</a> 上可以找到 Service Worker 现在拥有的 API：</p>\n<p><img src=\"https://ws2.sinaimg.cn/large/006tNbRwly1fvam86ngcuj30dg0p2tb1.jpg\" alt=\"Server Worker API 列表\"></p>\n<p>其中，用于缓存的是 <code>Cache</code> 和 <code>CacheStorage</code>，只需要下面在 Service Worker 内的一段代码即可实现页面资源的缓存，并在离线时可用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 缓存的ID，唯一性标识，用于缓存的控制</span><br><span class=\"line\">const CACHE_ID = &quot;v1.0.0&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 为了保证线程不影响整个 Web 应用（同步 API 阻塞），Service Worker 中的 API 都是 Promise 的异步形式。</span><br><span class=\"line\">// cacheStorage.open() 获取的 Cache 对象，就是从全局对象里取的 caches 对象，因此可以直接使用 caches 对象。</span><br><span class=\"line\"></span><br><span class=\"line\">// Service Worker 安装事件（并不是 Web 应用安装到手机上，可以看出 Service Worker 开始充初始化的事件）</span><br><span class=\"line\">self.addEventListener(&apos;install&apos;, event =&gt; &#123;</span><br><span class=\"line\">    // event.waitUtil 用于在安装成功之前执行一些预装逻辑</span><br><span class=\"line\">    // 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span><br><span class=\"line\">    // 安装成功后 Service Worker 状态会从 installing 变为 installed</span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        // 使用 cache API 打开指定的 cache </span><br><span class=\"line\">        caches.open(CACHE_ID).then(cache =&gt; &#123;</span><br><span class=\"line\">            // 添加要缓存的资源列表</span><br><span class=\"line\">            return cache.addAll([</span><br><span class=\"line\">                &apos;./static/example.js&apos;,</span><br><span class=\"line\">                &apos;./static/example.css&apos;,</span><br><span class=\"line\">                &apos;./static/404.jpg&apos;,</span><br><span class=\"line\">                &apos;./index.html&apos;</span><br><span class=\"line\">            ]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Service Worker 激活时间，此事用于删除失效的缓存</span><br><span class=\"line\">self.addEventListener(&apos;activate&apos;, function (event) &#123;</span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        caches.keys().then(function (cacheIDs) &#123;</span><br><span class=\"line\">            return Promise.all(</span><br><span class=\"line\">                cacheIDs.map(function (cacheID) &#123;</span><br><span class=\"line\">                    // 如果获取到的版本和缓存版本不一致，则删除相应缓存</span><br><span class=\"line\">                    if (cacheID !== CACHE_ID) &#123;</span><br><span class=\"line\">                        return caches.delete(cacheID);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 拦截请求，做匹配，对于从线上请求的数据，将其缓存</span><br><span class=\"line\">self.addEventListener(&apos;fetch&apos;, function (event) &#123;</span><br><span class=\"line\">    // 从缓存中匹配相应请求</span><br><span class=\"line\">    event.respondWith(caches.match(event.request).catch(function () &#123;</span><br><span class=\"line\">        // 匹配失败，从线上请求</span><br><span class=\"line\">        return fetch(event.request);</span><br><span class=\"line\">    &#125;).then(function (response) &#123;</span><br><span class=\"line\">        // 将请求结果缓存</span><br><span class=\"line\">        caches.open(CACHE_ID).then(function (cache) &#123;</span><br><span class=\"line\">            cache.put(event.request, response);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return response.clone();</span><br><span class=\"line\">    &#125;).catch(function () &#123;</span><br><span class=\"line\">        // 发生错误，则从缓存里匹配相应的 Fallback 内容</span><br><span class=\"line\">        return caches.match(&apos;./static/404.jpg&apos;);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看出不论是缓存的内容，还是缓存的管理，甚至添加缓存，都是由开发者实现代码来控制的，让更新和缓存逻辑完全掌控在开发者手里。上面的代码只是个基本逻辑，开发者可以根据自身的情况，设计出符合自身情况的逻辑，例如说，公共资源与业务资源分开，使用不同的缓存（不同的 CACHE_ID），等等。笔者只是在这里抛砖引玉，具体的情况还需要具体分析。</p>\n<p>上文，在谈到 App Cache 时，提到 App Cache 与 Browser Cache 互相影响，纠缠不清。那么，SW Cache 和 Browser Cache 又是什么关系呢？请看下图。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/0069RVTdly1fv3na9dpxjj30c7077dg5.jpg\" alt=\"SW Cache\"></p>\n<p>相比于 Browser Cache ，SW Cache 更偏向于应用层，和 Browser Cache 是串行关系。<strong>SW Cache 匹配失败的资源请求线上时，仍旧会走 Browser Cache。</strong> 因此，对于 Browser Cache 的服务端，只要不将缓存时间设置过长，就不会影响 SW Cache 的使用。</p>\n<p>总之，SW Cache 是一个想简单也异常简单，想复杂也可以复杂的开发者可控的缓存机制，可以让开发者根据资深情况定制不同的缓存策略。</p>\n<h3 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h3><p>这一部分，主要讲了 Web 缓存，从浏览器缓存到 HTML5 的 App Cache，再到跨时代技术 PWA 的 SW Cache。与硬件或系统缓存不同，Web 缓存是最早运用在用户端应用层的缓存策略，从浏览器缓存的前端不可控，到 App Cache、SW Cache 方案中前端有一定的控制权，策略的改变体现了开发者对用户端缓存给予了越来越多的重视。</p>\n<p>谈到缓存，就不得不谈到另一个概念 —— <strong>热更新</strong>。Web 应用与传统的原生应用项目，最大的优势在于可以非常及时地使用到最新版本的应用，而不是像传统原生应用一样，必须删除应用后再从应用市场下载进行重装，其操作和时间成本都很高，尤其在细微的更新或者修复 Bug 时。因此，越来越多的原生应用参考 Web 应用的缓存策略，实现自己的资源热更新机制，让绝大多数资源的更新不需要通过应用市场来更新应用，而是通过自身的机制进行更新，降低用户的升级成本。其中，在游戏方面，由于游戏应用体积一般较大，不便于每次小调整都要从应用市场更新应用，因此，使用资源的热更新机制成为了不二选择。下图就是游戏《王者荣耀》的资源更新界面。</p>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tNbRwly1fvbg4nmz78j31kw0w0x6z.jpg\" alt=\"\"></p>\n<p>最后做个简单的总结：Web 缓存策略是广泛应用在每一个 Web 应用中，深入理解 Web 缓存策略有利于去优化 Web 应用的性能、提高 Web 应用的使用体验。同时，也有助于理解或设计原生客户端中的热更新策略，毕竟 Web 缓存策略是应用最广泛的，而所有新生的客户端热更新策略都会借鉴其经验。</p>"},{"title":"2019 · 新的开始","date":"2019-01-01T10:00:00.000Z","thumbnailImage":"https://ws4.sinaimg.cn/large/006tNbRwly1fyr87t0arnj30g60ncdgq.jpg","thumbnailImagePosition":"right","_content":"\n2018 年，步入了幸福的婚姻殿堂，同时也换了份工作。\n2019 年，将带着不同的家庭身份和工作身份，执着地向前奔跑。\n有些时候，总结与愿望更多拘泥于文字，而更多的行动或许会最好的例证。\n2019 做好自己，既往不恋，纵情向前。\n\n<!-- more -->\n\n\n\n","source":"_posts/2019-01-01-The_Next_Year_2019.md","raw":"title: 2019 · 新的开始\ndate: 2019-01-01 18:00:00\ncategory: 随笔\ntags: [2019]\nthumbnailImage: https://ws4.sinaimg.cn/large/006tNbRwly1fyr87t0arnj30g60ncdgq.jpg\nthumbnailImagePosition: right\n---\n\n2018 年，步入了幸福的婚姻殿堂，同时也换了份工作。\n2019 年，将带着不同的家庭身份和工作身份，执着地向前奔跑。\n有些时候，总结与愿望更多拘泥于文字，而更多的行动或许会最好的例证。\n2019 做好自己，既往不恋，纵情向前。\n\n<!-- more -->\n\n\n\n","slug":"2019-01-01-The_Next_Year_2019","published":1,"updated":"2019-01-01T10:49:55.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqhgoc7d0015hxp4r9nta2ge","content":"<p>2018 年，步入了幸福的婚姻殿堂，同时也换了份工作。<br>2019 年，将带着不同的家庭身份和工作身份，执着地向前奔跑。<br>有些时候，总结与愿望更多拘泥于文字，而更多的行动或许会最好的例证。<br>2019 做好自己，既往不恋，纵情向前。</p>\n<a id=\"more\"></a>\n","site":{"data":{}},"thumbnailImageUrl":"https://ws4.sinaimg.cn/large/006tNbRwly1fyr87t0arnj30g60ncdgq.jpg","excerpt":"<p>2018 年，步入了幸福的婚姻殿堂，同时也换了份工作。<br>2019 年，将带着不同的家庭身份和工作身份，执着地向前奔跑。<br>有些时候，总结与愿望更多拘泥于文字，而更多的行动或许会最好的例证。<br>2019 做好自己，既往不恋，纵情向前。</p>","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cjqhgoc700009hxp4i5sf1c9w","category_id":"cjqhgoc6x0005hxp4ezqrqcop","_id":"cjqhgoc75000fhxp4qp6atrp4"},{"post_id":"cjqhgoc6s0001hxp4eivhq11h","category_id":"cjqhgoc6x0005hxp4ezqrqcop","_id":"cjqhgoc77000jhxp4tp1j21fi"},{"post_id":"cjqhgoc6v0003hxp4oamombca","category_id":"cjqhgoc6x0005hxp4ezqrqcop","_id":"cjqhgoc77000mhxp41l2fd5sy"},{"post_id":"cjqhgoc76000ihxp4yh2ngv78","category_id":"cjqhgoc6x0005hxp4ezqrqcop","_id":"cjqhgoc79000shxp43xv7qk5c"},{"post_id":"cjqhgoc6z0007hxp44ibzu5b5","category_id":"cjqhgoc76000ghxp45ssbqdm9","_id":"cjqhgoc7a000whxp4abstsou7"},{"post_id":"cjqhgoc78000qhxp4hfczmlli","category_id":"cjqhgoc6x0005hxp4ezqrqcop","_id":"cjqhgoc7b000zhxp49zg3jv21"},{"post_id":"cjqhgoc71000ahxp4svaunn58","category_id":"cjqhgoc78000ohxp4e20wlxe1","_id":"cjqhgoc7c0013hxp4rzalbnku"},{"post_id":"cjqhgoc7a000vhxp4yyn7aeut","category_id":"cjqhgoc76000ghxp45ssbqdm9","_id":"cjqhgoc7e0016hxp4tdw0z2lr"},{"post_id":"cjqhgoc73000dhxp4p2nuyhpa","category_id":"cjqhgoc76000ghxp45ssbqdm9","_id":"cjqhgoc7f0018hxp4m0p8def6"},{"post_id":"cjqhgoc7b000yhxp4g1ydqsg7","category_id":"cjqhgoc76000ghxp45ssbqdm9","_id":"cjqhgoc7f001ahxp482kwvkfc"},{"post_id":"cjqhgoc75000ehxp44s19ubrl","category_id":"cjqhgoc76000ghxp45ssbqdm9","_id":"cjqhgoc7g001ehxp42vxly39k"},{"post_id":"cjqhgoc7d0015hxp4r9nta2ge","category_id":"cjqhgoc6x0005hxp4ezqrqcop","_id":"cjqhgoc7g001ghxp4c0ezjd3n"},{"post_id":"cjqhgoc77000lhxp4ey5j0d9y","category_id":"cjqhgoc78000ohxp4e20wlxe1","_id":"cjqhgoc7g001jhxp451c6gssr"},{"post_id":"cjqhgoc79000rhxp4fy3lrvyk","category_id":"cjqhgoc7f001bhxp45qbyl1g5","_id":"cjqhgoc7h001lhxp4i2webojl"}],"PostTag":[{"post_id":"cjqhgoc6s0001hxp4eivhq11h","tag_id":"cjqhgoc6y0006hxp4vwgbr7to","_id":"cjqhgoc77000khxp4r4s1obtd"},{"post_id":"cjqhgoc6s0001hxp4eivhq11h","tag_id":"cjqhgoc72000chxp4chrk9osk","_id":"cjqhgoc77000nhxp4q1zg6djf"},{"post_id":"cjqhgoc6v0003hxp4oamombca","tag_id":"cjqhgoc76000hhxp4glwj9ywl","_id":"cjqhgoc7b000xhxp4jm3rqexv"},{"post_id":"cjqhgoc6v0003hxp4oamombca","tag_id":"cjqhgoc78000phxp4hn50gon4","_id":"cjqhgoc7b0011hxp4u2yy4zrw"},{"post_id":"cjqhgoc6z0007hxp44ibzu5b5","tag_id":"cjqhgoc7a000uhxp4aw8aegsw","_id":"cjqhgoc7g001fhxp4o6fa7303"},{"post_id":"cjqhgoc6z0007hxp44ibzu5b5","tag_id":"cjqhgoc7c0014hxp4rra6nd95","_id":"cjqhgoc7g001hhxp4kj9nzl7y"},{"post_id":"cjqhgoc6z0007hxp44ibzu5b5","tag_id":"cjqhgoc7f0019hxp461ndu25p","_id":"cjqhgoc7h001khxp4p79b6d1z"},{"post_id":"cjqhgoc700009hxp4i5sf1c9w","tag_id":"cjqhgoc7a000uhxp4aw8aegsw","_id":"cjqhgoc7h001nhxp4pv0xzo13"},{"post_id":"cjqhgoc700009hxp4i5sf1c9w","tag_id":"cjqhgoc7g001ihxp48pfh6v0a","_id":"cjqhgoc7h001ohxp43ghcjcav"},{"post_id":"cjqhgoc71000ahxp4svaunn58","tag_id":"cjqhgoc7h001mhxp4upsltv4d","_id":"cjqhgoc7h001qhxp4vw2zdr2f"},{"post_id":"cjqhgoc73000dhxp4p2nuyhpa","tag_id":"cjqhgoc7f0019hxp461ndu25p","_id":"cjqhgoc7i001shxp4i8nioqi9"},{"post_id":"cjqhgoc75000ehxp44s19ubrl","tag_id":"cjqhgoc7a000uhxp4aw8aegsw","_id":"cjqhgoc7j001whxp47kzqjy0f"},{"post_id":"cjqhgoc75000ehxp44s19ubrl","tag_id":"cjqhgoc7i001thxp4haso1bar","_id":"cjqhgoc7j001xhxp4jy8wc7op"},{"post_id":"cjqhgoc75000ehxp44s19ubrl","tag_id":"cjqhgoc7f0019hxp461ndu25p","_id":"cjqhgoc7j001zhxp46sorxaoy"},{"post_id":"cjqhgoc76000ihxp4yh2ngv78","tag_id":"cjqhgoc7g001ihxp48pfh6v0a","_id":"cjqhgoc7j0020hxp4uzj892n0"},{"post_id":"cjqhgoc77000lhxp4ey5j0d9y","tag_id":"cjqhgoc7j001yhxp48bt36jrk","_id":"cjqhgoc7k0022hxp4ku0d6oa6"},{"post_id":"cjqhgoc78000qhxp4hfczmlli","tag_id":"cjqhgoc7j0021hxp413l08kga","_id":"cjqhgoc7k0024hxp4vlojqvs8"},{"post_id":"cjqhgoc79000rhxp4fy3lrvyk","tag_id":"cjqhgoc7k0023hxp4jfg8aaph","_id":"cjqhgoc7k0026hxp4xifkj20n"},{"post_id":"cjqhgoc7a000vhxp4yyn7aeut","tag_id":"cjqhgoc7k0025hxp42yv6f046","_id":"cjqhgoc7l0029hxp47fq7cyvs"},{"post_id":"cjqhgoc7a000vhxp4yyn7aeut","tag_id":"cjqhgoc7f0019hxp461ndu25p","_id":"cjqhgoc7l002ahxp48hxh2kqb"},{"post_id":"cjqhgoc7b000yhxp4g1ydqsg7","tag_id":"cjqhgoc7l0028hxp4356z9qfe","_id":"cjqhgoc7l002dhxp44ac00aaa"},{"post_id":"cjqhgoc7b000yhxp4g1ydqsg7","tag_id":"cjqhgoc7l002bhxp4x2skf864","_id":"cjqhgoc7l002ehxp4c57bc2yq"},{"post_id":"cjqhgoc7d0015hxp4r9nta2ge","tag_id":"cjqhgoc7m002fhxp4ze4qoc0h","_id":"cjqhgoc7m002hhxp47j4utk7x"}],"Tag":[{"name":"Weibo","_id":"cjqhgoc6y0006hxp4vwgbr7to"},{"name":"IM","_id":"cjqhgoc72000chxp4chrk9osk"},{"name":"前端","_id":"cjqhgoc76000hhxp4glwj9ywl"},{"name":"全栈","_id":"cjqhgoc78000phxp4hn50gon4"},{"name":"Mobile","_id":"cjqhgoc7a000uhxp4aw8aegsw"},{"name":"Debug","_id":"cjqhgoc7c0014hxp4rra6nd95"},{"name":"Hybrid","_id":"cjqhgoc7f0019hxp461ndu25p"},{"name":"D2","_id":"cjqhgoc7g001ihxp48pfh6v0a"},{"name":"Docker","_id":"cjqhgoc7h001mhxp4upsltv4d"},{"name":"Bridge","_id":"cjqhgoc7i001thxp4haso1bar"},{"name":"区块链","_id":"cjqhgoc7j001yhxp48bt36jrk"},{"name":"职业规划","_id":"cjqhgoc7j0021hxp413l08kga"},{"name":"Design","_id":"cjqhgoc7k0023hxp4jfg8aaph"},{"name":"动态化","_id":"cjqhgoc7k0025hxp42yv6f046"},{"name":"资源更新","_id":"cjqhgoc7l0028hxp4356z9qfe"},{"name":"缓存","_id":"cjqhgoc7l002bhxp4x2skf864"},{"name":"简悟","_id":"cjqhgoc7l002chxp4rpa3og50"},{"name":"2019","_id":"cjqhgoc7m002fhxp4ze4qoc0h"}]}}